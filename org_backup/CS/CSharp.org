#+TITLE: C# .Net
#+KEYWORDS: CSharp, .Net
#+OPTIONS: H:2 toc:2 num:3 ^:nil
#+SETUPFILE: ~/github/notes/org-html-themes/setup/theme-readtheorg.setup
* 类
* 集合
#+BEGIN_VERSE
一般集合类在 System.Collections(ArrayList)
泛型集合类在 System.Collections.Generic
特定类型的集合类在 System.Collections.Specialized
线程安全的集合类在 System.Collections.Concurrent
#+END_VERSE
** 集合接口一览
| 接口                      | 说明                                                                                          |
|---------------------------+-----------------------------------------------------------------------------------------------|
| IEnumerable<T>            | 实现了该接口可用 foreach 遍历，定义了方法 GetEnumerator()，返回一个实现了 IEnumerator 接口的枚举。 |
| ICollection<T>            | 定义了 Count 属性、复制到数组的 CopyTo()、Add()、Remove()、Clear()                               |
| IList<T>                  | 继承自 ICollection。增加了一个索引器(List[index])，可以在指定位置插入删除项 Insert()和 RemoveAt() |
| IDictionary<TKey, TValue> | 键值对泛型集合。一键一值。                                                                    |
| ILookup<TKey, TValue>     | 类似于 IDictionary。一键多值。                                                                 |
| IComparable<T>            | 定义方法 CompareTo()                                                                           |
| IComparer<T>              | 由比较器实现，定义 Compare()方法用于排序。                                                     |
** List
*** 创建
#+begin_src csharp
  var intList = new List<int>(); //默认创建容量为 4 个元素，如果 Add 时超出最大容量，则将最大容量*2
  var intList = new List<int>(10);//指定先创建 10 个元素的容量，Add 时超出，处理和上面一样
  intList.Capacity = 20;//还可以使用 Capacity 设定
  intList.TrimExcess();//不希望再往 List 中添加元素时使用。去除不需要的容量
#+end_src
容量改变了整个集合就会被分配一个新的内存块。

** 性能
| Collection       | Add       | Insert  | Remove         | Item    | Sort                | Find |
|------------------+-----------+---------+----------------+---------+---------------------+------|
| List             | O(1)/O(n) | O(n)    | O(n)           | O(1)    | B:O(nlong) W:O(n^2) | O(n) |
| Stack            | O(1)/O(n) | na      | Pop(),O(1)     | na      | na                  | na   |
| Queue            | O(1)/O(n) | na      | Dequeue(),O(1) | na      | na                  | na   |
| HashSet          | O(1)/O(n) | 同 Add() | O(1)           | na      | na                  | na   |
| LinkedList       | O(1)      | O(1)    | O(1)           | na      | na                  | O(n) |
| Dictionary       | O(1)/O(n) | na      | O(1)           | O(1)    | na                  | na   |
| SortedDictionary | O(nlogn)  | na      | O(n)           | O(logn) | na                  | na   |

* 异常
- try...finally...语句块(非异常常规用法)
#+BEGIN_VERSE
省略 catch，当 try 中语句有多个出口时，可以确保再出去前执行 finally 中的代码。
这看上去不错。
但是当 try 中真有异常发生时，程序会抛出异常，并且 finally 语句块不会正常执行！
#+END_VERSE
- 可执行程序应捕获尽可能多的异常，类库最好不要捕获异常
* 反射
** 自定义特性
*** 概述
#+begin_src csharp
  [FieldNameAttribute("Name")]
  //[FieldName("Name")]与上一条效果一样。说明"Attribute"是可省略的。
  public string Name
  {
      get ; set ;
  }
#+end_src
#+BEGIN_VERSE
编译器发现这个 *属性* 应用了 FieldName 特性后，首先会将 Attribute 加上，
即变成 FieldNameAttribute 特性。然后再其所使用的所有命名空间中搜索特性
处理类(本例为 FieldNameAttribute 类)。定义了特性的这个类直接或者间接的
继承了 System.Attribute 类，编译器还会认为该类包含控制特性用法的信息。

如果编译器找不到对应的特性类，或者使用特性的方式与特性类中的信息不匹配，
编译器会报错。
#+END_VERSE
*** 定义特性类
#+begin_src csharp
  [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field,
                  AllowMultiple=false,
                  Inherited=false)]
  public class FieldNameAttribute : Attribute
  {
      private string name;
      public FieldNameAttribute(string name)
          {
              this.name = name;
          }
  }
#+end_src
#+BEGIN_VERSE
首先，特性类本身用一个内建的特性 AttributeUsage 标记。

第一个参数 AttributeTargets 为必选项，指定应用到哪些类型的元素上(示例表示该特性能用在属性或成员变量上)。
Assembly 和 Module 类型有些特殊，说明该特性可以应用到整个程序集或模块的各类型元素中。
使用时需用关键字 assembly 或 module 作为前缀：[assembly:SomeAssemblyAttribute(Parameters)]
另一个应用到全局元素的类型是 AttributeTargets.All。

第二个参数表示是否可以多次用在同一个程序元素上。(可选参数)

第三个参数表示特性应用在类或接口上时，是否可由子类继承。(可选参数)
#+END_VERSE
*** 指定特性所接受的参数
#+BEGIN_VERSE
当编译遇到如下语句时：
[FieldName("Name")]
将查找特性类中是否有参数为字符串类型的构造函数。
#+END_VERSE
- 指定可选参数
#+BEGIN_VERSE
在特性类中添加属性，以支持特性可选参数。
[FieldName("Name", Comment="This is a primary key")
Comment 必须在特性类 FieldNameAttribute 中是一个 string 类型的属性。
#+END_VERSE

** 反射
*** System.Type 类
#+BEGIN_VERSE
通过该类，可以访问关于任何数据类型的信息。

使用 Type 类为了存储类型的引用。
Type t = typeof(double);

也可以这样使用：
double d = 0;
Type t = d.GetType();
GetType()是.Net 基类 System.Object 的方法。

还可以使用 Type 类的静态方法手工指定类型：
Type t = Type.GetType("System.Double");

还可以获取定义该类型的程序集的引用：
Type t = typeof(CustomizeClass);
Assembly containingAssembly = new Assembly(t);
#+END_VERSE
**** Type 类常用属性
Name、FullName、Namespace、BaseType、UnderlyingSystemType、IsClass(IsAbstract、IsEnum 等。
**** Type 类方法
GetMethod、GetMethods
*** System.Reflection.Assembly 类
#+BEGIN_VERSE
System.Reflection.Assembly 可以用于访问给定程序集的相关信息。

首先使用 Load 或者 LoadForm 加载程序集。
- Assembly.Load()的参数传入程序集名称，运行库会在本地目录和全局程序集缓存中查找该程序集。
- Assembly.LoadForm()的参数需传入程序集的完整路径。

列出一些常用的方法：
#+END_VERSE
#+begin_src csharp
  Assembly assemblyTest = Assembly.Load("SomeAssembly");
  string name = assemblyTest.FullName;

  //以下获取的是 Assembly 类型的 Attribute
  Attribute[] assemblyAttributes = Attribute.GetCustomAttributes(assemblyTest);

  //以下获取的是 Class 类型的 Attribute
  Type[] types = assemblyTest.GetTypes();
  foreach (var type in types)
  {
      Attribute[] classAttributes = Attribute.GetCustomAttributes(type);

      //以下获取的是 Method 类型的 Attribute
      MemberInfo[] methods = type.GetMethods();
      foreach (var method in methods)
      {
          Attribute methodAttribute = Attribute.GetCustomAttributes(method);
      }
  }
#+end_src
*** 示例参照[[ReflectionDemo]]
*** 常用类列表

* 序列化及持久化
** 概述
- 序列化：将对象转换成字节流的过程称为序列化。反之，则称反序列化。
- 持久化：将对象存储在一些持久性的媒介(例：内存为非持久性媒介，硬盘是持久性媒介)上称为持久化。
#+BEGIN_VERSE
命名空间 System.Runtime.Serialization 和 System.Runtime.Serialization.Formatters 提供了序列化对象的基础架构。
#+END_VERSE
** Serializable 特性
#+BEGIN_VERSE
要使某对象能够进行序列化，需要对类标注[Serializable]特性。
还可以对类成员分别标注[NonSerialized]特性，标出不需要序列化的成员。例：
#+END_VERSE
#+begin_src csharp
  [Serializable]
  class Person
  {
      public string Name;//属性也可被序列化
      private int Age { get; set; }//可被序列化
      [NonSerialized]public string Phone;//该字段不会被序列化，注：NonSerialized 特性只能标准字段。
  }
#+end_src
** IFormatter 接口
#+BEGIN_VERSE
只要实现了 IFormatter 接口的类都提供了序列化过程的具体实现，也可以
自定义一个类实现该接口支持序列化特殊格式的字符流。该接口定义如下：
#+END_VERSE
| 方法                                         | 说明                   |
|----------------------------------------------+------------------------|
| void Serialize(Stream stream, object source) | 把 source 序列化为 stream |
| object Deserialize(Stream stream)            | 反序列化 stream，返回 object |

注：如果 stream 是个 FileStream 类型，将其写入文件，这也就是将对象 object 持久化了。
** 序列化为 Binary 示例
#+BEGIN_VERSE
Binary 是常用的序列化形式之一，简单介绍下它的使用，其他形式的使用方式类似。
命名空间：System.Runtime.Serialization.Formatters.Binary
类：BinaryFormatter
作用：能把对象序列化为二进制流，同样支持反序列化。
#+END_VERSE
#+begin_src csharp
  //序列化
  IFomatter serializer = new BinaryFormatter();
  serializer.Serialize(myStream, myObject);

  //反序列化
  IFomatter serializer = new BinaryFormatter();
  MyObjectType myObject = serializer.Deserialize(MyStream) as MyObjectType;
#+end_src
完整示例：[[http://files.cnblogs.com/ChrisChen3121/Serialization.rar][Serialization.rar]]
** 拓展
*** ISerializable 接口
#+BEGIN_VERSE
另外，如果类需要控制自身的序列化过程，则需要实现 ISerializable 接口，
在 GetObjectData 修改 SerializationInfo 的信息。详细参考[[http://msdn.microsoft.com/en-us/library/wf4375ks(v=vs.90).aspx][MSDN]]。
#+END_VERSE
*** 一些.Net 序列化类
下表列出了.Net 提供的其他一些序列化类：
 | 类名                      | 作用                       |
 |---------------------------+----------------------------|
 | SoapFormatter             | 序列化为 Soap 格式的 XML 数据  |
 | ObjectStateFormatter      | 在 ASP.Net 中序列化 viewstate |
 | NetDataContractSerializer | 用于序列化 WCF 数据合同      |
* 多线程
** 创建线程
*** 异步委托方式
#+BEGIN_VERSE
使用异步委托创建的线程，都是由.Net 线程池维护的。
线程池中的线程总是后台线程。
为了方便起见，接下来使用的共通委托方法如下[fn:1]：
#+END_VERSE
#+begin_src csharp
  static int TakesAWhile(int data, int ms)
  {
      Console.WriteLine("TakesAWhile started");
      Thread.Sleep(ms);
      Console.WriteLine("TakesAWhile completed");
      return ++data;
  }
#+end_src
**** IAsyncResult.IsCompleted
#+BEGIN_VERSE
根据 IAsyncResult.IsCompleted 判断异步委托是否执行完成。
EndInvoke 获取返回值。
#+END_VERSE
#+begin_src csharp
  TakesAWhileDelegate dl = TakesAWhile;
  IAsyncResult ar = dl.BeginInvoke(1, 3000, null, null);
  while (!ar.IsCompleted)
  {
      Console.Write(".");
      Thread.Sleep(50);
  }
  int result = dl.EndInvoke(ar);
  Console.WriteLine("result: {0}", result);
#+end_src
**** IAsyncResult.AsyncWaitHandle
使用 WaitHandle，可指定异步调用的超时时间进行后续处理。
#+begin_src csharp
  TakesAWhileDelegate dl = TakesAWhile;
  IAsyncResult ar = dl.BeginInvoke(1, 3000, null, null);
  if (!ar.AsyncWaitHandle.WaitOne(200, false))
  {
      Console.WriteLine("Thread not invoked.");
  }
  if (ar.AsyncWaitHandle.WaitOne(3000, false))
  {
      int result = dl.EndInvoke(ar);
      Console.WriteLine("result: {0}", result);
  }
#+end_src
**** AsyncCallBack
通过传入回调函数，进行后续处理
***** 分支一：单独定义回调方法
#+begin_src csharp
  static void Main(string[] args)
  {
      TakesAWhileDelegate dl = TakesAWhile;
      dl.BeginInvoke(1, 3000, TakesAWhileCompleted, dl);
      //必须程序主线程一直存在才会执行回调方法，所以使用了如下 for 循环(说明了异步委托所创建的线程是一个后台线程)
      for (int i = 0; i < 100; i++ )
      {
          Console.Write(".");
          Thread.Sleep(50);
      }
  }

  //定义回调方法
  static void TakesAWhileCompleted(IAsyncResult ar)
  {
      if (ar == null)
      {
          throw new ArgumentNullException("ar");
      }
      TakesAWhileDelegate dl = ar.AsyncState as TakesAWhileDelegate;
      Trace.Assert(dl != null, "Invalid object type");
      int result = dl.EndInvoke(ar);
      Console.WriteLine("result: {0}", result);
  }
#+end_src
***** 分支二：使用 lambada 表达式
#+begin_src csharp
  TakesAWhileDelegate dl = TakesAWhile;
  dl.BeginInvoke(1, 3000,
                 //这是个回调函数，使用 lambada 表达式的话，代码不够清晰。
                 ar =>
      {
          int result = dl.EndInvoke(ar);//lambda 表达式可使用该作用域外部的变量 dl
          Console.WriteLine("result: {0}", result);
      },
                 null);
  //必须程序主线程一直存在才会执行回调方法
  for (int i = 0; i < 100; i++)
  {
      Console.Write(".");
      Thread.Sleep(50);
  }
#+end_src

*** Thread 类
**** 无参数线程方法
#+begin_src csharp
  var t1 = new Thread(() => Console.WriteLine("running in a thread, id {0}", Thread.CurrentThread.ManagedThreadId));
  t1.Start();
  Console.WriteLine("This is a main thread, id {0}", Thread.CurrentThread.ManagedThreadId);
#+end_src
**** 有参数线程方法
#+begin_src csharp
  public struct Data
  {
      public string Message;
  }

  static int TakesAWhile(int data, int ms)
  {
      var d = new Data { Message = "Info" };
      var t2 = new Thread((object obj) =>
          {
              Data data = (Data)obj;
              Console.WriteLine("running in a thread, id {0}, Data {1}", Thread.CurrentThread.ManagedThreadId, data.Message);
          });
      t2.Start(d);
      Console.WriteLine("This is a main thread, id {0}", Thread.CurrentThread.ManagedThreadId);
  }
#+end_src

**** 后台线程
Thread 类默认创建的是前台线程，设定 IsBackground 属性可转为后台线程
#+begin_src csharp
  var t1 = new Thread(
      () =>
      {
          Console.WriteLine("branch thread Start, id {0}", Thread.CurrentThread.ManagedThreadId);
          Thread.Sleep(3000);
          Console.WriteLine("branch thread End");
      })
  { Name = "NewBKThread", IsBackground = true };
  t1.Start();
  Thread.Sleep(50);//为了使后台线程的情况下，能打出 branch thread Start, id
  Console.WriteLine("This is a main thread, id {0}", Thread.CurrentThread.ManagedThreadId);
#+end_src
- IsBackground = true 结果：
#+BEGIN_VERSE
branch thread Start, id 3
This is a main thread, id 1
#+END_VERSE
- IsBackground = false 结果：
#+BEGIN_VERSE
branch thread Start, id 3
This is a main thread, id 1
branch thread End
#+END_VERSE

**** 关于线程优先级
#+BEGIN_VERSE
可以通过 Thread.Priority 属性调整线程的 *基本* 优先级。实际线程调度器会动态调整优先级
频繁使用 CPU 的线程的优先级会动态调低，等待资源(等待磁盘 IO 完成等)的线程会动态调高优先级。
以便在下次等待结束时获得 CPU 资源。[fn:2]
#+END_VERSE

**** 线程状态
#+BEGIN_VERSE
通过属性 Thread.ThreadState 获取当前线程状态

运行 Thread.Start()后，状态为 Unstarted。
系统线程调度器选择了运行该线程后，状态为 Running。
调用 Thread.Sleep()，状态为 WaitSleepJoin。

停止另一个线程，调用 Thread.Abort()。接到中止命令的线程中会抛出 ThreadAbortException。[fn:3]
涉及的状态有 AbortRequested、Aborted。
继续停止的线程，调用 Thread.ResetAbort()。线程将会在抛出 ThreadAbortException 后的语句后继续进行。

等待线程的结束，调用 ThreadInstance.Join()。
该调用会停止 *当前* 线程，当前线程状态设为 WaitSleepJoin。
等待加入的线程处理完成，再继续当前线程的处理。
#+END_VERSE

*** 线程池
超出最大线程数时，QueueUserWorkItem 会等待获取线程资源时再调用。
#+begin_src csharp
  static void Main(string[] args)
  {
      ThreadPool.SetMinThreads(3, 3);//创建线程池时启动的最小线程数
      ThreadPool.SetMaxThreads(10, 10);//最大线程数
      for (int i = 0; i < 5; i++ )
      {
          ThreadPool.QueueUserWorkItem(JobForAThread);
      }
      Thread.Sleep(3000);//由于是后台线程，需要使主线程等一会，否则程序直接退出
  }

  static void JobForAThread(object state)
  {
      for (int i = 0; i < 3; i++)
      {
          Console.WriteLine("loop {0}, running inside pooled thread {1}", i, Thread.CurrentThread.ManagedThreadId);
      }
  }
#+end_src
使用线程池的限制：
- 其中的所有线程只能是后台线程。
- 无法设置线程的优先级或名称。
- *关键点* 适用于耗时较短的任务。长期运行的线程，应使用 Thread 类创建。

** 同步问题
*** lock 关键字
#+BEGIN_VERSE
只能锁定引用类型，锁定值类型等于锁定了一个副本，没有意义，编译器也不允许你这么做。
使用锁定需要时间，并不总是必须。可以创建类的两个版本，一个同步版本，一个异步版本。
#+END_VERSE
**** 将实例成员设为线程安全的
#+begin_src csharp
  lock(this)
  {
      //一次只有一个线程能访问相同实例的该语句块
  }
#+end_src
因为该实例对象也可用于外部访问，这样做会导致外部访问时也得等待该同步语句块执行完成。正确的做法：
#+begin_src csharp
  private object syncRoot = new object();
  public void DoSomething()
  {
      lock (object)
      {
          //Do something
      }
  }

  private static object syncRoot = new object();//可用于锁定类静态成员
#+end_src
**** lock 关键字由编译器解析为 Monitor 类
#+begin_src csharp
  lock (obj) {  };
#+end_src
等价于：
#+begin_src csharp
  Monitor.Enter(obj);
  try
  {
  }
  finally
  {
      Monitor.Exit(obj);
  }
#+end_src
与 lock 关键字的区别：
- 可添加一个等待解锁的超时时间，使用 TryEnter 传递超时值。
#+begin_src csharp
  bool lockTaken = Monitor.TryEnter(obj, 500);
  if (lockTaken)
  {
      try
      {

      }
      finally
      {
          Monitor.Exit(obj);
      }
  }
  else
  {
      //didn't get the lock, do something else
  }
#+end_src

**** 更快速的 Interlocked 类
仅用于简单的针对变量赋值的同步问题
#+begin_src csharp
  lock(this)
  {
      if (someState == null)
      {
          someState = newState;
      }
  }
#+end_src
等价于(可用于单件模式的 GetInstance)：
#+begin_src csharp
  Interlocked.CompareExchange<SomeState>(ref someState, newState, null);//第一个参数和第三个参数比较，如果相等，替换为第二个参数的值
#+end_src
#+begin_src csharp
  public int State
  {
      get
      {
          lock (this)
          {
              return ++state;
          }
      }
  }
#+end_src
等价于：
#+begin_src csharp
  public int State
  {
      get
      {
          return Interlocked.Increment(ref state);
      }
  }
#+end_src
*** WaitHandle
#+BEGIN_VERSE
WaitHandle 是一个抽象基类。用于等待某个信号量。
Mutex、EventWaitHandle、Semaphore 类都从 WaitHandle 派生。
#+END_VERSE
*** Mutex 类
#+BEGIN_VERSE
提供进程之间的同步访问。创建一个进程之间能共享的以字符串命名的互斥锁。
构造函数的一种形式如下：
#+END_VERSE
#+begin_src csharp
  bool created;
  Mutex mutex = new Mutex(false, "IFFileMutex", out created);
#+end_src
#+BEGIN_VERSE
其中，第一个参数定义了该互斥体的所有权是否应属于调用线程。
第二个参数是互斥体名字，操作系统能识别该字符串，以此实现各进程之间的同步。
第三个参数，如果系统中已存在该命名的互斥体返回 false，否则返回 true。
#+END_VERSE
#+begin_src csharp
  Mutex mutex = Mutex.OpenExisting("IFFileMutex");//打开系统中已存在的互斥体
  if(mutex.WaitOne(500))//500 为等待超时时间
  {
      try
      {
          //synchronized region
      }
      finally
      {
          mutex.ReleaseMutex();
      }
  }
#+end_src
*** Semaphore 类
信号量可以同时由多个线程使用，是计数的互斥体。一般用于受数量限制的访问资源(如 DB 连接资源)。
*** Event 类
#+BEGIN_VERSE
系统级的资源同步方式，比之 Mutex，多了个 Reset 方法，
重置 nonsignaled 的状态(等同于互斥体的锁定状态)，释放所有等待的线程。

Set 方法：将事件设为 signaled 状态，使其他等待的线程得以继续，类似锁的 Release 方法。
Waitone 方法：等待事件被设为 signaled 状态。
Reset 方法：将事件设为 nonsignaled 状态，并且阻塞所有等待的线程。
#+END_VERSE
**** AutoResetEvent
#+BEGIN_VERSE
Reset 方法会在某一线程 Waitone 成功后，自动重置为 nonsignaled。
达到的效果：一次只能一个线程继续处理。
#+END_VERSE
**** ManualResetEvent
#+BEGIN_VERSE
需手动调用 Reset 方法重置为 nonsignaled。
达到的效果：多个线程都能继续进行处理。
#+END_VERSE
*** ReaderWriterLockSlim 类(.Net 3.5 引入)
#+BEGIN_VERSE
如果没有 Writer 锁定资源，就允许多个 Reader 访问资源，但只能有一个
Writer 锁定该资源(所有访问中的 Reader 都必须先释放锁)。
比之.Net 1.0 版本 ReaderWriterLock 类，重新设计为防止死锁，提供更好的性能。
#+END_VERSE
- EnterReadLock
  进入锁定，另一个方法 TryEnterReadLock 允许指定一个超时时间。ExitReadLock 释放锁定
- EnterUpgradableReadLock
  用于读取锁定需要改为写入锁定的情况。
- EnterWriteLock
  获得多资源的写入锁定。仅一个线程能获取锁定，在这之前还必须释放所有的读取锁定。

** Timer 类
.Net 提供了几个 Timer 类，比较如下：
| 命名空间             | 说明                                                                                                                    |
|----------------------+-------------------------------------------------------------------------------------------------------------------------|
| System.Threading     | 提供了 Timer 的核心功能，在构造函数中传入回调的委托。                                                                     |
| System.Timer         | 继承 Component，可在设计界面拖入，提供了基于事件的机制(非委托)。                                                         |
| System.Windows.Forms | 为单线程环境设计的(创建和回调在同一个线程中执行)，执行回调方法时 UI 会假死，不宜执行耗时较长的代码。该 Timer 时间精度 55ms。 |
| System.Web.UI        | 是一个 AJAX 扩展，可以用于 Web 页面                                                                                         |

** 总结
| 类                   | 目的                                                       | 参考开销[fn:4] | 是否跨进程？ |
|----------------------+------------------------------------------------------------+----------------+--------------|
| lock(Monitor)        | 保证单个进程内只有一个线程能够获取同步资源                 | 20ns           | No           |
| Mutex                | 保证只有一个线程能够获取同步资源                           | 1000ns         | Yes          |
| Semaphore            | 可指定可获取同步资源的线程数                               | 1000ns         | Yes          |
| ReaderWriterLock     | 允许多个 Reader 访问同步资源                                 | 100ns          | No           |
| AutoResetEvent       | 当信号被设为 signaled 状态时，允许单个线程进入同步资源块     | 1000ns         | Yes          |
| ManualResetEvent     | 当信号被设为 signaled 状态时，允许所有等待线程进入同步资源块 | 1000ns         | Yes          |
| ReaderWriterLockSlim | 可锁定多个 Reader 访问资源以及单个 Writer 修改资源             | 40ns           | No           |

- 注：一些 Slim 类(如 ManualResetEventSlim)，比之旧版本，通常拥有更好的性能。参考 [[http://msdn.microsoft.com/en-us/library/5hbefs30(v=vs.100).aspx][MSDN]]。

几条规则：
1) 尽量使同步要求最低，尝试避免共享状态。
2) 类的静态成员应是线程安全的。
3) 实例成员不需要是线程安全的。为了最佳性能，最好在类的外部处理同步问题。
** 推荐阅读
[[http://www.albahari.com/threading/][Threading in C#]]
* 诊断
对应命名空间 System.Diagnostics
** 跟踪(Trace)
#+BEGIN_VERSE
用于应用程序运行时获得消息。记录各种形式的 Log 等
#+END_VERSE
Trace 体系结构：
   #+CAPTION:
   #+ATTR_HTML: align="center"
   [[file:../resources/csharp/Trace Architect.png]]
- 使用 TraceSource 发送跟踪消息
- Swith 定义了要记录的信息级别
- TraceListener 定义了写入跟踪消息的位置
- Listener 可以关联一个 Filter，过滤跟踪消息
- 监听器和过滤器都可定制拓展

可在 Visual Studio 项目属性的 Build Tab 中对是否在调试或发布版本中启用 Trace 标志进行设置。
*** TraceSource
与 Trace 类相比，TraceSource 类较难使用，提供的选项更多。
#+begin_src csharp
  TraceSource source1 = new TraceSource("Tracing");
  source1.TraceInformation("Info Message");//写入 Trace 消息
  source1.TraceEvent(TraceEventType.Error, 3, "Error Message");//写入指定级别的 Trace 信息，可使用 Switch 只查看指定级别的消息。
  source1.TraceData(TraceEventType.Information, 2, new int[] { 1, 2, 3 });//TraceData 可以传入任意对象
  source1.Flush();//为确保 TraceData 传入的数据由监听器写入，且不存储在内存中，需要执行 Flush()
  source1.Close();//不再需要该跟踪源时执行，Close()执行同时也会执行 Flush()
#+end_src
*** Swith
三个子类可供选择：
- BooleanSwitch 可以打开和关闭跟踪
- TraceSwitch 提供了 TraceLevel 的选择，过滤 Trace 消息(TraceLevel 包含 Off、Error、Warning、Info、Verbose)
- SourceSwitch 提供了 TraceLevel 的选择，过滤 Trace 消息

编程中硬编码方式：
#+begin_src csharp
  source1.Switch = new SourceSwitch("MySwitch", "Warning");//显示 Warning 以上级 Trace 消息
#+end_src

配置文件方式：
#+begin_src xml
  <?xml version="1.0" encoding="utf-8" ?>
  <configuration>
    <system.diagnostics>
      <sources>
        <source name="Tracing" switchName="MySourceSwitch"
                switchType="System.Diagnostics.SourceSwitch"/>
      </sources>
      <switches>
        <add name="MySourceSwitch" value="Verbose"/>
      </switches>
    </system.diagnostics>
  </configuration>
#+end_src
source name 必须与程序中定义的 TraceSource 名匹配。

*** TraceListener
#+BEGIN_VERSE
默认在调试时，当前的追踪消息之写入 Visual Studio 的 Output 窗口。
Trace 监听器可重定向到不同的输出位置。需要在配置文件中配置。
#+END_VERSE
#+begin_src xml
  <?xml version="1.0" encoding="utf-8" ?>
  <configuration>
    <system.diagnostics>
      <sources>
        <source name = "Tracing" switchName="MySourceSwitch"
                switchType="System.Diagnositcs.SourceSwitch">
          <listeners>
            <!--监听消息以 xml 格式写入-->
            <add name="xmlListener"
                 type="System.Diagnostics.XmlWriterTraceListener"
                 traceOutputOptions="None" initializeData="c:/logs/trace.xml"/>
            <add name="delimitedListener" />
          </listeners>
        </source>
      </sources>
      <sharedListeners>
        <!--监听消息以指定分隔符分隔消息各部分-->
        <add name="delimitedListener" delimiter=":"
             type="System.Diagnostics.DelimitedListTraceListener"
             traceOutputOptions="DataTime, ProcessId"
             initializeData="c:/logs/trace.txt"/>
      </sharedListeners>
      <switches>
        <add name="MySourceSwitch" value="Verbose"/>
      </switches>
    </system.diagnostics>
  </configuration>
#+end_src
- traceOutputOptions 由 TraceOptions 这个枚举定义，可将这些额外的信息写入 Trace 日志。
- sharedListeners 元素可以定义共通的监听方式

以上定义的 DelimitedListTraceListener 的输出结果如下：
#+begin_example
"Tracing":Information:0:"Info message"::4188:""::"2012-11-24T12:15:52.3756748Z"::
"Tracing":Error:3:"Error message"::4188:""::"2012-11-24T12:15:52.77546721Z"::
#+end_example

可用监听器列表：
| 监听器名                   | 说明                                                                               |
|----------------------------+------------------------------------------------------------------------------------|
| DefaultTraceListener       | 默认输出至关联的调试器中，如 Visual Studio Output 窗口                               |
| EventLogTraceListener      | 写入 EventLog                                                                       |
| TextWriterTraceListener    | 写入文件                                                                           |
| ConsoleTraceListener       | 写入控制台，继承 TextWriterTraceListener                                            |
| DelimitedListTraceListener | 写入带指定分隔符的文件，继承 TextWriterTraceListener                                |
| XmlWriterTraceListener     | 写入 XML 格式文件中，继承 TextWriterTraceListener。(默认包括 TraceOptions 中定义的信息) |
| IisTraceListener           | .Net 3.0 以上，写入 IIS 中                                                            |
| WebPatgeTraceListener      | 依赖于 ASP.NET 所特有的另一个跟踪选项，在动态创建的输出文件 trace.axd 中写入 Trace 信息  |

*** TraceFilter
每个监听器都有一个过滤器。监听器使用过滤器确定是否应写入信息。
- SourceFilter 根据指定源过滤写入的 Trace 消息
- EventTypeFilter 根据跟踪级别过滤写入的 Trace 消息
#+begin_src xml
  <sharedListeners>
    <add name="xmlListener"
         type="System.Diagnostics.XmlWriterTraceListener"
         traceOutputOptions="None" initalizeData="c:/logs/trace.xml>
      <filter type="System.Diagnostics.SourceFilter"
              initializeData="Tracing"/>
      <filter type="System.Diagnostics.EventTypeFilter"
              initializeData="Warning"/>
    </add>
  </sharedListeners>
#+end_src

*** Trace.Assert
#+BEGIN_VERSE
可以显示信息和错误，中止或继续运行应用程序。一般用于开发期。
还可以用 Debug.Assert，项目默认只有 Debug 时才加入编译。
是否禁用断言信息可以通过程序配置项配置：
#+END_VERSE
#+begin_src xml
  <configuration>
    <system.diagnostics>
      <assert assertuienabled="false"/>
    </system.diagnostics>
  </configuration>
#+end_src
** 事件日志
*** 日志分类
- 系统： 用于系统驱动程序与硬件驱动程序。
- 应用程序：用于各应用程序及服务程序。
- 安全：是应用程序的只读日志。
- 自定义类别：程序还可以自定义日志类别，可以在“应用程序和服务日志”文件夹中看到自定义的类别。(通常都是这么做的)
** 性能
*** 监控类
System.Diagnostics 提供了如下监控类
| 类名                        | 说明                                                             |
|-----------------------------+------------------------------------------------------------------|
| PerformanceCounter          | 用于写入计数和监控计数，可使用此类创建新的性能类别               |
| PerformanceCounterCategory  | 可查看所有已有的类别以及创建新类别。可从一个类别中获取所有计数器 |
| PerformanceCounterInstaller | 用于安装性能计数器                                      |

** 代码约定
#+BEGIN_VERSE
使用 System.Diagnostics.Contracts(.Net 4.0 引入)，可定义方法中的前提条件、
后置条件和常量。可以选择性编译进调试级程序或者发布级程序。(VS2010 以上
项目属性→CodeContracts Tab，需另装插件[[http://visualstudiogallery.msdn.microsoft.com/1ec7db13-3363-46c9-851f-1ce455f66970][Code Contracts for .NET]])。
#+END_VERSE
用法提示：
- 前置条件和后置条件都必须放在方法开头。
- 验证失败会触发 ContractFailed 事件，可自定义事件处理程序。
*** 前置条件
有两个方法可以定义前置条件
1) Requires()
2) Requires<TException>()
看例子，与断言(Assert)的用法非常相似。
#+begin_src csharp
  static bool IsStrValid(int min, int max, string str)
  {
      Contract.Requires(min<=max);//可定义第二个参数，指定验证失败时显示的字符串。
      Contract.Requires<ArgumentNullException>(str != null, "Preconditions, o is null");//验证项 str != null 为 false 时，抛出异常。
      int value = int.TryParse(str);
      if (value >= min || value <= max)
          return true;
      return false;
  }
#+end_src
注意点：
- 将 ContractFailed 事件设为 handled，则不抛出异常。
- 如果配置了 Assert on Contract Failure，则在约定处调用 Trace.Assert()方法替代抛出异常。
- 遗留代码添加一行代码即可。EndContractBlock 指定其之前的代码为条件检查代码。
#+begin_src csharp
  if (o == null) throw new ArgumentNullException("o");
  Contract.EndContractBlock();
#+end_src
- Contract 类提供了 Exists()和 ForAll()方法用作参数的检查。ForAll 针对集合。可用于前置条件、后置条件和常量。
#+begin_src csharp
  void ArrayTest(int[] data)
  {
      Contract.Requires(Contract.ForAll(data, i=>i<12));
  }
#+end_src
*** 后置条件
定义后置条件的两个方法：
1) Ensures()
2) EnsuresOnThrow<TException>()
用法大致上与前置条件差不多，请看示例，不再累述。
#+begin_src csharp
  static int sharedState = 5;
  static void Postcondtion()
  {
      Contract.Ensures(sharedState < 6);
      sharedState--;
  }
  static int ReturnValue()
  {
      Contract.Ensures(Contract.Result<int>() < 6);
      return 3;
  }
#+end_src
*** 常量条件
#+BEGIN_VERSE
定义了在整个方法生命期中都必须满足的条件。
Contract.Invariant(x>5)说明整个方法生命期中 x 都必须大于 5。
#+END_VERSE

*** 接口协定
可使用 ContractClass、ContractClassFor、Pure 特性来为接口定义约束条件类。
#+begin_src csharp
  [ContractClass(typeof(PersonContract))]
  public interface IPerson
  {
      string Name{ get; set; }
  }

  [ContractClassFor(typeof(IPerson))]
  public class PersonContract : IPerson
  {
      string IPerson.Name
      {
          [Pure] get { return Contract.Result<string>(); }
          set { Contract.Requires(value != null); }
      }
  }

  public class Person : IPerson
  {
      string Name{ get; set; }
  }

  static void Main()
  {
      var p = new Person { Name = null };//contract error
  }
#+end_src

* 程序集
** 共享程序集
#+BEGIN_VERSE
①GAC 全局共享
②配置文件 codeBase 元素配置，共享程序集路径如没有，搜索 probing 元素。
#+END_VERSE
** Useful Utility
- ILDASM 将汇编转成 IL 代码
- [[http://msdn.microsoft.com/zh-cn/library/k5b5tt23(v=vs.90).aspx][Sn.exe]] 公用程序集强名工具
- [[http://msdn.microsoft.com/zh-cn/library/ex0ss12c(v=vs.90).aspx][Gacutil.exe]] 公用程序集安装工具
- [[http://msdn.microsoft.com/zh-cn/library/6t9t5wcf(v=vs.90).aspx][Ngen.exe]] 安装期间 IL 转成汇编机器码，提高托管应用程序性能的工具，取代程序集的 JIT 编译。
#+BEGIN_VERSE
预编译的程序集和需要运行 JIT 编译的程序集，其性能在编译 IL 代码后差别不大。
使用 Ngen.exe 唯一改进是，应用程序启动比较快，因为不需要启动 JIT 编译器。
需保证应用程序所有程序集均已作成本机映像
#+END_VERSE
* 部署
** 自定义安装包
1) [[http://blog.csdn.net/wonsoft/article/details/5956320][打包微软各种库的方法]]
2) [[http://blog.csdn.net/cxyyxc/article/details/1725703][自动安装 web 网站及执行 SQL 的方法 IIS6]]
* WebService
* Footnotes
[fn:1] 例子参照《C# 高级编程(第 7 版)》

[fn:2] 给线程指定较高的基本优先级时，需注意。这有可能会降低其他线程的运行概率。

[fn:3] 可以捕捉该异常完成线程的资源清理任务。

[fn:4] 该时间测自 CPU Intel Core i7 860 的环境，参考[[http://www.albahari.com/threading/][Threading in C#]]
