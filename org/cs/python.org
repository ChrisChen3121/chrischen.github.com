#+TITLE: Python Cookbook
#+KEYWORDS: python
#+OPTIONS: H:3 toc:3 num:3 ^:nil LaTeX:t
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SETUPFILE: ../../org-templates/level-1.org
#+STARTUP: inlineimages
* Data Structures and Algorithms
** Unpacking from Iterables
   #+BEGIN_SRC python
     x, *middle, y = [1, 2, 3, 4, 5] # middle can be replaced by placeholder '_'
     # x => 1
     # y => 5

     data = ['ACME', 50, 91.1, (2012, 12, 21)]
     name, shares, price, (year, mon, day) = data
   #+END_SRC

** Keeping the Last N Items
   #+BEGIN_SRC python
     from collections import deque
     d=deque(maxlen=N)
   #+END_SRC

** Finding the Largest N Items
   #+BEGIN_SRC python
     import heapq
     heapq.nlargest(N, items)
     heapq.nsmallest(N, items)
     # heapq.nlargest(N, data, key=lambda function)
   #+END_SRC
   Underneath the covers, they work by first converting the data into a list
   where items are ordered as a heap.
   #+BEGIN_SRC python
     nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
     heapq.heapify(nums) # inplace function
     # nums => [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] heap[0] is the smallest
   #+END_SRC

** PriorityQueue Implemention
   #+BEGIN_SRC python
     import heapq

     class PriorityQueue:
         def __init__(self):
             self._queue = []
             self._index = 0 # use index to properly order items with the same priority level

         def push(self, item, priority):
             heapq.heappush(self._queue, (-priority, self._index, item))
             self._index += 1

         def pop(self):
             return heapq.heappop(self._queue)[-1]
   #+END_SRC

** defaultdict
   #+BEGIN_SRC python
     from collections import defaultdict
     d = defaultdict(list)
     d['a']
     #=> []
   #+END_SRC
   *defaultdict* will automatically create dictionary entries for keys accessed later on, alternative:
   #+BEGIN_SRC python
     d.setdefault('a', []).append(1)
   #+END_SRC
*** alternative
    #+BEGIN_SRC python
      d = {}
      # A regular dictionary
      d.setdefault('a', []).append(1)
    #+END_SRC

** OrderedDict
   An OrderedDict internally maintains a doubly linked list that orders the keys according to insertion order.

** sortedcontainers
   SortedList, SortedDict, SortedSet

** Calculating with Dictionaries
   #+BEGIN_SRC python
     prices = {
         'ACME': 45.23,
         'AAPL': 612.78,
         'IBM': 205.55,
         'HPQ': 37.20,
         'FB': 10.75
     }
     min_price = min(zip(prices.values(), prices.keys())) # zip to ((value, key)) generator

     min(prices, key=lambda k: prices[k]) # Returns 'FB'
     min_value = prices[min(prices, key=lambda k: prices[k])]
   #+END_SRC

** keys-view
   #+BEGIN_SRC python
     a.keys() & b.keys()
     a.keys() - {'z', 'w'} # {'z', 'w'} is a set
   #+END_SRC

** Naming a Slice
   #+BEGIN_SRC python
     a = [1,2,3,4,5]
     b = slice(1,2)

     a[b] #=> [2] slower than a[1]
   #+END_SRC

** Counting
   #+BEGIN_SRC python
     from collections import Counter
     word_counts1 = Counter(words1)
     word_counts2 = Counter(words2)
     word_counts1 + word_counts2
   #+END_SRC

** Sorting a List of Dictionaries
   #+BEGIN_SRC python
     from operator import itemgetter
     rows_by_fname = sorted(rows, key=itemgetter('fname'))
     rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))

     g = itemgetter(2, 5, 3) # the call g(r) returns (r[2], r[5], r[3])
   #+END_SRC

** Sorting Objects Without Native Comparison
   #+BEGIN_SRC python
     sorted(users, key=lambda u: u.user_id)
     from operator import attrgetter
     sorted(users, key=attrgetter('user_id'))
     by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
   #+END_SRC


* Network&Web
** RESTful API Query
   #+BEGIN_SRC python
     from urllib import request, parse
     url = 'http://www.123.com/get'
     params = {
         'name1' : 'value1',
         'name2' : 'value2'
     }
     query_string = parse.urlencode(params)

     # headers
     headers = {
         'User-agent' : 'none/ofyourbusiness',
         'Spam' : 'Eggs'
     }

     u = request.urlopen(url+'?' + query_string.encode('ascii'), headers=headers)
     resp = u.read() # resp.text(unicode),  resp.content(raw binary), resp.json
   #+END_SRC
   - useful resp data
     - ~resp.status_code~
     - ~resp.headers['last-modified']~
     - ~resp.headers['content-type']~
     - ~resp.headers['content-length']~

   - urlopen useful args
     - headers
     - cookies
     - files
     - auth

*** Testing
    - use [[http://httpbin.org/][httpbin]]

* Interface
** Properties
   #+BEGIN_SRC python
     class Prop:
         def __init__(self, x):
             self.__x = x

         @property
         def x(self):
             return self.__x

         @x.setter
         def x(self, value):
             self.__x = value
   #+END_SRC

** Sequences
#+BEGIN_SRC plantuml :file ../resources/python/SeqInterface.png
  interface Container {
  {method} __contains__
  }

  interface Iterable {
  {method} __iter__
  }

  interface Sized {
  {method} __len__
  }

  interface Sequence {
  {method} __getitem__
  {method} __reversed__
  {method} index
  {method} count
  }
  Container <|-- Sequence
  Iterable <|-- Sequence
  Sized <|-- Sequence
#+END_SRC

#+RESULTS:
[[file:../resources/python/SeqInterface.png]]
** Monkey Patching
   Changing a class or module at runtime, without touching the source code.
   #+BEGIN_SRC python
   some_obj.__getitem__ = some_get_function(some_class, position)
   #+END_SRC
* asyncio
** coroutine
   #+BEGIN_SRC python
     def simple_coroutine():
         print('-> coroutine started')
         x = yield # received by send(x)
         print('-> coroutine received:', x)

     coro = simple_coroutine() # GEN_CREATED
     next(coro) # equivalent to coro.send(None). GEN_CREATED->GEN_RUNNING->GEN_SUSPENDED
     #-> coroutine started
     coro.send(42) # GEN_SUSPENDED->GEN_RUNNING->GEN_CLOSED
     #-> coroutine received: 42
   #+END_SRC
   - next(coro) is often describe as "priming" the coroutine(advancing it to the first yield)

*** states
    use ~inspect.getgeneratorstate()~ to get state
    - GEN_CREATED: Waiting to start execution
    - GEN_RUNNING: Currently being executed by the interpreter
    - GEN_SUSPENDED: Currently suspended at a yield expression
    - GEN_CLOSED

*** generator methods
    - send(value): the caller can post data that then becomes the value of the yield expression inside the generator.
    - throw(): allow the caller to throw an exception to be handled inside the generator.
    - close()

*** auto priming
    #+BEGIN_SRC python
      from functools import wraps
      def coroutine(func):
          """Decorator: primes `func` by advancing to first `yield`"""
          @wraps(func)
          def primer(*args,**kwargs):
              gen = func(*args,**kwargs)
              next(gen)
              return gen
          return primer

      @coroutine
      def simple_coroutine():
          x = yield

      coro = simple_coroutine()
      #-> GEN_SUSPENDED
    #+END_SRC
   - ~yield from~ automatically primes the coroutine called by it, making it incompatible with the coroutine decorator above.
   - ~asyncio.coroutine~ is designed to work with yield from so it does not prime the coroutine.

*** Termination & Exception
**** from generator
     An exception within a coroutine propagates to the caller of the next or send that triggered it.
**** to generator
     - ~throw~: Causes the yield expression where the generator was paused to raise the exception given.
     - ~close~: Causes the yield expression where the generator was paused to raise a Generator Exit exception.
**** cleanup code
     wrap the cleanup code in ~try/finally~ block

*** return value
    #+BEGIN_SRC python
      Result = namedtuple('Result', 'count average')
      def averager():
          total = 0.0
          count = 0
          average = None
          while True:
              term = yield # yield None
              if term is None:
                  break # use a sentinel to terminate the coroutine normally
              total += term
              count += 1
              average = total/count
          return Result(count, average)

      coro_avg = averager()
      coro_avg.send(10)
      try:
          coro_avg.send(None)
      except StopIteration as exc:
          result = exc.value # Result(count=3, average=15.5)
    #+END_SRC
    - in order to return a value, a coroutine must terminate normally

*** *yield from*
    The main feature of *yield from* is to open a bidirectional channel from the outermost caller to the innermost subgenerator, so that values
    can be sent and yielded back and forth directly from them, and exceptions can be thrown all the way in without adding a lot of exception
    handling boilerplate code in the intermediate coroutines.

    - similar constructs in other languages are called *await*
    #+BEGIN_SRC python
      def gen():
          yield from 'abc'
          # shortcut for forloop
          # for x in 'abc':
          #     yield x
    #+END_SRC

**** terms
     - delegating generator: The generator function that contains the *yield from <iterable>* expression
     - subgenerator
     - caller

     #+CAPTION: Coroutine
     #+ATTR_HTML: align="center"
     file:../resources/python/coroutine.png

**** meaning of *yield from*
     - Any values that the subgenerator yields are passed directly to the caller of the delegating generator
     - Any values sent to the delegating generator using *send()* are passed directly to the subgenerator.
     If the sent value is *None*, the subgenerator's *__next__()* method is called. If the sent value is
     not *None*, the subgenerator's *send()* method is called. If the call raises *StopIteration*, the delegating
     generator is resumed. Any other exception is propagated to the delegating generator.
     - return expr in a generator (or subgenerator) causes *StopIteration(expr)* to be raised upon exit from
     the generator.
     - The value of the *yield from* expression is the first argument to the *StopIteration* exception raised by
     the subgenerator when it terminates.

**** pseudocode
     #+BEGIN_SRC python
       _i = iter(EXPR)
       try:
           _y = next(_i)
       except StopIteration as _e:
           _r = _e.value # the RESULT in the simplest case
       else: # channel between the caller and the subgenerator
           while 1:
               _s = yield _y
               try:
                   _y = _i.send(_s)
               except StopIteration as _e:
                   _r = _e.value
                   break
       RESULT = _r
     #+END_SRC
     - _i(iterator): The subgenerator
     - _y(yielded): A value yielded from the subgenerator
     - _r(result): The eventual result
     - _s(sent): A value sent by the caller to the delegating generator, which is forwarded to the subgenerator
     - _e(exception): An exception

**** ipython-yf
     Enables evaluating yield from directly in the *iPython* console.
*** example
** asyncio
