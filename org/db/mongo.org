#+TITLE: MongoDB
#+KEYWORDS: MongoDB
#+OPTIONS: H:3 toc:2 num:2 ^:nil
#+LaTeX: t
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* Basic
** CRUD

create, read, update, and delete

- create: insertOne
- read: find, findOne
- update: updateOne
- delete: deleteOne

** Types
   ~null~, Boolean, Number, String, Date(int64 since epoch), Regular expression(query only), Array, Embedded document
   - Binary data: Binary data is the only way to save non-UTF-8 strings to the database.
   - Code: MongoDB also makes it possible to store arbitrary JavaScript in queries and documents: ~{"x" : function() { /* ... */ }}~
*** Object ID
    12-byte ID for documents
    |                  0 |      1 |                            2 | 3 4 5 6 7 8 9 10 11 |
    |--------------------+--------+------------------------------+---------------------|
    | Timestamp(seconds) | Random | Counter (random start value) |                     |

** Mongo Shell
   #+BEGIN_SRC js
     conn = new Mongo("host:port")
     db = conn.getDB("myDB")
   #+END_SRC
   - help

*** Useful Helpers
    | Helper           | Equivalent              |
    |------------------+-------------------------|
    | use db           | db.getSisterDB("db")    |
    | show dbs         | db.getMongo().getDBs()  |
    | show collections | db.getCollectionNames() |
    - ~pwd()~:
    - ~run("ls", "-l", "/home/myUser/my-scripts/")~

*** Custom Helper
    1. define helper function in js
    2. load js
    3. ~typeof helper_function~

*** Frequently Loaded Scripts
    Use ~.mongorc.js~ in your home directory, This file is run whenever you start up the shell.
    - common example in ~.mongorc.js~: remove some of the more "dangerous" shell helpers
    #+BEGIN_SRC js
      var no = function() {
          print("Not on my watch.");
      };

      // Prevent dropping databases
      db.dropDatabase = DB.prototype.dropDatabase = no;

      // Prevent dropping collections
      DBCollection.prototype.drop = no;

      // Prevent dropping an index
      DBCollection.prototype.dropIndex = no;

      // Prevent dropping indexes
      DBCollection.prototype.dropIndexes = no;
    #+END_SRC
    - use ~--norc~ option to disable ~.mongorc.js~

*** Customizing Your Prompt
    Just set the ~prompt~ variable
    #+BEGIN_SRC js
      prompt = function() {
          if (typeof db == 'undefined') {
              return '(nodb)> ';
          }

          // Check the last db operation
          try {
              db.runCommand({getLastError:1});
          }
          catch (e) {
              print(e);
          }

          return db+"> ";
      };
    #+END_SRC

** Tools
   - ~mongoimport~: importing raw data from a data feed or MySQL

* CRUD
** query
   - some query condition: ~$nin~, ~$or~, ~$exists~, ~$regex~
   - Mongo uses the Perl Compatible Regular Expression
*** querying arrays
    - contains
    #+BEGIN_SRC js
      db.food.insertOne({"fruit" : ["apple", "banana", "peach"]})
      db.food.find({"fruit" : "banana"}) // successfully match the document
    #+END_SRC
    - contains all: ~db.food.find({fruit : {$all : ["apple", "banana"]}})~
    - exact match: ~db.food.find({"fruit" : ["apple", "banana", "peach"]})~
    - index match: ~db.food.find({"fruit.2" : "peach"})~
    - ~$size~: not working with ~$gt~
    - ~$slice~: ~db.blog.posts.findOne(criteria, {"comments" : {"$slice" : [23, 10]}})~, ~db.blog.posts.findOne(criteria, {"comments" : {"$slice" : -1}})~
    - ~db.blog.posts.find({"comments.name" : "bob"}, {"comments.$" : 1})~: return the matching element with the ~$~
    - range query on array elements: ~db.test.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}})~
*** query embedded documents
    - ~db.people.find({"name.first" : "Joe", "name.last" : "Schmoe"})~

*** ~$where~
    - Allows you to execute arbitrary JavaScript as part of your query.(Insecure)

    "$where" queries should not be used unless *strictly necessary*: they are much slower than regular queries.
    Each document has to be converted from BSON to a JavaScript object and then run through the "$where" expression.

*** query options
    limit, skip, sort
    - Avoiding Large Skips: large skips are not very performant; there are suggestions for how to avoid them in the next section.

*** immortal cursors
    Tells the database not to time out the cursor.

** insert
*** insertMany
- Batch inserts limit: 48 MB. Drivers will split up the batch insert into multiple 48 MB batch inserts
**** ordererd vs unordered
- Executing an ordered list of operations on a sharded collection will generally be slower than executing an unordered list since with an ordered list, each operation must wait for the previous operation to finish.
- For unordered inserts, MongoDB will attempt to insert all documents, regardless of whether some insertions produce errors. execute the operations in parallel

*** insert
Old method before mongo 3.0. Use insertOne and insertMany instead

** delete
   - ~deleteOne~
   - ~deleteMany~
   - Clear an entire collection: ~drop~

** update
   Updating a document is atomic
   - ~updateOne~
   - ~updateMany~
   - ~replaceOne~: takes a filter as the first parameter, but as the second parameter replaceOne expects a document with which it will replace the document matching the filter.
   This can be useful to do a dramatic schema migration.

*** update operaters
    - ~{"$inc": {"field": 1}}~: create or increment 1
    - ~{"$set": {"new/existed field": "newValue"}}~, ~{"$unset": {"field": 1}}~
    - change embedded documents: ~{"$set": {"field.sub": "newValue"}}~
    - ~{"$setOnInsert" : {"createdAt" : new Date()}}~: can be useful for creating padding, initializing counters, and for collections that do not use ObjectIds.
    - ~findOneAndUpdate~ (after 4.2): can return the item and update it in a single operation
    - ~findOneAndReplace~
    - ~findOneAndDelete~

**** array operaters
     - ~{"$push": {"field": document}}~ adds elements to the end of an array if the array exists and creates a new array if it does not.
     - ~$each~: e.g. ~{"$push" : {"hourly" : {"$each" : [562.776, 562.790, 559.123]}}})~~
     - ~$slice~ can be used to create a queue in a document. e.g. ~{"$push" : {"last5" : {"$each" : ["Nightmare on Elm Street", "Saw"], "$slice" : -5}}})~
     - ~$sort~ If you only want the array to grow to a certain length, you can use the ~$slice~ modifier effectively making a “top N” list of items.
     #+BEGIN_SRC js
       db.movies.updateOne({"genre" : "horror"},
                           {"$push" : {"top10" : {"$each" : [{"name" : "Nightmare on Elm Street",
                                                              "rating" : 6.6},
                                                             {"name" : "Saw", "rating" : 4.3}],
                                                  "$slice" : -10,
                                                  "$sort" : {"rating" : -1}}}})
     #+END_SRC
     - ~$addToSet~: used to prevent duplicates
     - ~{"$pop" : {"key" : 1}}~ removes an element from the end of the array. ~{"$pop" : {"key" : -1}}~ removes it from the beginning.
     - ~$pull~ is used to remove elements of an array that match the given criteria.
     - update first match: e.g. set in comments array ~{"$set" : {"comments.$.author" : "Jim"}}~
     - ~$arrayFilters~
     #+BEGIN_SRC js
       db.blog.updateOne(
           {"post" : post_id },
           { $set: { "comments.$[elem].hidden" : true } },
           {
               arrayFilters: [ { "elem.votes": { $lte: -5 } } ]
           }
       )
       // This command defines elem as the identifier for each matching element in the "comments" array. If the votes value for the comment
       // identified by elem is less than or equal to -5, we will add a field called "hidden" to the "comments" document and set its value to true.
     #+END_SRC

*** upsert
    Eliminating race condition: query->if exists->update
* Server Administration
** mongod options
* Indexing
** Test Dataset
   #+BEGIN_SRC js
     for (i=0; i<1000000; i++) {
         db.users.insertOne(
             {
                 "i" : i,
                 "username" : "user"+i,
                 "age" : Math.floor(Math.random()*120),
                 "created" : new Date()
             }
         );
     }
   #+END_SRC

*** Profiling
   ~cursor.explain("executionStats")~

*** Stages
    - FETCH: "FETCH" stage will retrieve the documents themselves and return them in batches as the client requests them.
    - SORT: means MongoDB would have been unable to sort the result set in the database using an index and instead would have had to do an in-memory sort.

*** Query Types
    - equality filter: {"age": 25}
    - multivalue filter: {"age": {"$gte": 40}}
    - sort component

** Designing Indexes
   - selectivity: minimize the number of records scanned. "nReturned" is very close to "totalKeysExamined".
*** Designing a Compound Index
    1. Keys for equality filters should appear first.
    1. Keys used for sorting should appear before multivalue fields.
    1. Keys for multivalue filters should appear last.

** Specifying an Index to Use
   - ~hint([indexname])~ or ~hint([indexshape])~
