#+TITLE: Python Cookbook
#+KEYWORDS: python, cookbook
#+OPTIONS: H:3 toc:1 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: chrischen
#+EMAIL: chrischen3121@gmail.com
#+SETUPFILE: ../../org-templates/level-1.org
#+STARTUP: inlineimages
* Data Structures and Algorithms
** Unpacking from Iterables
   #+BEGIN_SRC python
     x, *middle, y = [1, 2, 3, 4, 5] # middle can be replaced by placeholder '_'
     # x => 1
     # y => 5

     data = ['ACME', 50, 91.1, (2012, 12, 21)]
     name, shares, price, (year, mon, day) = data
   #+END_SRC

** Keeping the Last N Items
   #+BEGIN_SRC python
     from collections import deque
     d=deque(maxlen=N)
   #+END_SRC

** Finding the Largest N Items
   #+BEGIN_SRC python
     import heapq
     heapq.nlargest(N, items)
     heapq.nsmallest(N, items)
     # heapq.nlargest(N, data, key=lambda function)
   #+END_SRC
   Underneath the covers, they work by first converting the data into a list
   where items are ordered as a heap.
   #+BEGIN_SRC python
     nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
     heapq.heapify(nums) # inplace function
     # nums => [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] heap[0] is the smallest
   #+END_SRC

** PriorityQueue Implemention
   #+BEGIN_SRC python
     import heapq

     class PriorityQueue:
         def __init__(self):
             self._queue = []
             self._index = 0 # use index to properly order items with the same priority level

         def push(self, item, priority):
             heapq.heappush(self._queue, (-priority, self._index, item))
             self._index += 1

         def pop(self):
             return heapq.heappop(self._queue)[-1]
   #+END_SRC

** defaultdict
   #+BEGIN_SRC python
     from collections import defaultdict
     d = defaultdict(list)
     d['a']
     #=> []
   #+END_SRC
   *defaultdict* will automatically create dictionary entries for keys accessed later on, alternative:
   #+BEGIN_SRC python
     d.setdefault('a', []).append(1)
   #+END_SRC
*** alternative
    #+BEGIN_SRC python
      d = {}
      # A regular dictionary
      d.setdefault('a', []).append(1)
    #+END_SRC

** OrderedDict
   An OrderedDict internally maintains a doubly linked list that orders the keys according to insertion order.

** sortedcontainers
   SortedList, SortedDict, SortedSet

** Calculating with Dictionaries
   #+BEGIN_SRC python
     prices = {
         'ACME': 45.23,
         'AAPL': 612.78,
         'IBM': 205.55,
         'HPQ': 37.20,
         'FB': 10.75
     }
     min_price = min(zip(prices.values(), prices.keys())) # zip to ((value, key)) generator

     min(prices, key=lambda k: prices[k]) # Returns 'FB'
     min_value = prices[min(prices, key=lambda k: prices[k])]
   #+END_SRC

** keys-view
   #+BEGIN_SRC python
     a.keys() & b.keys()
     a.keys() - {'z', 'w'} # {'z', 'w'} is a set
   #+END_SRC

** Naming a Slice
   #+BEGIN_SRC python
     a = [1,2,3,4,5]
     b = slice(1,2)

     a[b] #=> [2] slower than a[1]
   #+END_SRC

** Counting
  @contextmanager
def list_transaction(orig_list):
    working = list(orig_list)
    yield working
    orig_list[:] = working #+BEGIN_SRC python
     from collections import Counter
     word_counts1 = Counter(words1)
     word_counts2 = Counter(words2)
     word_counts1 + word_counts2
   #+END_SRC

** Sorting a List of Dictionaries
   #+BEGIN_SRC python
     from operator import itemgetter
     rows_by_fname = sorted(rows, key=itemgetter('fname'))
     rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))

     g = itemgetter(2, 5, 3) # the call g(r) returns (r[2], r[5], r[3])
   #+END_SRC

** Sorting Objects Without Native Comparison
   #+BEGIN_SRC python
     sorted(users, key=lambda u: u.user_id)
     from operator import attrgetter
     sorted(users, key=attrgetter('user_id'))
     by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
   #+END_SRC

** groupby
   Since =groupby()= only examines consecutive items, should sort the groupby key first.
   #+BEGIN_SRC python
     from itertools import groupby
     rows.sort(key=itemgetter('date'))
     for date, items in groupby(rows, key=itemgetter('date')):
         pass
     # alternative if memory is no concern, and faster than sort+groupby
     rows_by_date = defaultdict(list)
     for row in rows:
         rows_by_date[row['date']].append(row)
   #+END_SRC
** itertools.compress
   Like boolean index in pandas. Takes an iterable and an accompanying Boolean selector sequence as input.
   =list(compress(data, mask))=

** namedtuple & namedlist
   optional or missing fields
   #+BEGIN_SRC python
     Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
     Stock.__new__.__defaults__ = ('', 0, 0, None, None)
     # or
     stock_prototype = Stock('', 0, 0.0, None, None)

     def dict_to_stock(s):
         return stock_prototype._replace(**s)
   #+END_SRC
*** useful method
    - ~_make~: Make a new Stock object from a sequence or iterable
    - ~_replace~
    - ~_fields~
    - ~_asdict~

** sum, min,...
   #+BEGIN_SRC python
     s = sum((x * x for x in nums))
     s = sum(x * x for x in nums) # same as above

     # Original: Returns 20
     min_shares = min(s['shares'] for s in portfolio)
     # Alternative: Returns {'name': 'AOL', 'shares': 20}
     min_shares = min(portfolio, key=lambda s: s['shares'])
   #+END_SRC

** ChainMap
   A ChainMap takes multiple mappings and makes them logically appear as one. If there are duplicate keys,
   the values from the first mapping get used.
   #+BEGIN_SRC python
     from collections import ChainMap
     c = ChainMap(a,b)
     # alternative
     c = b
     c.update(a)
   #+END_SRC
   - but ChainMap keep the reference of a&b

*** store scoped values
   A ChainMap is particularly useful when working with scoped values such as variables in
   a programming language (i.e., globals, locals, etc.)
   #+BEGIN_SRC python
     values = ChainMap()
     values['x'] = 1
     values = values.new_child()
     values['x'] = 2
     values['x'] #=> 2
     values = values.parents
     values['x'] #=> 1
   #+END_SRC
* String Manipulation
** modules
   - *fnmatch*: Filename matching with shell patterns.
   - *glob*: Filename globbing utility.

** re
*** find
    - =match()=
    - =findall()=
    - =finditer()=
    - =scaner()=

*** replace
    - =sub=

*** regex
    - named capture group: =r'?P<TOKENNAME>[a-zA-Z]+'=
    - noncapture

*** tokenize
**** Problem
     You have a string that you want to parse left to right into a stream of tokens.
**** Usage
    #+BEGIN_SRC python
      from collections import namedtuple
      Token = namedtuple('Token', ['type', 'value'])


      def generate_tokens(pat, text):
          scanner = pat.scanner(text)
          for m in iter(scanner.match, None):
              yield Token(m.lastgroup, m.group())


      # Example use
      for tok in generate_tokens(master_pat, 'foo = 42'):
          print(tok)

      # Produces output
      # Token(type='NAME', value='foo')
      # Token(type='WS', value=' ')
      # Token(type='EQ', value='=')
      # Token(type='WS', value=' ')
      # Token(type='NUM', value='42')
    #+END_SRC
    =scanner()= method of pattern objects. This method creates a scanner object in which repeated calls to match() step through the
    supplied text one match at a time

*** syntax parser
    - PyParsing
    - PLY
    - Recipe: 2.19

** format
*** align
    #+BEGIN_SRC python
      format('right', '>20')
      # '               right'
      format('right', '=>20')
      # '===============right'
    #+END_SRC

*** safesub
    #+BEGIN_SRC python
      class safesub(dict):
          def __missing__(self, key):
              return '{' + key + '}'

      name = 'ABC'
      n = 5
      s = '{name} has {n} messages.'
      s.format_map(safesub(vars()))
      # 'ABC has 5 messages.'
    #+END_SRC
**** frame hack
     #+BEGIN_SRC python
       def sub(text):
           return text.format_map(safesub(sys._getframe(1).f_locals))
     #+END_SRC

*** textwrap
    The textwrap module is a straightforward way to clean up text for printing.
    =textwrap.fill()= reformat text for output.

** join
   - ='abc' + ',' + 'def'=
   - ='abc' ',' 'def'=
   - =','.join(('abc', 'def'))=
   - ='{},{}'.format('abc', 'def')=
   - print('abc', 'def', sep=',')

** Combining I/O Write Operation
   #+BEGIN_SRC python
     def combine(source, maxsize):
         parts = []
         size = 0
         for part in source:
             parts.append(part)
             size += len(part)
             if size > maxsize:
                 yield ''.join(parts)
                 parts = []
                 size = 0
         yield ''.join(parts)

     for part in combine(sample(), 32768):
         f.write(part)
   #+END_SRC
   - Example: write to socket send buffer

** escape
   - =html.escape=
   - =xml.escape=

** Tokenizing Text
   #+BEGIN_SRC python
     import re
     from collections import namedtuple

     NAME = r'(?P<NAME>[a-zA-Z_][a-zA-Z_0-9]*)'
     NUM = r'(?P<NUM>\d+)'
     PLUS = r'(?P<PLUS>\+)'
     TIMES = r'(?P<TIMES>\*)'
     EQ = r'(?P<EQ>=)'
     WS = r'(?P<WS>\s+)'

     master_pat = re.compile('|'.join([NAME, NUM, PLUS, TIMES, EQ, WS]))

     Token = namedtuple('Token', ['type', 'value'])


     def generate_tokens(pat, text):
         # scanner method creates a scanner object in which repeated calls to match()
         # step through the supplied text one match at a time
         scanner = pat.scanner(text)
         for m in iter(scanner.match, None):
             yield Token(m.lastgroup, m.group())


     tokens = (tok for tok in generate_tokens(master_pat, 'foo = 42')
               if tok.type != 'WS')
     for tok in tokens:
         print(tok)

     # Produces output
     # Token(type='NAME', value='foo')
     # Token(type='EQ', value='=')
     # Token(type='NUM', value='42')
   #+END_SRC

* Numbers
** round
   #+BEGIN_SRC python
     round(1.29, 1)
     # => 1.3
     round(1245, -1)
     # => 1240
     round(1275, -1)
     # => 1280
   #+END_SRC

** Decimal
   #+BEGIN_SRC python
     from decimal import Decimal, localcontext
     a = Decimal('6.32')
     b = Decimal('2.41')

     with localcontext() as ctx:
         ctx.prec = 5
         print(a/b) # 2.6224
   #+END_SRC

** Formatting
   #+BEGIN_SRC python
     x = 1234.56789
     format(x, '0.2f')
     # => '1234.57'   # round
     format(x, '>10.1f')
     # => '    1234.6'
     format(x, '0,.1f')
     # => '1,234.6

     x = 1234
     bin(x)  # others: oct, hex
     # => '0b10011010010'
     format(x, 'b')  # others: o, x
     # => '0011010010'
     int('10011010010', 2)
     # => 1234
   #+END_SRC

** Bin, Oct, Hex Int
   #+BEGIN_SRC python
     x = -1234
     format(x, 'b')
     #=> '-10011010010'
     format(x, 'x')
     #=> '-4d2'
     format(2**32 + x, 'b')
     #=> '11111111111111111111101100101110'
     format(2**32 + x, 'x')
     #=> 'fffffb2e'
     int('4d2', 16)
     #=> 1234
     int('10011010010', 2)
     #=> 1234
   #+END_SRC

** Bytes2Int
   #+BEGIN_SRC python
     data = b'\x00\x124V\x00x\x90\xab\x00\xcd\xef\x01\x00#\x004'
     x = int.from_bytes(data, 'little')  # or 'big

     x = 94522842520747284487117727783387188
     x.to_bytes(16, 'little')
   #+END_SRC
   useful in cryptography or networking domains
   - ~struct~ module
   - ~int.bit_length()~

** Complex Math
   #+BEGIN_SRC python
     a = complex(2, 4)
     b = 3 - 5j
     a.conjugate()
     #=> (2-4j)
     abs(a)
     #=> 4.47213595499958
     a * b
     #=> (26+2j)

     import cmath
     cmath.sin(a)
     #=> (24.83130584894638-11.356612711218174j)

     import numpy as np
     a = np.array([2 + 3j, 4 + 5j, 6 - 7j, 8 + 9j])
     np.sin(a)
   #+END_SRC

** random
   - =random.choice=
   - =random.sample=
   - =random.shuffle=
   - =random.randint=
   - =random.random=: 0 to 1
   - =random.getrandbits=
*** seed
    #+BEGIN_SRC python
      random.seed()  # Seed based on system time or os.urandom()
      random.seed(12345)  # Seed based on integer given
      random.seed(b'bytedata')  # Seed based on byte data
    #+END_SRC

*** distribution
    - =random.uniform=
    - =random.gauss=

** math.f***
   - =math.fsum=
   - =math.fmod=
   - =math.fabs=

* Datetime
** Finding Last Friday
   #+BEGIN_SRC python
     from dateutil.relativedelta import relativedelta
     from dateutil.rrule import FR
     d = datetime.now()
     print(d + relativedelta(weekday=FR(-1)))
   #+END_SRC

** Timezone
   #+BEGIN_SRC python
     import pytz
     d = datetime.now() # no timezone info
     print(d)
     # => 2018-12-21 17:14:01.258941

     shanghai = pytz.timezone('Asia/Shanghai')
     loc_d = shanghai.localize(d) # Localize the date for Shanghai
     print(loc_d)
     # => 2018-12-21 17:14:01.258941+08:00

     # Once the date has been localized, it can be converted to other time zones
     utc_d = loc_d.astimezone(pytz.utc)
     print(utc_d)
     # => 2018-12-21 09:14:01.258941+00:00
   #+END_SRC

   - ~datetime.replace~
   - ~datetime.astimezone~

* Iterator
** Manually Consuming an Iterator
   #+BEGIN_SRC python
     iterable = iter(range(5))  # Invokes range.__iter__()
     try:
         while True:
             line = next(iterable)  # Invokes iterable.__next__()
             print(line, end='')
     except StopIteration:
         pass

     # non exception version
     while True:
         line = next(iterable, None)
         if line is None:
             break
         print(line, end='')
   #+END_SRC
   - Python’s iterator protocol requires ~__iter__()~ to return a special iterator object that implements a ~__next__()~ method to carry out the actual iteration.
** Iterating Over Multi Sequences
   #+BEGIN_SRC python
     a = [1, 2, 3]
     b = ['w', 'x', 'y', 'z']

     for i in zip(a, b):
         print(i)
     #=> (1, 'w') (2, 'x') (3, 'y')

     from itertools import zip_longest
     for i in zip_longest(a, b):
         print(i)
     #=> (1, 'w') (2, 'x') (3, 'y') (None, 'z')
   #+END_SRC

** ~dropwhile~
   Drop all of the initial comment lines.

** Permutation & Combination
   - ~combinations~, ~permutations~, ~combinations_with_replacement~

** ~itertools.chain~
   Concatenate two iterables(copy-free)
** Data Processing Pipelines
** Flattening a Nested Sequence
   #+BEGIN_SRC python
     from collections import Iterable


     def flatten(items, ignore_types=(str, bytes)):
         for x in items:
             if isinstance(x, Iterable) and not isinstance(x, ignore_types):
                 yield from flatten(x)
             else:
                 yield x

     items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
     for x in flatten(items):
         print(x)
   #+END_SRC
** Merge Two Sorted Iterables
   #+BEGIN_SRC python
     import heapq
     a = [1, 4, 7, 10]
     b = [2, 5, 6, 11]
     for c in heapq.merge(a, b):
         print(c)
   #+END_SRC
** ~iter()~
   <<iter>>
   ~iter()~ optionally accepts a zero-argument *callable* and *sentinel* (terminating) value as inputs.
   #+BEGIN_SRC python
     for chunk in iter(lambda: fs.read(10), ''):
         print(chunk)
   #+END_SRC
* I/O
** Encoding
   #+BEGIN_SRC python
     with open('somefile.txt', 'rt', encoding='latin-1') as f:
         ...
   #+END_SRC
   *latin-1* encoding is notable in that it will never produce a decoding error when reading text of a possibly unknown encoding.
   #+BEGIN_SRC python
     # Replace bad chars with Unicode U+fffd replacement char
     open('sample.txt', 'rt', encoding='ascii', errors='replace')

     # Ignore bad chars entirely
     open('sample.txt', 'rt', encoding='ascii', errors='ignore')
   #+END_SRC
** ~readinto~
   #+BEGIN_SRC python
     import array
     a = array.array('i', [0, 0, 0, 0, 0, 0, 0, 0])
     with open('data.bin', 'rb') as f:
         f.readinto(a)
   #+END_SRC
   ~readinto()~ fills the contents of an existing buffer
   - One caution with using ~f.readinto()~~ is that you must always make sure to check its return code, which is the number of bytes actually read.
** ~io.StringIO~, ~io.BytesIO~
** ~gzip.open~, ~bz2.open~
** Iterating Over Fixed-Sized Records
   #+BEGIN_SRC python
     from functools import partial

     RECORD_SIZE = 32

     with open('somefile.data', 'rb') as f:
         records = iter(partial(f.read, RECORD_SIZE), b'')
         for r in records:
             ...
   #+END_SRC
   - [[iter]]

** In-memory Modification
*** ~nmap~
    Use the ~mmap~ module to memory map files for random access to its contents or to make in-place modifications.
    - ~nmap~ also can be used to exchange data between interpreters

*** ~memoryview~
   #+BEGIN_SRC python
     buf = bytearray(b'Hello World')
     m1 = memoryview(buf)
     m2 = m1[-5:]
     #m2=> <memory at 0x100681390>
     m2[:] = b'WORLD'
     #buf=> bytearray(b'Hello WORLD')
   #+END_SRC

** ~os.path~
   #+BEGIN_SRC python
     os.path.basename(path)
     os.path.dirname(path)
     os.path.expanduser(path)
     os.path.splitext(path)  # Split the file extension
     os.path.exists(path)
     os.path.isfile(path) # isdir, islink
     os.path.realpath('/usr/local/bin/python3') # => '/usr/local/bin/python3.3'
     os.path.getsize() # getmtime
     os.listdir(dir)
   #+END_SRC
   - other module: ~glob~, ~fnmatch~ used for filename matching
** Changing Encoding of a File
   #+BEGIN_SRC python
     import io
     # decode a binary file
     with open('some_binary_file.bin', 'rb') as open_file:
         fs = io.TextIOWrapper(open_file, encoding='utf8')
         text = fs.read()

     # change encoding
     import sys
     sys.stdout.encoding  #=> 'UTF-8'
     # use its detach() method to remove the existing text encoding layer before replacing it with a new one
     sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding='latin-1')
     sys.stdout.encoding #=> 'latin-1'
   #+END_SRC
   - layers on I/O:
   #+BEGIN_SRC python
     f = open('sample.txt', 'w')
     # a text-handling layer that encodes and decodes Unicode
     f # => <_io.TextIOWrapper name='sample.txt' mode='w' encoding='UTF-8'>

     # a buffered I/O layer that handles binary data
     f.buffer # => <_io.BufferedWriter name='sample.txt'>
     f.buffer.write(b'hello\n') # write bytes to a text file

     # io.FileIO is a raw file representing the low-level file descriptor in the operating system
     f.buffer.raw # => <_io.FileIO name='sample.txt' mode='wb'>
   #+END_SRC
   - ~detach~: disconnects the topmost layer of a file and returns the next lower layer.

** File Descriptor
   #+BEGIN_SRC python
     # Create a file object, but don't close underlying fd when done
     f = open(fd, 'wt', closefd=False)

     def echo_client(client_sock, addr):
         print('Got connection from', addr)

         # Make text-mode file wrappers for socket reading/writing, only works on Unix-based systems
         # Use the makefile() method of sockets instead to be cross platform
         client_in = open(client_sock.fileno(), 'rt', encoding='latin-1',
                              closefd=False)
         client_out = open(client_sock.fileno(), 'wt', encoding='latin-1',
                               closefd=False)

         # Echo lines back to the client using file I/O
         for line in client_in:
             client_out.write(line)
             client_out.flush()
         client_sock.close()
   #+END_SRC
** Temporary Files
   #+BEGIN_SRC python
     from tempfile import TemporaryFile, NamedTemporaryFile, TemporaryDirectory
     with TemporaryFile('w+t', encoding='utf-8', errors='ignore') as f:
         f.write('Hello World\n')

     with NamedTemporaryFile(
             'w+t', delete=False, prefix='mytemp', suffix='.txt', dir='/tmp') as f:
         print('filename is:', f.name)  #=> /tmp/mytemp2tmz4nl5.txt

     with TemporaryDirectory() as dirname:
         print('dirname is:', dirname)
   #+END_SRC

** Serializing Python Objects
   ~pickle~ is a Python-specific self-describing data encoding
*** Dealing with Multiple Objects
    #+BEGIN_SRC python
      import pickle
      with open('somedata', 'wb') as fs:
          pickle.dump([1, 2, 3, 4], fs)
          pickle.dump('hello', fs)

      with open('somedata', 'rb') as fs:
          pickle.load(fs) # => [1, 2, 3, 4]
          pickle.load(fs) # => hello
    #+END_SRC

*** Safety
    ~pickle.load()~ should never be used on untrusted data

*** User-defined Classes
    Certain kinds of objects can’t be pickled. These are typically objects that involve some sort of external system state, such as open files,
    open network connections, threads, processes, stack frames, and so forth. User-defined classes can sometimes work around these limitations
    by providing ~__getstate__()~ and ~__setstate__()~ methods
    - ~pickle.dump()~ will call ~__getstate__()~ to get an object that can be pickled

* Encoding
** csv
*** ~reader~
    #+BEGIN_SRC python
      from collections import namedtuple
      import re
      import csv
      with open('stock.csv') as f:
          f_csv = csv.reader(f)
          headings = next(f_csv)
          Row = namedtuple('Row', headings)
          for r in f_csv:
              row = Row(*r)
              # Process row
    #+END_SRC

*** ~DictReader~
   #+BEGIN_SRC python
     import csv
     with open('stocks.csv') as f:
         f_csv = csv.DictReader(f)
         for row in f_csv:
             # process row
             ...
   #+END_SRC

*** ~writer~
    - ~writer.writerow~ and ~writer.writerows~

*** ~DictWriter~
    - ~writer.writeheader~ and ~writer.writerows~
** json2object
   - use ~object_pairs_hook~ and ~object_hook~ options
   #+BEGIN_SRC python
     import json
     from collections import OrderedDict
     s = '{"name": "ACME", "shares": 50, "price": 490.1}'
     data = json.loads(s, object_pairs_hook=OrderedDict)
     # data => OrderedDict([('name', 'ACME'), ('shares', 50), ('price', 490.1)])

     class JSONObject:
         def __init__(self, d):
             self.__dict__ = d

         def __str__(self):
             return str(self.__dict__)


     obj = json.loads(s, object_hook=JSONObject)
     obj.name = 'def'

     json.dumps(vars(obj)) # vars(obj) same as obj.__dict__
     # or
     json.dumps(obj, default=vars) # use vars as a serializing function
   #+END_SRC

** xml
   #+BEGIN_SRC python
     from xml.etree.ElementTree import parse
     doc = parse(xml_str)
   #+END_SRC
   - ~lxml~
   - for huge xml: =Recipe 6.4=
   - more: =Recipe 6.3~6.7=

** hex encoding
   - ~binascii~
   #+BEGIN_SRC python
     import binascii

     s = b'hello'
     h = binascii.b2a_hex(s) # bytes2hexbytes b'68656c6c6f'
     b = binascii.a2b_hex(h) # hexbytes2bytes
   #+END_SRC
   - ~base64~
   #+BEGIN_SRC python
     import base64
     s = b'hello'
     h = base64.b16encode(s) # b'68656C6C6F' uppercase
     b = base64.b16decode(h)
   #+END_SRC

** base64
   - ~base64.b64encode~
   - ~base64.b64decode~

** struct
   #+BEGIN_SRC python
     from struct import Struct

     def write_records(records: tuple, format, f):
         record_struct = Struct(format)
         for r in records:
             f.write(record_struct.pack(*r))

     def read_records(format, f) -> tuple:
         record_struct = Struct(format)
         chunks = iter(lambda: f.read(record_struct.size), b'') # star!
         return (record_struct.unpack(chunk) for chunk in chunks) # star!

   #+END_SRC
   - more to explore =Recipe 6.12=

* Functions
** Keyword-only Arguments
   #+BEGIN_SRC python
     def recv(maxsize, *, block):
         pass

     recv(1024, True)# TypeError
     recv(1024, block=True) # OK
   #+END_SRC

** Capture Variables
   #+BEGIN_SRC python
     x = 10
     a = lambda y, x=x: x + y # use x=x to bind at definition time
     x = 20
     a(5) # => 15
   #+END_SRC

** Replace Single-method Classes with Closures

** Callback Shared State
   =Recipe 7.10= four ways:
   - single-method class
   - closure
   - coroutine: use coroutine.send as callback
   - use ~functools.partial~
* Class
** String Representation
   - ~__repr__~: returns the code representation of an instance, and is usually the text you would type to recreate the instance. ~eval(repr(x)) == x~
   - ~__str__~: converts the instance to a string.

** ~__format__~
   #+BEGIN_SRC python
     _formats = {
         'ymd' : '{d.year}-{d.month}-{d.day}',
         'mdy' : '{d.month}/{d.day}/{d.year}',
         'dmy' : '{d.day}/{d.month}/{d.year}'
         }
     from datetime import date
     d = date.today()
     format(d, 'mdy')
     'The date is {:ymd}'.format(d)
   #+END_SRC

** Context Management
   #+BEGIN_SRC python
     class Connection:
         def __enter__(self):
             self.fs = open('somefile.txt', 'rt')
             return self.fs

         def __exit__(self, exc_ty, exc_val, tb):
             self.fs.close()
             self.fs = None
   #+END_SRC

** Saving Memory ~__slots__~
   - Instances are built around a small fixed-sized array instead of a dictionary.
   - A side effect of using slots is that it is no longer possible to add new attributes to instances.
   #+BEGIN_SRC python
     class Date:
         __slots__ = ['year', 'month', 'day']
         def __init__(self, year, month, day):
             self.year = year
             self.month = month
             self.day = day
   #+END_SRC

** Properties
   #+BEGIN_SRC python
     class Object:
         @property
         def attr(self):
             return self.__attr

         @attr.setter
         def attr(self, value):
             self.__attr = value

         @attr.deleter
         def attr(self):
             self.__attr = None
         # del obj.attr
   #+END_SRC
*** Extending a Property
    #+BEGIN_SRC python
      class SubPerson(Person):
          @property
          def name(self):
              print('Getting name')
              return super().name

          @name.setter
          def name(self, value):
              print('Setting name to', value)
              # the only way to get to setter method is to access it as a class variable
              super(SubPerson, SubPerson).name.__set__(self, value)

          @name.deleter
          def name(self):
              print('Deleting name')
              super(SubPerson, SubPerson).name.__delete__(self)
    #+END_SRC
    - Extending only ~getter~ method
      #+BEGIN_SRC python
        class SubPerson(Person):
            @Person.name.getter
            def name(self):
                print('Getting name')
                return super().name
      #+END_SRC

** ~super()~
   - To avoid double-invocation when involving multiple inheritance.
   - Use ~__mro__~ to see method resolution order.

*** MRO
    The actual determination of the MRO list itself is made using a technique known as C3 Linearization.
    - Child classes get checked before parents.
    - Multiple parents get checked in the order listed.
    - If there are two valid choices for the next class, pick the one from the first parent.
    When you use the ~super()~ function, Python continues its search starting with the next class on the MRO. See Chapter 8.7 [[https://rhettinger.wordpress.com/2011/05/26/super-considered-super/][More details]].

    - Hint: ~super(MyClass, self).__init__()~ provides the next ~__init__~ method according to the used Method Resolution Ordering(MRO)
*** Multiple Inheritance with Different Arguments to Constructors
   #+BEGIN_SRC python
     class A:
         def __init__(self, a, **kw):
             super().__init__(**kw)
             print('A a', a)


     class B:
         def __init__(self, b, c=0, **kw):
             super().__init__(**kw)
             print('B b', b)
             print('B c', c)


     class C(A, B):
         def __init__(self, a, b, c, d):
             super().__init__(a=a, b=b, c=c)
             print('C d', d)
   #+END_SRC
   or
   #+BEGIN_SRC python
     class C(A, B):
         def __init__(self, a, b, c):
             A.__init__(self, a)
             B.__init__(self, b, c)
    # should be careful with double-invocation
   #+END_SRC

** *Descriptor*
   Descriptors provide the underlying magic for most of Python’s class features, such as ~@classmethod~, ~@staticmethod~, ~@property~.
   - ~__get__(self, instance, cls)~
   - ~__set__(self, instance, value)~
   - ~__delete__(self, instance)~
   #+BEGIN_SRC python
     class String:
         def __init__(self, name):
             self.name = name

         def __get__(self, instance, cls):
             if instance is None:  # called as class variable
                 return self
             return instance.__dict__[self.name]

         def __set__(self, instance, value):
             if not isinstance(value, str):
                 raise TypeError('Expected a string')
             instance.__dict__[self.name] = value

         def __delete__(self, instance):
             del instance.__dict__[self.name]


     class Person:
         name = String('name')

         def __init__(self, name):
             self.name = name
   #+END_SRC
*** Advanced Usage
    #+BEGIN_SRC python
      # Descriptor for a type-checked attribute
      class Typed:
          def __init__(self, name, expected_type):
              self.name = name
              self.expected_type = expected_type

          def __get__(self, instance, cls):
              if instance is None:
                  return self
              else:
                  return instance.__dict__[self.name]

          def __set__(self, instance, value):
              if not isinstance(value, self.expected_type):
                  raise TypeError('Expected ' + str(self.expected_type))
              instance.__dict__[self.name] = value

          def __delete__(self, instance):
              del instance.__dict__[self.name]


      # Class decorator that applies it to selected attributes
      def typeassert(**kwargs):
          def decorate(cls):
              for name, expected_type in kwargs.items():
                  # Attach a Typed descriptor to the class
                  setattr(cls, name, Typed(name, expected_type))
                  return cls

          return decorate


      # Example use
      @typeassert(name=str, shares=int, price=float)
      class Stock:
          def __init__(self, name, shares, price):
              self.name = name
              self.shares = shares
              self.price = price
    #+END_SRC

*** Lazy Properties
    Define a read-only attribute as a property that only gets computed on access.
    #+BEGIN_SRC python
      class lazyproperty:
          def __init__(self, func):
              self.func = func

          def __get__(self, instance, cls):
              if instance is None:
                  return self
              else:
                  value = self.func(instance)
                  setattr(instance, self.func.__name__, value)
                  return value


      class Circle:
          def __init__(self, radius):
              self.radius = radius

          @lazyproperty
          def area(self):
              print('Computing area')
              return math.pi * self.radius**2
    #+END_SRC

*** Data Model
    #+BEGIN_SRC python
      # Base class. Uses a descriptor to set a value
      class Descriptor:
          def __init__(self, name=None, **opts):
              self.name = name
              for key, value in opts.items():
                  setattr(self, key, value)

          def __set__(self, instance, value):
              instance.__dict__[self.name] = value


      # Descriptor for enforcing types
      class Typed(Descriptor):
          expected_type = type(None)

          def __set__(self, instance, value):
              if not isinstance(value, self.expected_type):
                  raise TypeError('expected ' + str(self.expected_type))
              super().__set__(instance, value)


      # Descriptor for enforcing values
      class Unsigned(Descriptor):
          def __set__(self, instance, value):
              if value < 0:
                  raise ValueError('Expected >= 0')
              super().__set__(instance, value)


      class Integer(Typed):
          expected_type = int


      class UnsignedInteger(Integer, Unsigned):
          pass
    #+END_SRC

**** Simplify the Specification by Class Decorator
     #+BEGIN_SRC python
       # Class decorator to apply constraints
       def check_attributes(**kwargs):
           def decorate(cls):
               for key, value in kwargs.items():
                   if isinstance(value, Descriptor):
                       value.name = key
                       setattr(cls, key, value)
                   else:
                       setattr(cls, key, value(key))
               return cls
           return decorate

       # Example
       @check_attributes(name=SizedString(size=8),
                         shares=UnsignedInteger,
                         price=UnsignedFloat)
       class Stock:
           def __init__(self, name, shares, price):
               self.name = name
               self.shares = shares
               self.price = price
     #+END_SRC

**** Simplify the Specification by Metaclass
     #+BEGIN_SRC python
       # A metaclass that applies checking
       class checkedmeta(type):
           def __new__(cls, clsname, bases, methods):
               # Attach attribute names to the descriptors
               for key, value in methods.items():
                   if isinstance(value, Descriptor):
                       value.name = key
                   return type.__new__(cls, clsname, bases, methods)


       # Example
       class Stock(metaclass=checkedmeta):
           name = SizedString(size=8)
           shares = UnsignedInteger() # no need to give a name
           price = UnsignedFloat()

           def __init__(self, name, shares, price):
               self.name = name
               self.shares = shares
               self.price = price
     #+END_SRC

**** Decorator Version(Preferred Approach)
     #+BEGIN_SRC python
       # Base class. Uses a descriptor to set a value
       class Descriptor:
           def __init__(self, name=None, **opts):
               self.name = name
               for key, value in opts.items():
                   setattr(self, key, value)

           def __set__(self, instance, value):
               instance.__dict__[self.name] = value


       # Decorator for applying type checking
       def Typed(expected_type, cls=None):
           if cls is None:
               return lambda cls: Typed(expected_type, cls)

           super_set = cls.__set__

           def __set__(self, instance, value):
               if not isinstance(value, expected_type):
                   raise TypeError('expected ' + str(expected_type))
               super_set(self, instance, value)

           cls.__set__ = __set__
           return cls


       @Typed(int)
       class Integer(Descriptor):
           pass
     #+END_SRC

** Simplifying Initialization
   #+BEGIN_SRC python
     class Structure:
         # Class variable that specifies expected fields
         _fields = []

         def __init__(self, *args):
             if len(args) != len(self._fields):
                 raise TypeError('Expected {} arguments'.format(len(self._fields)))

             # Set the arguments
             for name, value in zip(self._fields, args):
                 setattr(self, name, value)


     class Stock(Structure):
         _fields = ['name', 'shares', 'price']
   #+END_SRC
   - Downside: documentation and help features of IDEs. It can be solved by attaching or enforcing a type signature

** Abstract Base Class
   - Define an abc class: ~class AbstractBase(metaclass=abc.ABCMeta)~
   - Using ~register~ to bind other class which is already defined
   - ~@abstractmethod~ can work with ~@staticmethod~, ~@classmethod~

** Implementing Custom Containers
   - ~Container~: ~__contains__~
   - ~Iterable~: ~__iter__~
   - ~Sized~: ~__len__~
   - ~Sequence~: ~__getitem__~, ~__len__~
   - ~MutableSequence~: ~__delitem__~, ~__getitem__~, ~__len__~, ~__setitem__~, ~insert~

** Proxy Class
   Implement ~__getattr__~, ~__setattr__~, ~__delattr__~
   - ~__getattr__~ method is actually a fallback method that only gets called when an attribute is not found.

** Multiple Constructors
   - Use ~@classmethod~, example: ~Date.today~
   - Use ~cls.__new__(cls)~ to create instance without initialization.

** Mixin Class
   - To enhance the functionality of existing classes with optional features.
   - See Recipe 8.18, example: ~ThreadedXMLRPCServer(ThreadingMixIn, SimpleXMLRPCServer)~
   - Mixin classes are never meant to be instantiated directly.
   - Mixin classes typically have no state of their own(not a restriction)
   - Use ~__slots__ = ()~ to serve as a strong hint that the mixin classes do not have their own instance data.
   - Use class decorator to patch method(preferred approach)

** State Machine
   Based on state design pattern. See Recipe 8.19, should use ~__class__~

** Calling a Method by Name
   - ~getattr~
   - ~operator.methodcaller()~

** Visitor Pattern
   *Recipe 8.21*
*** *Without Recursion*
    *Recipe 8.22*
    - Use *stack* (like depth-first traversal) and generator
    #+BEGIN_SRC python
      import types


      class Node:
          pass


      class NodeVisitor:
          def visit(self, node):
              stack = [node]
              last_result = None
              while stack:
                  try:
                      last = stack[-1]
                      if isinstance(last, types.GeneratorType):
                          stack.append(last.send(last_result))
                          last_result = None
                      elif isinstance(last, Node):
                          stack.append(self._visit(stack.pop()))
                      else:
                          last_result = stack.pop()
                  except StopIteration:
                      stack.pop()
              return last_result


      def _visit(self, node):
          methname = 'visit_' + type(node).__name__
          meth = getattr(self, methname, None)
          if meth is None:
              meth = self.generic_visit
          return meth(node)


      def generic_visit(self, node):
          raise RuntimeError('No {} method'.format('visit_' + type(node).__name__))
    #+END_SRC

** Comparison
   ~__le__~, ~__ge__~, ~__lt__~, ~__gt__~, ~__eq__~

** ~weakref~
*** Avoid Cyclic Reference
    ~weakref.ref~

*** Cache Instances(like ~logging.getLogger~)
    Use ~weakref.WeakValueDictionary~ to store instances as weak reference

* Metaprogramming
** ~functools.wrap~
   - Preserving function metadata, ~__name__~, ~__doc__~, ~__annotations__~.
   - original function in ~__wrapped__~ (hint: ~@classmethod~ and ~@staticmethod~ store original function in ~__func__~)

** Decorator with get/set
   #+BEGIN_SRC python
     def attach_wrapper(obj, func=None):
         if func is None:
             return partial(attach_wrapper, obj)
         setattr(obj, func.__name__, func)
         return func
   #+END_SRC

** Decorator with Optional Arguments
   example:
   #+BEGIN_SRC python
     import logging
     from functools import partial, wraps


     def logged(func=None, *, level=logging.DEBUG, name=None, message=None):
         if func is None:
             return partial(logged, level=level, name=name, message=message)
         logname = name if name else func.__module__
         log = logging.getLogger(logname)
         logmsg = message if message else func.__name__

         @wraps(func)
         def wrapper(*args, **kwargs):
             log.log(level, logmsg)
             return func(*args, **kwargs)

         return wrapper
   #+END_SRC

** Type Checking Decorator
   #+BEGIN_SRC python
     from inspect import signature
     from functools import wraps


     def typeassert(*ty_args, **ty_kwargs):
         def decorate(func):
             # If in optimized mode, disable type checking
             if not __debug__:
                 return func
             # Map function argument names to supplied types
             sig = signature(func)
             bound_types = sig.bind_partial(*ty_args, **ty_kwargs).arguments

             @wraps(func)
             def wrapper(*args, **kwargs):
                 bound_values = sig.bind(*args, **kwargs)
                 # Enforce type assertions across supplied arguments
                 for name, value in bound_values.arguments.items():
                     if name in bound_types:
                         if not isinstance(value, bound_types[name]):
                             raise TypeError('Argument {} must be {}'.format(
                                 name, bound_types[name]))
                 return func(*args, **kwargs)
             return wrapper
         return decorate


     @typeassert(int, z=int)
     def add(x, y, z=42):
         return x + y + z
   #+END_SRC

** Decorator as Functional Class
   #+BEGIN_SRC python
     import types
     from functools import wraps


     class Profiled:
         def __init__(self, func):
             wraps(func)(self)
             self.ncalls = 0

         def __call__(self, *args, **kwargs):
             self.ncalls += 1
             return self.__wrapped__(*args, **kwargs)

         def __get__(self, instance, cls):
             if instance is None:
                 return self
             else:
                 return types.MethodType(self, instance)


     @Profiled
     def add(x, y):
         return x + y


     add(4, 5)
     print(add.ncalls)
   #+END_SRC
** ~inspect~
   - signature
   - getargspec
   - Parameter

** Using Decorators to Patch Class Definitions
   #+BEGIN_SRC python
     def patch(cls):
         orig_method = cls.method

         def new_method(self):
             return orig_method(self)

         cls.method = new_method
   #+END_SRC
** Enforcing an Argument Signature on *args and **kwargs
*** Creating a Function Signature
    #+BEGIN_SRC python
      from inspect import Signature, Parameter

      # Make a signature for a func(x, y=42, *, z=None)

      parms = [
          Parameter('x', Parameter.POSITIONAL_OR_KEYWORD),
          Parameter('y', Parameter.POSITIONAL_OR_KEYWORD, default=42),
          Parameter('z', Parameter.KEYWORD_ONLY, default=None)
      ]
      sig = Signature(parms)
      print(sig)

      def func(*args, **kwargs):
          bound_values = sig.bind(*args, **kwargs)
    #+END_SRC

*** *Enforcing Function Signatures*
    #+BEGIN_SRC python
      from inspect import Signature, Parameter
      def make_sig(*names):
          parms = [Parameter(name, Parameter.POSITIONAL_OR_KEYWORD)
                   for name in names]
          return Signature(parms)

      class Structure:
          __signature__ = make_sig() # inspect.signature will lookup __signature__
          def __init__(self, *args, **kwargs):
              bound_values = self.__signature__.bind(*args, **kwargs)
              for name, value in bound_values.arguments.items():
                  setattr(self, name, value)

      class Stock(Structure):
          __signature__ = make_sig('name', 'shares', 'price')
          def __init__(self, *args, **kwargs):
              super().__init__(*args, **kwargs)
    #+END_SRC

*** Metaclass Approach
    #+BEGIN_SRC python
      from inspect import Signature, Parameter


      def make_sig(*names):
          parms = [
              Parameter(name, Parameter.POSITIONAL_OR_KEYWORD) for name in names
          ]
          return Signature(parms)


      class StructureMeta(type):
          def __new__(cls, clsname, bases, clsdict):
              clsdict['__signature__'] = make_sig(*clsdict.get('_fields', []))
              return super().__new__(cls, clsname, bases, clsdict)


      class Structure(metaclass=StructureMeta):
          fields = []

          def __init__(self, *args, **kwargs):
              bound_values = self.__signature__.bind(*args, **kwargs)
              for name, value in bound_values.arguments.items():
                  setattr(self, name, value)
    #+END_SRC
** Parsing and Analyzing Python Source
   - ~eval('2 + 3*4 + x')~
*** ~exec~
   - ~exec('for i in range(10): print(i)')~
   #+BEGIN_SRC python
     def test1():
         x = 0
         exec('x += 1')
         print(x) # => 0

     def test2():
         x = 0
         loc = locals()
         exec('x += 1')
         x = loc['x']
         print(x) # => 1
   #+END_SRC

*** ~ast~
    compile Python source code into an abstract syntax tree(AST)
    #+BEGIN_SRC python
      import ast
      ex = ast.parse('2 + 3*4 + x', mode='eval')
      ast.dump(ex)
      # "Expression(body=BinOp(left=BinOp(left=Num(n=2), op=Add(), right=BinOp(left=Num(n=3), op=Mult(), right=Num(n=4))), op=Add(), right=Name(id='x', ctx=Load())))"
    #+END_SRC

*** Rewriting AST to Achieve Performance Improvement
    - see 9.24

** ~dis~
   - ~dis.dis~
   - disassembled code: ~some_func.__code__.co_code~

** Simple namedtuple
   #+BEGIN_SRC python
     import operator

     class StructTupleMeta(type):
         def __init__(cls, *args, **kwargs):
             super().__init__(*args, **kwargs)
             for n, name in enumerate(cls._fields):
                 setattr(cls, name, property(operator.itemgetter(n)))
                 # After f = itemgetter(2), the call f(r) returns r[2]

     class StructTuple(tuple, metaclass=StructTupleMeta):
         _fields = []

         def __new__(cls, *args):
             if len(args) != len(cls._fields):
                 raise ValueError('{} arguments required'.format(len(cls._fields)))
             return super().__new__(cls, args)

     class Stock(StructTuple):
         _fields = ['name', 'shares', 'price']

     s = Stock('ACME', 50, 91.1)
   #+END_SRC
** Multimethod 9.20
** Avoiding Repetitive Property
   #+BEGIN_SRC python
     def typed_property(name, expected_type):
         storage_name = '_' + name

         @property
         def prop(self):
             return getattr(self, storage_name)

         @prop.setter
         def prop(self, value):
             if not isinstance(value, expected_type):
                 raise TypeError('{} must be a {}'.format(name, expected_type))
             setattr(self, storage_name, value)
         return prop

     from functools import partial
     String = partial(typed_property, expected_type=str)
     Integer = partial(typed_property, expected_type=int)

     # Example use
     class Person:
         name = String('name')
         age = Integer('age')

         def __init__(self, name, age):
             self.name = name
             self.age = age
   #+END_SRC

** Defining Context Manager the Easy Way
   #+BEGIN_SRC python
     import time
     from contextlib import contextmanager

     @contextmanager
     def timethis(label):
         start = time.time()
         try:
             yield
         finally:
             end = time.time()
             print('{}: {}'.format(label, end - start))

     # Example use
     with timethis('counting'):
         n = 10000000
         while n > 0:
             n -= 1
   #+END_SRC
   - all of the code prior to the yield executes as the ~__enter__()~ method of a context manager. All of the code after the ~yield~ executes as the ~__exit__()~ method
   - If there was an exception, it is *raised* at the ~yield~ statement.

* Metaclass
** Basic
   When writing metaclasses, it is somewhat common to only define a ~__new__()~ or ~__init__()~ method, *but not both*.
   #+BEGIN_SRC python
     class MyMeta(type):
         def __new__(self, clsname, bases, clsdict):
             # self is a class object
             # clsname is name of class being defined
             # bases is tuple of base classes
             # clsdict is class dictionary
             return super().__new__(self, clsname, bases, clsdict)
   #+END_SRC
   or
   #+BEGIN_SRC python
     class MyMeta(type):
         def __init__(cls, clsname, bases, clsdict):
             super().__init__(clsname, bases, clsdict)
   #+END_SRC
   - ~__prepare__~ :: is called first and used to *create the class namespace* prior to the body of any class definition being processed. Normally, this method simply returns a dictionary or other mapping object
   - ~__new__~  :: is invoked prior to class creation and is typically used when a metaclass wants to alter the class definition in some way
   - ~__init__~ :: is invoked after a class has been created, and is useful if you want to write code that works with the fully formed class object.

** NoInstances
   #+BEGIN_SRC python
     class NoInstances(type):
         def __call__(self, *args, **kwargs):
             raise TypeError("Can't instantiate directly")

     # Example
     class Spam(metaclass=NoInstances):
         @staticmethod
         def grok(x):
             print('Spam.grok')
   #+END_SRC

** Singleton
   #+BEGIN_SRC python
     class Singleton(type):
         def __init__(self, *args, **kwargs):
             self.__instance = None
             super().__init__(*args, **kwargs)

         def __call__(self, *args, **kwargs):
             if self.__instance is None:
                 self.__instance = super().__call__(*args, **kwargs)
                 return self.__instance
             else:
                 return self.__instance
   #+END_SRC

** Cached Instances
   #+BEGIN_SRC python
     import weakref

     class Cached(type):
         def __init__(self, *args, **kwargs):
             super().__init__(*args, **kwargs)
             self.__cache = weakref.WeakValueDictionary()

         def __call__(self, *args):
             if args in self.__cache:
                 return self.__cache[args]
             else:
                 obj = super().__call__(*args)
                 self.__cache[args] = obj
                 return obj
   #+END_SRC
** OrderedDict for Class Body
   This method is invoked immediately at the start of a class definition with the class name and base classes. It must then return a mapping object to use when processing the class body.
   #+BEGIN_SRC python
     # Metaclass that uses an OrderedDict for class body
     class OrderedMeta(type):
         def __new__(cls, clsname, bases, clsdict):
             d = dict(clsdict)
             order = []
             for name, value in clsdict.items():
                 if isinstance(value, Typed):
                     value._name = name
                     order.append(name)
             d['_order'] = order
             return type.__new__(cls, clsname, bases, d)

         @classmethod
         def __prepare__(cls, clsname, bases):
             return OrderedDict()
   #+END_SRC

** Optional Arguments on Class Definitions
   #+BEGIN_SRC python
     class Spam(metaclass=MyMeta, debug=True, synchronize=True):
         ...
   #+END_SRC
   To support such keyword arguments in a metaclass, make sure you define them on the
   ~__prepare__()~, ~__new__()~, and ~__init__()~ methods using keyword-only arguments
   #+BEGIN_SRC python
     class MyMeta(type):
         # Optional
         @classmethod
         def __prepare__(cls, name, bases, *, debug=False, synchronize=False):
             # Custom processing
             ...
             return super().__prepare__(name, bases)

         # Required
         def __new__(cls, name, bases, ns, *, debug=False, synchronize=False):
             # Custom processing
             ...
             return super().__new__(cls, name, bases, ns)

         # Required
         def __init__(self, name, bases, ns, *, debug=False, synchronize=False):
             # Custom processing
             ...
             super().__init__(name, bases, ns)
   #+END_SRC

* Packages and Modules
** Lazy Import
   #+BEGIN_SRC python
     # __init__.py
     def A():
         from .a import A
         return A()
   #+END_SRC

** Organize Add-on Packages into a Common Package
   #+BEGIN_SRC python
     # foo-package/
     #   spam/
     #     blah.py
     # bar-package/
     #   spam/
     #     grok.py
     import sys
     sys.path.extend(['foo-package', 'bar-package'])
     import spam.blah
     import spam.grok
   #+END_SRC
** Read Data File
   - ~pkgutil.get_data~

** Import Hooks
   - See =10.11=, =10.12=
* Network
** ~socketserver~
** CIDR network address
   #+BEGIN_SRC python
     import ipaddress
     net = ipaddress.ip_network('123.45.67.64/27')
     list(net)
     net.num_addresses

     inet = ipaddress.ip_interface('123.45.67.73/27')
     inet.network
     inet.ip
   #+END_SRC
** Simple WSGI
   WSGI: Web Server Gateway Interface. Same code for different web framework.
   #+BEGIN_SRC python
     def application(environ, start_response):
         start_response('200 OK', [('Content-Type', 'text/html')])
         return [b'<h1>Hello, web!</h1>']

     from wsgiref.simple_server import make_server
     httpd = make_server('', 8000, application)
     print('Serving HTTP on port 8000...')
     httpd.serve_forever()
   #+END_SRC
   - environ: http request info
   - ~start_response~: a function that must be called to initiate a response
   - return: response body

*** PathDispatcher
    #+BEGIN_SRC python
      import cgi


      def notfound_404(environ, start_response):
          start_response('404 Not Found', [('Content-type', 'text/plain')])
          return [b'Not Found']


      class PathDispatcher:
          def __init__(self):
              self.pathmap = {}

          def __call__(self, environ, start_response):
              path = environ['PATH_INFO']

              # extracts supplied query parameters from the request and puts them into a dictionary-like object
              params = cgi.FieldStorage(environ['wsgi.input'], environ=environ)
              method = environ['REQUEST_METHOD'].lower()
              environ['params'] = {key: params.getvalue(key) for key in params}
              handler = self.pathmap.get((method, path), notfound_404)
              return handler(environ, start_response)

          def register(self, method, path, function):
              self.pathmap[method.lower(), path] = function
              return function


      def hello(environ, start_response):
          start_response('200 OK', [('Content-Type', 'text/html')])
          return [b'<h1>Hello, web!</h1>']


      from wsgiref.simple_server import make_server
      dispatcher = PathDispatcher()
      dispatcher.register('GET', '/hello', hello)
      httpd = make_server('', 8080, dispatcher)
      print('Serving on port 8080...')
      httpd.serve_forever()
    #+END_SRC
** XMLRPC
    #+BEGIN_SRC python
      from xmlrpc.server import SimpleXMLRPCServer

      class KeyValueServer:
          _rpc_methods_ = ['get', 'set']
          def __init__(self, address):
              self._data = {}
              self._serv = SimpleXMLRPCServer(address, allow_none=True)
              for name in self._rpc_methods_:
                  self._serv.register_function(getattr(self, name))

          def get(self, name):
              return self._data[name]

          def set(self, name, value):
              self._data[name] = value

          def serve_forever(self):
              self._serv.serve_forever()

      if __name__ == '__main__':
          kvserv = KeyValueServer(('', 15000))
          kvserv.serve_forever()
    #+END_SRC
    - client
    #+BEGIN_SRC python
      from xmlrpc.client import ServerProxy
      s = ServerProxy('http://localhost:15000', allow_none=True)
      s.set('foo', 'bar')
      s.get('foo')
    #+END_SRC

** Communicating Between Interpreters
   - ~multiprocessing.connection~: support UNIX domain sockets

** Simple Auth
   #+BEGIN_SRC python
     import hmac
     import os

     def client_authenticate(connection, secret_key):
         '''
         Authenticate client to a remote service.
         connection represents a network connection.
         secret_key is a key known only to both client/server.
         '''
         message = connection.recv(32)
         hash = hmac.new(secret_key, message)
         digest = hash.digest()
         connection.send(digest)


     def server_authenticate(connection, secret_key):
         '''
         Request client authentication.
         '''
         message = os.urandom(32)
         connection.send(message)
         hash = hmac.new(secret_key, message)
         digest = hash.digest()
         response = connection.recv(len(digest))
         return hmac.compare_digest(digest, response)
   #+END_SRC

** SSL Wrapper
   #+BEGIN_SRC python
     import ssl
     KEYFILE = 'server_key.pem'  # Private key of the server
     CERTFILE = 'server_cert.pem'  # Server certificate (given to client)
     s_ssl = ssl.wrap_socket(
         s, keyfile=KEYFILE, certfile=CERTFILE, server_side=True)
   #+END_SRC

** select
   #+BEGIN_SRC python
     import select

     def event_loop(handlers):
         while True:
             wants_recv = [h for h in handlers if h.wants_to_receive()]
             wants_send = [h for h in handlers if h.wants_to_send()]
             can_recv, can_send, _ = select.select(wants_recv, wants_send, [])
             for h in can_recv:
                 h.handle_receive()
             for h in can_send:
                 h.handle_send()
   #+END_SRC

** Sending Large Arrays
   #+BEGIN_SRC python
     # zero copy with memoryview
     def send_from(arr, dest):
         view = memoryview(arr).cast('B')
         while len(view):
             nsent = dest.send(view)
             view = view[nsent:]


     def recv_into(arr, source):
         view = memoryview(arr).cast('B')
         while len(view):
             nrecv = source.recv_into(view)
             view = view[nrecv:]
   #+END_SRC
* Concurrency
** Threading
   - ~Thread~ methods: ~start~, ~is_alive~, ~join~, ~terminate~
   - ~Thread~ interface: ~run~

** Synchronization Primitives
*** Event
