#+TITLE: Python Cookbook
#+KEYWORDS: python, cookbook
#+OPTIONS: H:3 toc:3 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SETUPFILE: ../../org-templates/level-1.org
#+STARTUP: inlineimages
* Data Structures and Algorithms
** Unpacking from Iterables
   #+BEGIN_SRC python
     x, *middle, y = [1, 2, 3, 4, 5] # middle can be replaced by placeholder '_'
     # x => 1
     # y => 5

     data = ['ACME', 50, 91.1, (2012, 12, 21)]
     name, shares, price, (year, mon, day) = data
   #+END_SRC

** Keeping the Last N Items
   #+BEGIN_SRC python
     from collections import deque
     d=deque(maxlen=N)
   #+END_SRC

** Finding the Largest N Items
   #+BEGIN_SRC python
     import heapq
     heapq.nlargest(N, items)
     heapq.nsmallest(N, items)
     # heapq.nlargest(N, data, key=lambda function)
   #+END_SRC
   Underneath the covers, they work by first converting the data into a list
   where items are ordered as a heap.
   #+BEGIN_SRC python
     nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
     heapq.heapify(nums) # inplace function
     # nums => [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] heap[0] is the smallest
   #+END_SRC

** PriorityQueue Implemention
   #+BEGIN_SRC python
     import heapq

     class PriorityQueue:
         def __init__(self):
             self._queue = []
             self._index = 0 # use index to properly order items with the same priority level

         def push(self, item, priority):
             heapq.heappush(self._queue, (-priority, self._index, item))
             self._index += 1

         def pop(self):
             return heapq.heappop(self._queue)[-1]
   #+END_SRC

** defaultdict
   #+BEGIN_SRC python
     from collections import defaultdict
     d = defaultdict(list)
     d['a']
     #=> []
   #+END_SRC
   *defaultdict* will automatically create dictionary entries for keys accessed later on, alternative:
   #+BEGIN_SRC python
     d.setdefault('a', []).append(1)
   #+END_SRC
*** alternative
    #+BEGIN_SRC python
      d = {}
      # A regular dictionary
      d.setdefault('a', []).append(1)
    #+END_SRC

** OrderedDict
   An OrderedDict internally maintains a doubly linked list that orders the keys according to insertion order.

** sortedcontainers
   SortedList, SortedDict, SortedSet

** Calculating with Dictionaries
   #+BEGIN_SRC python
     prices = {
         'ACME': 45.23,
         'AAPL': 612.78,
         'IBM': 205.55,
         'HPQ': 37.20,
         'FB': 10.75
     }
     min_price = min(zip(prices.values(), prices.keys())) # zip to ((value, key)) generator

     min(prices, key=lambda k: prices[k]) # Returns 'FB'
     min_value = prices[min(prices, key=lambda k: prices[k])]
   #+END_SRC

** keys-view
   #+BEGIN_SRC python
     a.keys() & b.keys()
     a.keys() - {'z', 'w'} # {'z', 'w'} is a set
   #+END_SRC

** Naming a Slice
   #+BEGIN_SRC python
     a = [1,2,3,4,5]
     b = slice(1,2)

     a[b] #=> [2] slower than a[1]
   #+END_SRC

** Counting
   #+BEGIN_SRC python
     from collections import Counter
     word_counts1 = Counter(words1)
     word_counts2 = Counter(words2)
     word_counts1 + word_counts2
   #+END_SRC

** Sorting a List of Dictionaries
   #+BEGIN_SRC python
     from operator import itemgetter
     rows_by_fname = sorted(rows, key=itemgetter('fname'))
     rows_by_lfname = sorted(rows, key=itemgetter('lname','fname'))

     g = itemgetter(2, 5, 3) # the call g(r) returns (r[2], r[5], r[3])
   #+END_SRC

** Sorting Objects Without Native Comparison
   #+BEGIN_SRC python
     sorted(users, key=lambda u: u.user_id)
     from operator import attrgetter
     sorted(users, key=attrgetter('user_id'))
     by_name = sorted(users, key=attrgetter('last_name', 'first_name'))
   #+END_SRC

** groupby
   Since =groupby()= only examines consecutive items, should sort the groupby key first.
   #+BEGIN_SRC python
     from itertools import groupby
     rows.sort(key=itemgetter('date'))
     for date, items in groupby(rows, key=itemgetter('date')):
         pass
     # alternative if memory is no concern, and faster than sort+groupby
     rows_by_date = defaultdict(list)
     for row in rows:
         rows_by_date[row['date']].append(row)
   #+END_SRC
** compress
   Takes an iterable and an accompanying Boolean selector sequence as input.
   =list(compress(data, mask))=

** namedtuple&namedlist
   optional or missing fields
   #+BEGIN_SRC python
     Stock = namedtuple('Stock', ['name', 'shares', 'price', 'date', 'time'])
     stock_prototype = Stock('', 0, 0.0, None, None)
     def dict_to_stock(s):
         return stock_prototype._replace(**s)
   #+END_SRC

** sum, min,...
   #+BEGIN_SRC python
     s = sum((x * x for x in nums))
     s = sum(x * x for x in nums) # same as above

     # Original: Returns 20
     min_shares = min(s['shares'] for s in portfolio)
     # Alternative: Returns {'name': 'AOL', 'shares': 20}
     min_shares = min(portfolio, key=lambda s: s['shares'])
   #+END_SRC

** ChainMap
   A ChainMap takes multiple mappings and makes them logically appear as one. If there are duplicate keys,
   the values from the first mapping get used.
   #+BEGIN_SRC python
     from collections import ChainMap
     c = ChainMap(a,b)
     # alternative
     c = b
     c.update(a)
   #+END_SRC
   - but ChainMap keep the reference of a&b

*** store scoped values
   A ChainMap is particularly useful when working with scoped values such as variables in
   a programming language (i.e., globals, locals, etc.)
   #+BEGIN_SRC python
     values = ChainMap()
     values['x'] = 1
     values = values.new_child()
     values['x'] = 2
     values['x'] #=> 2
     values = values.parents
     values['x'] #=> 1
   #+END_SRC
* String Manipulation
** modules
   - *fnmatch*: Filename matching with shell patterns.
   - *glob*: Filename globbing utility.

** re
*** find
    - =match()=
    - =findall()=
    - =finditer()=
    - =scaner()=

*** replace
    - =sub=

*** regex
    - named capture group: =r'?P<TOKENNAME>[a-zA-Z]+'=
    - noncapture

*** tokenize
    #+BEGIN_SRC python
      from collections import namedtuple
      Token = namedtuple('Token', ['type', 'value'])


      def generate_tokens(pat, text):
          scanner = pat.scanner(text)
          for m in iter(scanner.match, None):
              yield Token(m.lastgroup, m.group())


      # Example use
      for tok in generate_tokens(master_pat, 'foo = 42'):
          print(tok)

      # Produces output
      # Token(type='NAME', value='foo')
      # Token(type='WS', value=' ')
      # Token(type='EQ', value='=')
      # Token(type='WS', value=' ')
      # Token(type='NUM', value='42')
    #+END_SRC

*** syntax parser
    - PyParsing
    - PLY
    - Recipe: 2.19

** format
*** align
    #+BEGIN_SRC python
      format('right', '>20')
      # '               right'
      format('right', '=>20')
      # '===============right'
    #+END_SRC

*** safesub
    #+BEGIN_SRC python
      class safesub(dict):
          def __missing__(self, key):
              return '{' + key + '}'

      name = 'ABC'
      n = 5
      s = '{name} has {n} messages.'
      s.format_map(safesub(vars()))
      # 'ABC has 5 messages.'
    #+END_SRC
**** frame hack
     #+BEGIN_SRC python
       def sub(text):
           return text.format_map(safesub(sys._getframe(1).f_locals))
     #+END_SRC

*** textwrap
    =textwrap.fill()= reformat text for output.

** join
   - ='abc' + ',' + 'def'=
   - ='abc' ',' 'def'=
   - =','.join(('abc', 'def'))=
   - ='{},{}'.format('abc', 'def')=
   - =print('abc', 'def', sep=',')=

** combining I/O write operation
   #+BEGIN_SRC python
     def combine(source, maxsize):
         parts = []
         size = 0
         for part in source:
             parts.append(part)
             size += len(part)
             if size > maxsize:
                 yield ''.join(parts)
                 parts = []
                 size = 0
         yield ''.join(parts)

     for part in combine(sample(), 32768):
         f.write(part)
   #+END_SRC
** escape
   - =html.escape=
   - =xml.escape=

* Numbers
** Decimal
   #+BEGIN_SRC python
     from decimal import Decimal, localcontext
     a = Decimal('6.32')
     b = Decimal('2.41')

     with localcontext() as ctx:
         ctx.prec = 5
         print(a/b) # 2.6224
   #+END_SRC

** math.f***
   - =math.fsum=
   - =math.fmod=
   - =math.fabs=
