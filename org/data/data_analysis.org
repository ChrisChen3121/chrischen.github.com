f#+TITLE: DataAnalysis For Python
#+KEYWORDS: python, data analysis
#+OPTIONS: H:4 toc:2 num:3 ^:nil
#+LaTeX: t
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* numpy
** ndarray
#+BEGIN_SRC python
  import numpy as np
  py_array = [1, 2, 3, 4, 5]
  np_array = np.array(py_array)
  np_array.shape #=> (5,)
  np_array.dtype #=> dtype('int64')

  py_array = [[1, 2, 3, 4], [5, 6, 7, 8]]
  np_array = np.array(py_array)
  np_array.shape #=> (2, 4)
  np_array.ndim #=> 2

  np.zeros(10)
  #=> array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
  np.ones((2, 3))
  #=> array([[ 1.,  1.,  1.], [ 1.,  1.,  1.]])
  np.empty((2, 3, 2))
  #=>
  # array([[[ 0.,  0.],
  #         [ 0.,  0.],
  #         [ 0.,  0.]],

  #        [[ 0.,  0.],
  #         [ 0.,  0.],
  #         [ 0.,  0.]]])

  np.arange(5)
  #=> array([0, 1, 2, 3, 4])
  np.random.randn(2, 3)

  np_array = np.array([1, 2, 3], dtype=np.int32)
  np_array = np_array.astype(np.float64)
  np_array.dtype #=> dtype('float64')
#+END_SRC
- Creation

  | Function          | Description                                                                                                                                                                   |
  |-------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | array             | Convert input data (list, tuple, array, or other sequence type) to an ndarray either by inferring a dtype or explicitly specifying a dtype. Copies the input data by default. |
  | asarray           | Convert input to ndarray, but do not copy if the input is already an ndarray                                                                                                  |
  | arange            | Like the built-in range but returns an ndarray instead of a list                                                                                                              |
  | ones, ones_like   | Produce an array of all 1’s with the given shape and dtype, ones_like takes another array and produces a ones array of the same shape and dtype.                             |
  | zeros, zeros_like | Like ones and ones_like but producing arrays of 0’s instead                                                                                                                  |
  | empty, empty_like | Create new arrays by allocating new memory, but do not populate with any values like ones and zeros                                                                           |
  | eye, identity     | Create a square N x N identity matrix (1’s on the diagonal and 0’s elsewhere)                                                                                               |

- Supported dtype

  int8, uint8, int16, uint16, int32, uint32, int64, uint64,
  float16, float32, float64, float128
  complex64, complex128, complex256
  bool
  object
  string_
  unicode_

*** Creating
    | Function          | Description                                                                     |
    |-------------------+---------------------------------------------------------------------------------|
    | array             | Convert input data (list, tuple, array, or other sequence type) to an ndarray   |
    | asarray           | Convert input to ndarray, but do not copy if the input is already an ndarray    |
    | arange            | Like the built-in range but returns an ndarray instead of a list.               |
    | ones, ones_like   | Produce an array of all 1’s with the given shape and dtype.                    |
    | zeros, zeros_like | Produce an array of all 0’s with the given shape and dtype.                    |
    | empty, empty_like | Create new arrays by allocating new memory                                      |
    | eye, identity     | Create a square N x N identity matrix (1’s on the diagonal and 0’s elsewhere) |
*** Indexing
    <<numpy indexing>>
**** basic indexing

    #+BEGIN_SRC python
      arr = np.array(range(12)).reshape(3,4)
      # array([[ 0,  1,  2,  3],
      #        [ 4,  5,  6,  7],
      #        [ 8,  9, 10, 11]])

      arr[1:, :3]
      # array([[ 4,  5,  6],
      #        [ 8,  9, 10]])
    #+END_SRC
**** boolean indexing
  #+BEGIN_SRC python
    flags = np.array([1, 2, 3, 2, 2, 1])
    data = np.random.randn(6,2)
    # array([[ 2.11684529,  1.24861544],
    #        [-0.34817586, -0.59905366],
    #        [-0.84976431,  0.11840417],
    #        [ 1.36648373,  1.33416664],
    #        [ 0.37616856, -0.0032112 ],
    #        [-0.7749904 , -0.60457688]])
    flags ==2
    # array([False,  True, False,  True,  True, False], dtype=bool)
    data[flags == 2]
    # array([[-0.34817586, -0.59905366],
    #        [ 1.36648373,  1.33416664],
    #        [ 0.37616856, -0.0032112 ]])
    data[(flags == 3) | (flags == 1), 1:]
    # array([[ 1.24861544],
    #        [ 0.11840417],
    #        [-0.60457688]])
    data[data<0] = 0
    # array([[ 2.11684529,  1.24861544],
    #        [ 0.        ,  0.        ],
    #        [ 0.        ,  0.11840417],
    #        [ 1.36648373,  1.33416664],
    #        [ 0.37616856,  0.        ],
    #        [ 0.        ,  0.        ]])
  #+END_SRC
**** fancy indexing
  #+BEGIN_VERSE
  Fancy indexing is a term adopted by NumPy to describe indexing using *integer arrays* .
  Unlike slicing, =always copies the data into a new array= .
  #+END_VERSE
  #+BEGIN_SRC python
    arr
    # array([[ 0.,  0.,  0.,  0.],
    #        [ 1.,  1.,  1.,  1.],
    #        [ 2.,  2.,  2.,  2.]])
    arr[[2, 1]]
    # array([[ 2.,  2.,  2.,  2.],
    #        [ 1.,  1.,  1.,  1.]])
    arr = np.array(range(12)).reshape(3,4)
    # array([[ 0,  1,  2,  3],
    #        [ 4,  5,  6,  7],
    #        [ 8,  9, 10, 11]])
    arr[[1,2], [2,3]]
    # array([ 6, 11]) # choose location (1, 2) (2, 3)

    arr[[1,2]][:, [2,3]]
    # array([[ 6,  7],
    #        [10, 11]])
    arr[np.ix_([1,2], [2,3])] # same effect
    # array([[ 6,  7],
    #        [10, 11]])
  #+END_SRC
** Conditional Logic
*** any and all
*** numpy.where
    The *numpy.where* function is a vectorized version of the ternary expression x if
    condition else y. *numpy.where* is quicker than list comprehension.
#+BEGIN_SRC python
  xarr = np.array([1,1,1,1,1])
  yarr = np.array([2,2,2,2,2])
  cond = np.array([True, False, True, False, False])
  np.where(cond, xarr, yarr)
  # array([1, 2, 1, 2, 2])
  np.where(cond, 4, 3)
  # array([4, 3, 4, 3, 3])
#+END_SRC

** Transpose
   Simple transposing with =.T= is just a special case of =swapaxes=

** Useful functions
*** Math
    | Method         | Description                                                                                |
    |----------------+--------------------------------------------------------------------------------------------|
    | sum            | Sum of all the elements in the array or along an axis. Zero-length arrays have sum 0       |
    | mean           | Arithmetic mean. Zero-length arrays have NaN mean                                          |
    | std, var       | Standard deviation and variance, respectively, with optional degrees of freedom adjustment |
    | min, max       | Minimum and maximum                                                                        |
    | argmin, argmax | Indices of minimum and maximum elements, respectively                                      |
    | cumsum         | Cumulative sum of elements starting from 0                                                 |
    | cumprod        | Cumulative product of elements starting from 1                                             |
    | abs, fabs      | Use *fabs* as a faster alternative for non-complex-valued data                             |
    | modf           | Return factional and integral parts of array as separate array                             |
    | rint           | Round elements to the nearest integer, preserving the dtype                                |
*** Linear Algebra
    | Function | Description                                                         |
    |----------+---------------------------------------------------------------------|
    | diag     | Return the diagonal (or off-diagonal) elements of a square matrix   |
    | dot      | *Matrix multiplication*                                             |
    | trace    | Compute the sum of the diagonal elements                            |
    | det      | Compute the matrix determinant                                      |
    | eig      | Compute the eigenvalues and eigenvectors of a square matrix         |
    | inv      | Compute the inverse of a square matrix                              |
    | pinv     | Compute the Moore-Penrose pseudo-inverse inverse of a square matrix |
    | qr       | Compute the QR decomposition                                        |
    | svd      | Compute the singular value decomposition (SVD)                      |
    | solve    | Solve the linear system Ax = b for x, where A is a square matrix    |
    | lstsq    | Compute the least-squares solution to y = Xb                        |
*** Random Number Generation
    | Function    | Description                                                                                          |
    |-------------+------------------------------------------------------------------------------------------------------|
    | seed        | Seed the random number generator                                                                     |
    | permutation | Return a random permutation of a sequence, or return a permuted range                                |
    | shuffle     | Randomly permute a sequence in place                                                                 |
    | rand        | Draw samples from a uniform distribution                                                             |
    | randint     | Draw random integers from a given low-to-high range                                                  |
    | randn       | Draw samples from a normal distribution with mean 0 and standard deviation 1 (MATLAB-like interface) |
    | binomial    | Draw samples a binomial distribution                                                                 |
    | normal      | Draw samples from a normal (Gaussian) distribution                                                   |
    | beta        | Draw samples from a beta distribution                                                                |
    | chisquare   | Draw samples from a chi-square distribution                                                          |
    | gamma       | Draw samples from a gamma distribution                                                               |
    | uniform     | Draw samples from a uniform [0, 1) distribution                                                      |
*** Set operations
    | Function          | Description                                                                        |
    |-------------------+------------------------------------------------------------------------------------|
    | unique(x)         | Compute the sorted, unique elements in x                                           |
    | intersect1d(x, y) | Compute the sorted, common elements in x and y                                     |
    | union1d(x, y)     | Compute the sorted union of elements                                               |
    | in1d(x, y)        | Compute a boolean array indicating whether element of x is in y                    |
    | setdiff1d(x, y)   | Set difference, elements in x that are not in y                                    |
    | setxor1d(x, y)    | Set symmetric differences; elements that are in either of the arrays, but not both |
* pandas
** Series
   Series is a fixed-length *ordered dict*
** DataFrame
#+BEGIN_SRC python
  df = pd.DataFrame(np.arange(8).reshape(4,2),
                    columns=['c1', 'c2'], index=['r1', 'r2', 'r3', 'r4'])

  df.ix['r1'] # retrieve row
  # c1    0
  # c2    1
  # Name: r1, dtype: int64

  df.ix[['r1','r2']]
  #     c1  c2
  # r1   0   1
  # r2   2   3

  df.T
  #     r1  r2  r3  r4
  # c1   0   2   4   6
  # c2   1   3   5   7

  del df['c2']

  df.columns
  # Index([u'c1'], dtype='object')
#+END_SRC
** Indexing Options
   - Common use: =obj[val], obj.ix[val], obj.ix[:, val], obj.ix[val1, val2], reindex=
   - Others:

     | Type                  | Notes                                                                      |
     |-----------------------+----------------------------------------------------------------------------|
     | xs                    | Select single row or column as a Series by label                           |
     | icol, irow, iloc, iat | Select single column or row, respectively, as a Series by integer location |
     | get_value, set_value  | Select single value by row and column label                                |
*** difference
    - loc: only work on index
    - iloc: work on position
    - ix: can get data from dataframe without it being in the index
    - at: get scalar values. It's a very fast loc
    - iat: get scalar values. It's a very fast iloc

** Index
   Index objects are immutable, functions as a fixed-size set.
   - main type: =Index, Int64Index, MultiIndex, DatetimeIndex, PeriodIndex=

   | Method       | Description                                                                               |
   |--------------+-------------------------------------------------------------------------------------------|
   | append       | Concatenate with additional Index objects, producing a new Index                          |
   | diff         | Compute set difference as an Index                                                        |
   | intersection | Compute set intersection                                                                  |
   | union        | Compute set union                                                                         |
   | isin         | Compute boolean array indicating whether each value is contained in the passed collection |
   | delete       | Compute new Index with element at index i deleted                                         |
   | drop         | Compute new index by deleting passed values                                               |
   | insert       | Compute new Index by inserting element at index i                                         |
   | is_monotonic | Returns True if each element is greater than or equal to the previous element             |
   | is_unique    | Returns True if the Index has no duplicate values                                         |
   | unique       | Compute the array of unique values in the Index                                           |
** Functionality
*** Reindexing
Example:
#+BEGIN_SRC python
  frame.reindex(columns=['c1', 'c2'])
  frame.reindex(index=['a', 'b', 'c', 'd'], method='ffill', columns=['c1', 'c2'])
  # is similar to frame.ix[['a', 'b', 'c', 'd'], ['c1', 'c2']]
#+END_SRC
reindex args: index, method, fill_value, limit, level, copy
*** Drop
#+BEGIN_SRC python
  frame.drop(['r1', 'r2'])
  frame.drop(['c1', 'c2'], axis=1)
#+END_SRC
*** Selection
See [[numpy indexing]].

*** Arithmetic
    - Basic df1 + df2,
    - use add method to fill na values: df1.add(df2, fill_value=0)

- Operation between Dataframe and Series
#+BEGIN_SRC python
  df = pd.DataFrame(np.arange(6).reshape(3,2),
                    columns=['c1', 'c2'], index=['r1', 'r2', 'r3'])

  #     c1  c2
  # r1   0   1
  # r2   2   3
  # r3   4   5

  s = pd.Series([4,5], index=['c1', 'c2'])

  # c1    4
  # c2    5
  # dtype: int64

  df + s
  #     c1  c2
  # r1   4   6
  # r2   6   8
  # r3   8  10


  s2 = pd.Series([1,2,3], index=['r1', 'r2', 'r3'])
  # r1    1
  # r2    2
  # r3    3
  # dtype: int64

  df.add(s2, axis=0)
  #     c1  c2
  # r1   1   2
  # r2   4   5
  # r3   7   8
#+END_SRC
*** Broadcasting
    #+BEGIN_SRC python
      frame=pd.DataFrame(np.arange(12).reshape((4,3)), columns=list('bde'), index=list('1234'))
      series = frame.ix[0]
      frame - series
      #=>
      #    b  d  e
      # 1  0  0  0
      # 2  3  3  3
      # 3  6  6  6
      # 4  9  9  9

      series2 = pd.Series(range(3), index=list('bef'))
      frame + series2
      #=>
      #      b   d     e   f
      # 1  0.0 NaN   3.0 NaN
      # 2  3.0 NaN   6.0 NaN
      # 3  6.0 NaN   9.0 NaN
      # 4  9.0 NaN  12.0 NaN
    #+END_SRC
*** Apply
    #+BEGIN_SRC python
      f = lambda x: x.max()
      frame.apply(f)
      frame.apply(f, axis=1)
    #+END_SRC
    *apply* can also return a series
    #+BEGIN_SRC python
      def f(x):
          return pd.Series([x.min(), x.max()], index=['min', 'max'])
      frame.apply(f)
      #=>    a   b
      # min xxx xxx
      # max xxx xxx
    #+END_SRC
*** Sort
  #+BEGIN_SRC python
    df.sort_index()

    # by column(s)
    df.sort_index(by='c1')
    df.sort_index(by=['c1', 'c2'])
  #+END_SRC
*** Rank
    args: 'average'(default), 'min', 'max', 'first'
    #+BEGIN_SRC python
      obj = pd.Series([7, -5, 7, 4, 2, 0, 4, 7])
      obj.rank()
      #=>
      # 0    7.0
      # 1    1.0
      # 2    7.0
      # 3    4.5
      # 4    3.0
      # 5    2.0
      # 6    4.5
      # 7    7.0
      obj.rank(method='first')
      #=>
      # 0    6.0
      # 1    1.0
      # 2    7.0
      # 3    4.0
      # 4    3.0
      # 5    2.0
      # 6    5.0
      # 7    8.0
    #+END_SRC

*** Other funtions
- numpy *ufancs* works fine with pandas objects
- applymap(element-wise), map(series element-wise)
- order(for series sorting): s.order()
- isnull, notnull, dropna, fillna
- stack, unstack, swaplevel, sortlevel
- set_index, reset_index
- unique(series based), value_counts(series based), isin(element-wise)
** Statistic methods
   Basic:
   count, describe, min, max, quantile, sum, pct_change, diff, corr, cov, corrwith

*** mean, median, mad, var, std
*** argmin, argmax, idxmin, idxmax

    argmin/argmax: compute index locations (integers) at which minimum or maximum value obtained, respectively

*** cumsum, cummin, cummax, cumprod
*** skew

    Sample skewness (3rd moment) of values

*** kurt

    Sample kurtosis (4th moment) of values

*** diff

    Compute 1st arithmetic difference (useful for time series)

*** corr, cov, corrwith
    #+BEGIN_SRC python
      import pandas_datareader as pdr

      all_data = {}
      for ticker in ['AAPL', 'IBM', 'MSFT', 'GOOG']:
          all_data[ticker] = pdr.get_data_yahoo(ticker, '1/1/2000', '1/1/2010')

      price = pd.DataFrame({tic: data['Adj Close'] for tic, data in all_data.iteritems()})
      returns = price.pct_change()

      returns.MSFT.corr(returns.IBM)
      returns.MSFT.cov(returns.IBM)

      returns.corr()
      returns.corrwith(returns.IBM)
    #+END_SRC

*** args
     | Method | Description                                                                |
     |--------+----------------------------------------------------------------------------|
     | axis   | Axis to reduce over. 0 for DataFrame’s rows and 1 for columns             |
     | skipna | Exclude missing values, True by default                                    |
     | level  | Reduce grouped by level if the axis is hierarchically-indexed (MultiIndex) |

     *skipna* option:
     - True(default): NA values are excluded unless the entire slice (row or column in this case) is NA
     - False: if any value is *NA*, then return *NA*
** Hierarchical Indexing
*** Indexing
    #+BEGIN_SRC example
      data[index_level1]
      data[index_level1 : index_level1]
      data[[index_level1, index_level1]]

      select by inner level:
      data[:, index_level2]
    #+END_SRC
*** stack, unstack
*** swaplevel, sortlevel
** Panel
   Panel can be thought as a 3-dimensional analogue of DataFrame.
   Although hierarchical indexing makes using truly N-dimensional arrays unnecessary in a lot of cases
   #+BEGIN_SRC python
     pdata = pd.Panel({stk: pdr.get_data_yahoo(stk, '1/1/2009', '6/1/2012')
                       for stk in ['AAPL', 'GOOG']})

   #+END_SRC
*** Useful functions
    - ix
      #+BEGIN_SRC python
        pdata.ix[:, '6/1/2012', :]
      #+END_SRC
    - swapaxes
      #+BEGIN_SRC python
        pdata.swapaxes('items', 'minor')['Adj Close']
      #+END_SRC
    - to_frame

      index will be the *[major, minor]* axis, *items* will be the columns
      #+BEGIN_SRC python
        stacked = pdata.to_frame()
      #+END_SRC

    - to_panel
      #+BEGIN_SRC python
        stacked.to_panel()
      #+END_SRC

* plotting
