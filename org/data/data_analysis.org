#+TITLE: DataAnalysis For Python
#+KEYWORDS: python, data analysis
#+OPTIONS: H:4 toc:2 num:3 ^:nil
#+LaTeX: t
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* numpy
** ndarray
#+BEGIN_SRC python
  import numpy as np
  py_array = [1, 2, 3, 4, 5]
  np_array = np.array(py_array)
  np_array.shape #=> (5,)
  np_array.dtype #=> dtype('int64')

  py_array = [[1, 2, 3, 4], [5, 6, 7, 8]]
  np_array = np.array(py_array)
  np_array.shape #=> (2, 4)
  np_array.ndim #=> 2

  np.zeros(10)
  #=> array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])
  np.ones((2, 3))
  #=> array([[ 1.,  1.,  1.], [ 1.,  1.,  1.]])
  np.empty((2, 3, 2))
  #=>
  # array([[[ 0.,  0.],
  #         [ 0.,  0.],
  #         [ 0.,  0.]],

  #        [[ 0.,  0.],
  #         [ 0.,  0.],
  #         [ 0.,  0.]]])

  np.arange(5)
  #=> array([0, 1, 2, 3, 4])
  np.random.randn(2, 3)

  np_array = np.array([1, 2, 3], dtype=np.int32)
  np_array = np_array.astype(np.float64)
  np_array.dtype #=> dtype('float64')
#+END_SRC
- Creation

  | Function          | Description                                                                                                                                                                   |
  |-------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
  | array             | Convert input data (list, tuple, array, or other sequence type) to an ndarray either by inferring a dtype or explicitly specifying a dtype. Copies the input data by default. |
  | asarray           | Convert input to ndarray, but do not copy if the input is already an ndarray                                                                                                  |
  | arange            | Like the built-in range but returns an ndarray instead of a list                                                                                                              |
  | ones, ones_like   | Produce an array of all 1’s with the given shape and dtype, ones_like takes another array and produces a ones array of the same shape and dtype.                             |
  | zeros, zeros_like | Like ones and ones_like but producing arrays of 0’s instead                                                                                                                  |
  | empty, empty_like | Create new arrays by allocating new memory, but do not populate with any values like ones and zeros                                                                           |
  | eye, identity     | Create a square N x N identity matrix (1’s on the diagonal and 0’s elsewhere)                                                                                               |

- Supported dtype

  int8, uint8, int16, uint16, int32, uint32, int64, uint64,
  float16, float32, float64, float128
  complex64, complex128, complex256
  bool
  object
  string_
  unicode_

*** Creating
    | Function          | Description                                                                     |
    |-------------------+---------------------------------------------------------------------------------|
    | array             | Convert input data (list, tuple, array, or other sequence type) to an ndarray   |
    | asarray           | Convert input to ndarray, but do not copy if the input is already an ndarray    |
    | arange            | Like the built-in range but returns an ndarray instead of a list.               |
    | ones, ones_like   | Produce an array of all 1’s with the given shape and dtype.                    |
    | zeros, zeros_like | Produce an array of all 0’s with the given shape and dtype.                    |
    | empty, empty_like | Create new arrays by allocating new memory                                      |
    | eye, identity     | Create a square N x N identity matrix (1’s on the diagonal and 0’s elsewhere) |
*** Indexing
    <<numpy indexing>>
**** basic indexing

    #+BEGIN_SRC python
      arr = np.array(range(12)).reshape(3,4)
      # array([[ 0,  1,  2,  3],
      #        [ 4,  5,  6,  7],
      #        [ 8,  9, 10, 11]])

      arr[1:, :3]
      # array([[ 4,  5,  6],
      #        [ 8,  9, 10]])
    #+END_SRC
**** boolean indexing
  #+BEGIN_SRC python
    flags = np.array([1, 2, 3, 2, 2, 1])
    data = np.random.randn(6,2)
    # array([[ 2.11684529,  1.24861544],
    #        [-0.34817586, -0.59905366],
    #        [-0.84976431,  0.11840417],
    #        [ 1.36648373,  1.33416664],
    #        [ 0.37616856, -0.0032112 ],
    #        [-0.7749904 , -0.60457688]])
    flags ==2
    # array([False,  True, False,  True,  True, False], dtype=bool)
    data[flags == 2]
    # array([[-0.34817586, -0.59905366],
    #        [ 1.36648373,  1.33416664],
    #        [ 0.37616856, -0.0032112 ]])
    data[(flags == 3) | (flags == 1), 1:]
    # array([[ 1.24861544],
    #        [ 0.11840417],
    #        [-0.60457688]])
    data[data<0] = 0
    # array([[ 2.11684529,  1.24861544],
    #        [ 0.        ,  0.        ],
    #        [ 0.        ,  0.11840417],
    #        [ 1.36648373,  1.33416664],
    #        [ 0.37616856,  0.        ],
    #        [ 0.        ,  0.        ]])
  #+END_SRC
**** fancy indexing
  #+BEGIN_VERSE
  Fancy indexing is a term adopted by NumPy to describe indexing using *integer arrays* .
  Unlike slicing, =always copies the data into a new array= .
  #+END_VERSE
  #+BEGIN_SRC python
    arr
    # array([[ 0.,  0.,  0.,  0.],
    #        [ 1.,  1.,  1.,  1.],
    #        [ 2.,  2.,  2.,  2.]])
    arr[[2, 1]]
    # array([[ 2.,  2.,  2.,  2.],
    #        [ 1.,  1.,  1.,  1.]])
    arr = np.array(range(12)).reshape(3,4)
    # array([[ 0,  1,  2,  3],
    #        [ 4,  5,  6,  7],
    #        [ 8,  9, 10, 11]])
    arr[[1,2], [2,3]]
    # array([ 6, 11]) # choose location (1, 2) (2, 3)

    arr[[1,2]][:, [2,3]]
    # array([[ 6,  7],
    #        [10, 11]])
    arr[np.ix_([1,2], [2,3])] # same effect
    # array([[ 6,  7],
    #        [10, 11]])
  #+END_SRC
** Conditional Logic
*** any and all
*** numpy.where
    The *numpy.where* function is a vectorized version of the ternary expression x if
    condition else y. *numpy.where* is quicker than list comprehension.
#+BEGIN_SRC python
  xarr = np.array([1,1,1,1,1])
  yarr = np.array([2,2,2,2,2])
  cond = np.array([True, False, True, False, False])
  np.where(cond, xarr, yarr)
  # array([1, 2, 1, 2, 2])
  np.where(cond, 4, 3)
  # array([4, 3, 4, 3, 3])
#+END_SRC

** Transpose
   Simple transposing with =.T= is just a special case of =swapaxes=

** Useful functions
*** Math
    | Method         | Description                                                                                |
    |----------------+--------------------------------------------------------------------------------------------|
    | sum            | Sum of all the elements in the array or along an axis. Zero-length arrays have sum 0       |
    | mean           | Arithmetic mean. Zero-length arrays have NaN mean                                          |
    | std, var       | Standard deviation and variance, respectively, with optional degrees of freedom adjustment |
    | min, max       | Minimum and maximum                                                                        |
    | argmin, argmax | Indices of minimum and maximum elements, respectively                                      |
    | cumsum         | Cumulative sum of elements starting from 0                                                 |
    | cumprod        | Cumulative product of elements starting from 1                                             |
    | abs, fabs      | Use *fabs* as a faster alternative for non-complex-valued data                             |
    | modf           | Return factional and integral parts of array as separate array                             |
    | rint           | Round elements to the nearest integer, preserving the dtype                                |
*** Linear Algebra
    | Function | Description                                                         |
    |----------+---------------------------------------------------------------------|
    | diag     | Return the diagonal (or off-diagonal) elements of a square matrix   |
    | dot      | *Matrix multiplication*                                             |
    | trace    | Compute the sum of the diagonal elements                            |
    | det      | Compute the matrix determinant                                      |
    | eig      | Compute the eigenvalues and eigenvectors of a square matrix         |
    | inv      | Compute the inverse of a square matrix                              |
    | pinv     | Compute the Moore-Penrose pseudo-inverse inverse of a square matrix |
    | qr       | Compute the QR decomposition                                        |
    | svd      | Compute the singular value decomposition (SVD)                      |
    | solve    | Solve the linear system Ax = b for x, where A is a square matrix    |
    | lstsq    | Compute the least-squares solution to y = Xb                        |
*** Random Number Generation
    | Function    | Description                                                                                          |
    |-------------+------------------------------------------------------------------------------------------------------|
    | seed        | Seed the random number generator                                                                     |
    | permutation | Return a random permutation of a sequence, or return a permuted range                                |
    | shuffle     | Randomly permute a sequence in place                                                                 |
    | rand        | Draw samples from a uniform distribution                                                             |
    | randint     | Draw random integers from a given low-to-high range                                                  |
    | randn       | Draw samples from a normal distribution with mean 0 and standard deviation 1 (MATLAB-like interface) |
    | binomial    | Draw samples a binomial distribution                                                                 |
    | normal      | Draw samples from a normal (Gaussian) distribution                                                   |
    | beta        | Draw samples from a beta distribution                                                                |
    | chisquare   | Draw samples from a chi-square distribution                                                          |
    | gamma       | Draw samples from a gamma distribution                                                               |
    | uniform     | Draw samples from a uniform [0, 1) distribution                                                      |
*** Set operations
    | Function          | Description                                                                        |
    |-------------------+------------------------------------------------------------------------------------|
    | unique(x)         | Compute the sorted, unique elements in x                                           |
    | intersect1d(x, y) | Compute the sorted, common elements in x and y                                     |
    | union1d(x, y)     | Compute the sorted union of elements                                               |
    | in1d(x, y)        | Compute a boolean array indicating whether element of x is in y                    |
    | setdiff1d(x, y)   | Set difference, elements in x that are not in y                                    |
    | setxor1d(x, y)    | Set symmetric differences; elements that are in either of the arrays, but not both |
* pandas
** Series
   Series is a fixed-length *ordered dict*
** DataFrame
#+BEGIN_SRC python
  df = pd.DataFrame(np.arange(8).reshape(4,2),
                    columns=['c1', 'c2'], index=['r1', 'r2', 'r3', 'r4'])

  df.ix['r1'] # retrieve row
  # c1    0
  # c2    1
  # Name: r1, dtype: int64

  df.ix[['r1','r2']]
  #     c1  c2
  # r1   0   1
  # r2   2   3

  df.T
  #     r1  r2  r3  r4
  # c1   0   2   4   6
  # c2   1   3   5   7

  del df['c2']

  df.columns
  # Index([u'c1'], dtype='object')
#+END_SRC
** Index
   Index objects are immutable, main type: Index, Int64Index, MultiIndex, DatetimeIndex, PeriodIndex
   | Method       | Description                                                                               |
   |--------------+-------------------------------------------------------------------------------------------|
   | append       | Concatenate with additional Index objects, producing a new Index                          |
   | diff         | Compute set difference as an Index                                                        |
   | intersection | Compute set intersection                                                                  |
   | union        | Compute set union                                                                         |
   | isin         | Compute boolean array indicating whether each value is contained in the passed collection |
   | delete       | Compute new Index with element at index i deleted                                         |
   | drop         | Compute new index by deleting passed values                                               |
   | insert       | Compute new Index by inserting element at index i                                         |
   | is_monotonic | Returns True if each element is greater than or equal to the previous element             |
   | is_unique    | Returns True if the Index has no duplicate values                                         |
   | unique       | Compute the array of unique values in the Index                                           |
** Functionality
*** Reindexing
Example:
#+BEGIN_SRC python
  frame.reindex(index=['a', 'b', 'c', 'd'], method='ffill', columns=['c1', 'c2'])
  frame.ix[['a', 'b', 'c', 'd'], ['c1', 'c2']]
#+END_SRC
reindex args: index, method, fill_value, limit, level, copy
*** Drop
#+BEGIN_SRC python
  frame.drop(['r1', 'r2'])
  frame.drop(['c1', 'c2'], axis=1)
#+END_SRC
*** Selection
See [[numpy indexing]].

*** Arithmetic
Examples: df1 + df2, df1.add(df2, fill_value=0)

- Operation between Dataframe and Series
#+BEGIN_SRC python
  df = pd.DataFrame(np.arange(6).reshape(3,2),
                    columns=['c1', 'c2'], index=['r1', 'r2', 'r3'])

  #     c1  c2
  # r1   0   1
  # r2   2   3
  # r3   4   5

  s = pd.Series([4,5], index=['c1', 'c2'])

  # c1    4
  # c2    5
  # dtype: int64

  df + s
  #     c1  c2
  # r1   4   6
  # r2   6   8
  # r3   8  10


  s2 = pd.Series([1,2,3], index=['r1', 'r2', 'r3'])
  # r1    1
  # r2    2
  # r3    3
  # dtype: int64

  df.add(s2, axis=0)
  #     c1  c2
  # r1   1   2
  # r2   4   5
  # r3   7   8
#+END_SRC
*** Other funtions
- apply, map, applymap
- sort_index, order
  #+BEGIN_SRC python
    df.sort_index()
    df.sort_index(by='c1')
    df.sort_index(by=['c1', 'c2'])
    s.order()
  #+END_SRC
- rank

  args: 'average'(default), 'min', 'max', 'first'

- statistic methods

  count, describe, min, max, argmin, argmax, idxmin, idxmax,
  quantile, sum, mean, median, mad, var, std, skew, kurt,
  cumsum, cummin, cummax, cumprod, diff, pct_change, corr, cov, corrwith

- unique, value_counts, isin
- isnull, notnull, dropna, fillna

  arg *thresh* keep only rows containing a certain number of observations.

- stack, unstack, swaplevel, sortlevel
- set_index, reset_index
** Panel
   Panel can be thought as a 3-dimensional analogue of DataFrame.
   - swapaxes
   - to_frame, to_panel
* plotting
