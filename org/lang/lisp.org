#+TITLE: Common Lisp
#+KEYWORDS: common Lisp
#+OPTIONS: H:2 toc:2 num:2 ^:nil
#+LANGUAGE: zh-CN
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* 安装
Install Slime, SBCL
- windows 下定义环境变量 SBCL_Home

* 函数
** 参数
   参数四种类型按解析顺序列出：必要形参，optional 形参，rest 形参，keyword 形参。
*** 注意点
    避免&optional 与&key 混合使用，为保持更好的扩展性，应使用&key。
    &rest 与&key 一同使用时，两者都会解析。例如：
#+BEGIN_SRC lisp
  (defun foo (&rest values &key a b)
    (list rest a b)

  (foo :a 1 :b 2) -> ((:A 1 :B 2) 1 2)
#+END_SRC
** 返回值
   使用 RETURN-FROM 从函数中间返回，需传入函数名。
#+BEGIN_SRC lisp
  (return-from foo return-value)
#+END_SRC

** 函数对象
   以下两种形式都返回函数对象
#+BEGIN_SRC lisp
  #'foo
  (function foo)
#+END_SRC
调用函数对象，通过 FUNCALL 和 APPLY
#+BEGIN_SRC lisp
  (foo 1 2 3)
  =
  (funcall #'foo 1 2 3)
#+END_SRC

*** 函数作为参数
- funcall

  #+BEGIN_SRC lisp
    (defun double-v (x) (* 2 x))

    (defun mapp (fn &rest values)
      (list (dolist (x values) (print (funcall fn x)))))

    (mapp #'(lambda (x) (+ x 1)) 1 2 3)
    (mapp (lambda (x) (+ x 1)) 1 2 3)
    (mapp #'double-v 1 2 3)
  #+END_SRC

- apply

  apply 第二个参数接受列表参数
  #+BEGIN_SRC lisp
    (defun foo (fn arg1 arg2 arg3)
      ...)

    (apply #'foo args)
    (apply #'foo #'fn args)
  #+END_SRC
  apply 允许像第二种方式那样，“孤立”头几个参数，
  最后传入一个包含所有剩余参数的列表。

** lambda
*** funcall 调用
#+BEGIN_SRC lisp
  (funcall #'(lambda (x y) (+ x y)) 2 3) -> 5
#+END_SRC

*** lambda 作为函数名调用
#+BEGIN_SRC lisp
  ((lambda (x y) (+ x y)) 2 3) -> 5
#+END_SRC
说明 lambda 表达式用在任何一个正常函数名可以出现的地方，都是合法的。
实际不会如上述例子这么做。
* 变量
** 词法(lexical)变量
*** Let
    形式：(let (variable*) body-form*)
#+BEGIN_SRC lisp
  (let ((x 10) (y 20) z)
    ...)
#+END_SRC

- let 声明的变量，作用域仅是 let 语句内。
- body 中最后一个表达式返回的值，将作为 let 表达式的值返回。
**** let*
     let*允许变量引用变量列表中早先引入的变量
#+BEGIN_SRC lisp
  (let* ((x 1)
         (y (+ x 1)))
    (list x y))
#+END_SRC
等同于嵌套的 let
#+BEGIN_SRC lisp
  (let ((x 1))
    (let ((y (+ x 10)))
      (list x y))
#+END_SRC
*** 闭包
#+BEGIN_SRC lisp
  (let ((count 0) #'(lambda () (setf count (1+ count)))))
#+END_SRC
其中的匿名函数被称为一个闭包

** 动态(dynamic)变量
有时被称为特殊(special)变量。通常用作全局变量。
其特殊是因为其作用域是动态作用域，运行时决定。

每个动态变量都会对应一个全局绑定关系栈，遇到局部重名定义或者新绑定时，
将新的关系压入栈，离开该作用时出栈。

声明有 *defvar* 和 *defparameter* 两种方式。
前者在发现变量已被定义时，不进行赋值。后者总是进行赋值。

*defvar* 还可以不使用初始值。这样的变量称为未绑定的(unbound)。

局部变量也可以声明为动态变量，使用 *declare* ，一般不常用。

- defvar
  #+BEGIN_SRC lisp
    (defvar *count* 0
      "Count of ...")
  #+END_SRC

- defparameter
  #+BEGIN_SRC lisp
    (defparameter *gap* 0.001
      "Gaps of ...")
  #+END_SRC

*** 注意点
将全局对象的改变限定在函数体内，可使用 *let* 对全局对象进行重新绑定。
#+BEGIN_SRC lisp
  (defvar *x* 10)
  (defun foo () (print *x*))
  (defun bar ()
    (let (*x* 20) (foo))
    (foo))

  (bar)
  ->
  20
  10
#+END_SRC
** 常量
形式：(defconstant name initial-value [document-string])
- 可在名字后面加上“+”约定常量

  并没有*全局变量*这么通用。


** SETF
形式：(setf place value)

setf 是一个宏，赋值前先检查 place 的形式，并分析成适当的底层操作来修改那个位置。

当该位置是变量时，展开成一个对特殊操作符 setq 的调用，
setq 可以访问到词法和动态绑定。守旧的 lisp 程序员仍然使用 setq 进行赋值。

多值赋值：
(setf x 1 y 2)

setf 返回最后一个被赋值的值
(setf x (setf y (random 10) z 3))
-> x == z == 3

** 其他常用操作
假设 x=20, y=5, z=15
*** ROTATEF
两两交换
#+BEGIN_SRC lisp
  (rotatef x y z)
  ->
  x=5, y=15, z=20
#+END_SRC

*** SHIFTF
#+BEGIN_SRC lisp
  (shiftf x y z)
  ->
  x=5, y=15, z=15
#+END_SRC
z 之后没有元素了，保持原值。
