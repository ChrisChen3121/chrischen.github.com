#+TITLE: C++ Concurrency
#+KEYWORDS: c++
#+OPTIONS: H:3 toc:2 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* Managing threads
** RAII(Resource Acquisition Is Initialization)
   Use RAII to avoid use of /try/catch/ blocks.
    #+BEGIN_SRC cpp
      class ThreadGuard {
      public:
        explicit ThreadGuard(std::thread &t) : t_(t) {}
        ~ThreadGuard() {
          if (t_.joinable()) {
            t_.join();
          }
        }
        ThreadGuard(const ThreadGuard &) = delete;
        ThreadGuard &operator=(const ThreadGuard &) = delete;

      private:
        std::thread &t_;
      };

      std::thread t(some_func);
      ThreadGuard g(t);
    #+END_SRC

** Daemon Threads
    #+BEGIN_SRC cpp
      std::thread t(do_background_work);
      t.detach();
    #+END_SRC

** Passing Arguments
   The arguments are *copied* into thread's internal storage by default. Use /std::ref/ to bind a reference argument.
   #+BEGIN_SRC cpp
     std::thread t(update_ref_data, std::ref(data)); // use std::move for move scenario
   #+END_SRC

** Transferring Ownership of a Thread
   Instances of std::thread are *movable*, but aren't *copyable*
   #+BEGIN_SRC cpp
     class ScopedThread {
     public:
       explicit ScopedThread(std::thread t) : t_(std::move(t)) {
         if (!t_.joinable())
           throw std::logic_error("No thread");
       }
       ~ScopedThread() { t_.join(); }
       ScopedThread(const ScopedThread &) = delete;
       ScopedThread &operator=(const ScopedThread &) = delete;

     private:
       std::thread t_;
     };

     ScopedThread t(std::thread(some_func));
   #+END_SRC

** hardware_concurrency
   #+BEGIN_SRC cpp
     std::cout << std::thread::hardware_concurrency() << "\n";
   #+END_SRC
* Sharing data
** Avoiding Deadlock
*** std::lock
    A function that can lock two or more mutexes at once without risk of deadlock
    #+BEGIN_SRC cpp
      std::lock(mu1, mu2);
      std::lock_guard<std::mutex> lock_a(mu1, std::adopt_lock);
      std::lock_guard<std::mutex> lock_b(mu2, std::adopt_lock);
    #+END_SRC
** Lazy Initialization
*** std::once_flag & std::call_once
     #+BEGIN_SRC cpp
       std::shared_ptr<some_resource> resource_ptr;

       void init_resource() {
         resource_ptr.reset(new some_resource);
       }

       void foo() {
         static std::once_flag resource_flag;
         std::call_once(resource_flag, init_resource());
         resource_ptr->do_something();
       }
     #+END_SRC
*** static(C++11)
    #+BEGIN_SRC cpp
      SomeClass &get_instance() {
        static SomeClass instance;
        return instance;
      }
    #+END_SRC

** Reader-writer Mutex
   - boost::shared_mutex
   - readers: shared_lock
   - writers: unique_lock

** More Approach
*** software transactional memory(STM)
    like transaction in database, this is an active research area.

* Synchronizing Concurrent Operations
** Condition Variables
   #+BEGIN_SRC cpp
     std::mutex mu;
     std::queue<data_chunk> data_queue;
     std::condition_variable data_cond;

     void prepare_data_thread() {
       while (more_data_to_prepare()) {
         data_chunk const data = prepare_data();
         std::lock_guard<std::mutex> lk(mu);
         data_queue.push(data);
         data_cond.notify_one();
       }
     }

     void data_processing_thread() {
       while (true) {
         std::unique_lock<std::mutex> lk(mu);
         data_cond.wait(lk, [] { return !data_queue.empty(); });
         data_chunk data=data_queue.front();
         data_queue.pop();
         lk.unlock();
         process(data);
         if (is_last_chunk(data))
           break;
       }
     }
   #+END_SRC
*** Thread-safe Queue
    #+BEGIN_SRC cpp
      template <typename T> class threadsafe_queue {
      public:
        threadsafe_queue() {}
        threadsafe_queue(const threadsafe_queue &other) {
          std::lock_guard<std::mutex> lk(other.mu_);
          data_queue_ = other.data_queue_;
        }

        bool empty() const {
          std::lock_guard<std::mutex> lk(mu_);
          return data_queue_.empty();
        }

        void push(T new_value) {
          std::lock_guard<std::mutex> lk(mu_);
          data_queue_.push(new_value);
          data_cond_.notify_one();
        }
        void wait_and_pop(T &value) {
          std::unique_lock<std::mutex> lk(mu_);
          data_cond_.wait(lk, [this] { !data_queue_.empty(); });
          value = data_queue.front();
          data_queue.pop();
        }

      private:
        mutable std::mutex mu_; // const member func like empty can lock mu_
        std::queue<T> data_queue_;
        std::condition_variable data_cond_;
      };
    #+END_SRC
* Useful tools
  - std::ref
  - std::distance(iter1, iter2)
  - std::advance(iter, distance)
** std::mem_fn
   useful for std algorithms
   #+BEGIN_SRC cpp
     class SomeClass {
       void some_func() {}
     };

     auto some_func = std::mem_fn(&SomeClass::some_func);
     SomeClass s;
     some_func(s);
     std::some_algo(iter1, iter2, some_func);
   #+END_SRC
