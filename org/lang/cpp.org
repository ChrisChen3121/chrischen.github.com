f#+TITLE: C++ 点滴
#+KEYWORDS: c++
#+OPTIONS: H:2 toc:2 num:2 ^:nil
#+LANGUAGE: zh-CN
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* 对象初始化
  - 总是使用花括号进行初始化{}，原因：当隐式转换精度变小时编译器将会报错。
  #+BEGIN_SRC cpp
  double pi = 3.1415926536;
  int a(pi), b = pi; //丢失精度
  // int c{pi}, d = {pi}; //编译报错：good!
  #+END_SRC
* 指针和引用
** 常量指针和引用
   - 指向常量的指针没有规定其所指对象必须是一个常量(该值仍可以通过其他方式改变)。引用也一样。

** const 指针
   #+BEGIN_SRC cpp
    int val = 0;
    int val2 = 1;
    int *const pi = &val; //指向整形的常量指针 top-level const
    pi = &val2; // error: assignment of read-only variable ‘pi’

    const int *pci = &val; //指向常量整形的指针 low-level const
    ,*pci = 2; // error: assignment of read-only location ‘* pci’
   #+END_SRC

* 类型
*** 类型别名
    以下两个语句等价：
    #+BEGIN_SRC cpp
      typedef double wages;
      using wages = double;
    #+END_SRC
    尽量使用 using，支持带模板的类型别名

*** 类型推断
    #+BEGIN_SRC cpp
      int i = 0;
      decltype(i) a = 3;
      decltype((i)) b = 5; //错误：b 为 int &
      decltype((i)) c = i; //正确
    #+END_SRC
**** 模板
     #+BEGIN_SRC cpp
       int x = 42;
       const int cx = x;
       const int &rx = x;
     #+END_SRC
     - case 1: reference or pointer
       #+BEGIN_SRC cpp
         template<typename T>
         void f(T& param);

         f(x); // T -> int
         f(cx); // T -> const int
         f(rx); // T -> const int &
       #+END_SRC
     - case 2: universal reference
       #+BEGIN_SRC cpp
         template<typename T>
         void f(T &&param);

         f(x); // x is lvalue, T -> int &
         f(cx); // T -> const int &
         f(rx); // T -> const int &
         f(42); // x is rvalue, T -> int &&
       #+END_SRC
     - case 3: neither reference nor pointer
       #+BEGIN_SRC cpp
         template<typename T>
         void f(T param);

         f(x); // T -> int
         f(cx); // T -> int
         f(rx); // T -> int
       #+END_SRC
     - case 4: array or function

       默认推断为指针，除非指定模板参数为引用

**** auto
     #+BEGIN_SRC cpp
       auto x = 42; // case3
       const auto cx = x; // case3
       const auto &cx = x; // case1
       auto &&uref1 = x; // case2: uref1 -> int &
       auto &&uref2 = cx; // case2: uref2 -> const int &
       auto &&uref3 = 42; // case2: uref3 -> int &&

       const char name[] = "beep";
       auto arr1 = name; // arr1 -> const char *
       auto &arr2 = name; // arr2 -> const char (&)[]

       void somefn(int);
       auto func1 = somefn; // func1 -> void (*)(int)
       auto &func2 = somefn; // func2 -> void (&)(int)

       auto x = {27}; // notice: x -> std::initializer_list<int>
     #+END_SRC
     - *auto* 与模板类型推断唯一的不同在于 auto 会将{}包围的初始化列表，推断为 *std::initializer_list*
     - C++14 允许函数返回值使用 *auto* ，但这里 *auto* 的行为方式与模板类型推断一致；C++14 lambda 中的 *auto* 参数也是如此
**** decltype
     - *decltype* 通常不做任何修改的返回变量或表达式的类型，非常直观
     - 对容器中的下标操作 *operator[]* 使用 *decltype* 则返回 *T&*
     - *decltype* 常用于模板函数，通过函数的参数推断函数的返回值类型，并置于函数签名结尾
       #+BEGIN_SRC cpp
         template<typename Container, typename Index>
         auto Access(Container &c, Index i)
             -> decltype(c[i]) {
           return c[i];
         }
       #+END_SRC
       这里的 *auto* 没有任何推断作用，只是用于标识尾部的 *decltype* 。C++14 语法允许去掉尾部的 *decltype* ，
       但是由于使用的是模板推断，原本的引用类型 *T&* 被推断为 *T* 。
       #+BEGIN_SRC cpp
         template<typename Container, typename Index>
         auto Access(Container &c, Index i) {
           return c[i];
         }

         std::vector<int> vec;
         ...
         Access(vec, 5) = 10; // Wrong，实际返回值为 int，且是一个 rvalue
       #+END_SRC
     - *decltype(auto)* ? *auto* 说明类型需要被推断， *decltype* 说明推断的时候应使用 *decltype* 的规则；C++14 only.
       #+BEGIN_SRC cpp
         int i = 42;
         const int &ci = i;
         auto a1 = ci; // a1 -> int
         decltype(auto) a2 = ci; // a2 -> const int &
       #+END_SRC

     - *std::forward* final version:
       #+BEGIN_SRC cpp
         template<typename Container, typename Index>
         decltype(auto) Access(Container &c, Index i) {
           return std::forward<Container>(c)[i];
         } // for C++14

         template<typename Container, typename Index>
         auto Access(Container &c, Index i)
             -> decltype(std::forward<Container>(c)[i])
         {
           return std::forward<Container>(c)[i];
         } // for C++11
       #+END_SRC


**** Diagnositcs(Boost.TypeIndex)
     #+BEGIN_SRC cpp
       #include <boost/type_index.hpp>
       using boost::typeindex::type_id_with_cvr;
       type_id_with_cvr<T>().pretty_name();
     #+END_SRC

* 容器
** 数组
   - 声明
     #+BEGIN_SRC cpp
       int *ptrs[10]; //指针数组，指针都指向一个 int 对象
       int &refs[10]; //语法错误：不存在引用的数组
       int (*pArray)[10]; //指向一个 int 数组
       int (&rArray)[10]; //引用一个 int 数组
     #+END_SRC
   - 使用数组初始化 vector
     #+BEGIN_SRC cpp
       int array[] = {1,5,3,6,9};
       std::vector<int> vec(std::begin(array), std::end(array));
     #+END_SRC
   - 多维数组
     #+BEGIN_SRC cpp
       int array[2][3]={2,5,7,5,3,1};
       for (auto &row: array)
         for (auto col: row)
             std::cout << col << std::endl;
     #+END_SRC
     #+BEGIN_VERSE
     2 行 3 列数组，使用 for range 时，外层循环要用引用
     #+END_VERSE

** iterator
   - C++11 引入 cbegin 和 cend，调用他们返回一个 const_iterator，支持只读访问。
   - C++11 引入全局函数 begin 和 end，定义在 iterator 头文件中。
     #+BEGIN_SRC cpp
       int test[] = {1,5,6,8,3,4};
       for (auto it = std::begin(test);
            it != std::end(test); it++) {
         std::cout << *it << std::endl;
       }
     #+END_SRC
   - 迭代器循环体内不能执行改变迭代器容量的操作，如执行会使迭代器失效。

** C 风格字符串
   常用方法 strlen, strcmp, strcat, strcpy
   - c_str

     string 对象成员方法，返回 const char*，指向其内部的内容。
     #+BEGIN_SRC cpp
       std::string s("hello world!");
       auto c = s.c_str();
       s = "hello"; // cout << c print 'hello'
     #+END_SRC
