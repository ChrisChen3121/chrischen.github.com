#+TITLE: C++ 点滴
#+KEYWORDS: c++
#+OPTIONS: H:2 toc:2 num:2 ^:nil
#+LANGUAGE: zh-CN
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* 对象初始化
  - 总是使用花括号进行初始化{}，原因：当隐式转换精度变小时编译器将会报错。
  #+BEGIN_SRC cpp
  double pi = 3.1415926536;
  int a(pi), b = pi; //丢失精度
  // int c{pi}, d = {pi}; //编译报错：good!
  #+END_SRC
* 指针和引用
** 常量指针和引用
   - 指向常量的指针没有规定其所指对象必须是一个常量(该值仍可以通过其他方式改变)。引用也一样。

** const 指针
   #+BEGIN_SRC cpp
    int val = 0;
    int val2 = 1;
    int *const pi = &val; //指向整形的常量指针 top-level const
    pi = &val2; // error: assignment of read-only variable ‘pi’

    const int *pci = &val; //指向常量整形的指针 low-level const
    ,*pci = 2; // error: assignment of read-only location ‘* pci’
   #+END_SRC

* 类型
*** 类型别名
    以下两个语句等价：
    #+BEGIN_SRC cpp
      typedef double wages;
      using wages = double;
    #+END_SRC

*** 类型推断
    - auto vs decltype 区别：

    auto 会忽略掉 top-level const，decltype 则保留。
    使用 decltype 时，给变量名加上括号会把它变为表达式。
    变量是一种可以作为赋值左值的特殊表达式，decltype 会得到引用类型
    #+BEGIN_SRC cpp
      int i = 0;
      decltype(i) a = 3;
      decltype((i)) b = 5; //错误：b 为 int &
      decltype((i)) c = i; //正确
    #+END_SRC

* 容器
** 数组
   - 声明
     #+BEGIN_SRC cpp
       int *ptrs[10]; //指针数组，指针都指向一个 int 对象
       int &refs[10]; //语法错误：不存在引用的数组
       int (*pArray)[10]; //指向一个 int 数组
       int (&rArray)[10]; //引用一个 int 数组
     #+END_SRC
   - 使用数组初始化 vector
     #+BEGIN_SRC cpp
       int array[] = {1,5,3,6,9};
       std::vector<int> vec(std::begin(array), std::end(array));
     #+END_SRC
   - 多维数组
     #+BEGIN_SRC cpp
       int array[2][3]={2,5,7,5,3,1};
       for (auto &row: array)
         for (auto col: row)
             std::cout << col << std::endl;
     #+END_SRC
     #+BEGIN_VERSE
     2 行 3 列数组，使用 for range 时，外层循环要用引用
     #+END_VERSE

** iterator
   - C++11 引入 cbegin 和 cend，调用他们返回一个 const_iterator，支持只读访问。
   - C++11 引入全局函数 begin 和 end，定义在 iterator 头文件中。
     #+BEGIN_SRC cpp
       int test[] = {1,5,6,8,3,4};
       for (auto it = std::begin(test);
            it != std::end(test); it++) {
         std::cout << *it << std::endl;
       }
     #+END_SRC
   - 迭代器循环体内不能执行改变迭代器容量的操作，如执行会使迭代器失效。

** C 风格字符串
   常用方法 strlen, strcmp, strcat, strcpy
   - c_str

     string 对象成员方法，返回 const char*，指向其内部的内容。
     #+BEGIN_SRC cpp
       std::string s("hello world!");
       auto c = s.c_str();
       s = "hello"; // cout << c print 'hello'
     #+END_SRC
