#+TITLE: C++ 点滴
#+KEYWORDS: c++
#+OPTIONS: H:3 toc:2 num:3 ^:nil
#+LANGUAGE: zh-CN
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* 对象初始化
  - 总是使用花括号进行初始化{}，原因：当隐式转换精度变小时编译器将会报错。
  #+BEGIN_SRC cpp
  double pi = 3.1415926536;
  int a(pi), b = pi; //丢失精度
  // int c{pi}, d = {pi}; //编译报错：good!
  #+END_SRC
* 指针和引用
** 常量指针和引用
   - 指向常量的指针没有规定其所指对象必须是一个常量(该值仍可以通过其他方式改变)。引用也一样。

** const 指针
   #+BEGIN_SRC cpp
    int val = 0;
    int val2 = 1;
    int *const pi = &val; //指向整形的常量指针 top-level const
    pi = &val2; // error: assignment of read-only variable ‘pi’

    const int *pci = &val; //指向常量整形的指针 low-level const
    *pci = 2; // error: assignment of read-only location ‘* pci’
   #+END_SRC

* 表达式
** 输入输出求值顺序
   #+BEGIN_SRC cpp
     int i{0};
     std::cout << i << " " << ++i << "\n"; //未定义
   #+END_SRC
** 递增递减运算符
   除非必须，否则不使用后置版本。后置版本需要存储原始值用于返回未修改的内容。
*** 与解引用混用
    #+BEGIN_SRC cpp
      std::cout << *iter << "\n";
      ++iter;
      //等价于
      std::cout << *iter++ << "\n"; //先递增后解引用，常规简洁写法，记住。
    #+END_SRC
** sizeof 运算符
   sizeof 运算符返回一条表达式或一个类型名字所占的字节数
   #+BEGIN_SRC cpp
     sizeof(type)
     sizeof expr
   #+END_SRC
   - sizeof 并不实际计算其运算对象的值，编译期即可
   - 对 string 或 vector 对象使用，仅返回该类型固定部分的大小
* 函数
** 局部静态变量
   在程序第一次经过对象定义语句时初始化，直到程序结束才销毁。
   #+BEGIN_SRC cpp
     auto f() {
       static auto cst = 0; // 仅执行一次
       return ++cst;
     }
   #+END_SRC
** 数组形参
   #+BEGIN_SRC cpp
     void f(const int *);
     void f(const int[]); //函数意图显而意见
     void f(const int[10]); //10 并不起作用，应通过额外的参数传数组长度
     void f(int (&arr)[10]); //数组引用形参
   #+END_SRC
** 可变参数形参
*** initializer_list
    同类型多参数
    #+BEGIN_SRC cpp
      void f(initializer_list<int> args);
      f({1, 2, 3});
    #+END_SRC
*** 可变参数模板
    #+BEGIN_SRC cpp
      template<typename... Args>
      void f(const Args& ... rest);
    #+END_SRC
** 列表初始化返回值
   #+BEGIN_SRC cpp
     vector<string> process() {
       return {"a", "b", "cd"};
     }
   #+END_SRC
** 尾置返回类型
   #+BEGIN_SRC cpp
     auto f(int i) -> int(*)[10];//返回指针，指向含有 10 个整数的数组
   #+END_SRC

** constexpr 函数
   能用于常量表达式的函数
   - 函数的返回值及所有形参类型必须是字面值类型
   - 函数体有且只有一条 return 语句
   #+BEGIN_SRC cpp
     constexpr int num() { return 42; }
   #+END_SRC
   - 编译时直接用结果值 42 替换对 num 的函数调用
* 类型
** 类型别名
   以下两个语句等价：
   #+BEGIN_SRC cpp
     typedef double wages;
     using wages = double;
   #+END_SRC
   尽量使用 using，支持带模板的类型别名

** 类型推断
   #+BEGIN_SRC cpp
     int i = 0;
     decltype(i) a = 3;
     decltype((i)) b = 5; //错误：b 为 int &
     decltype((i)) c = i; //正确
   #+END_SRC
*** 模板
    #+BEGIN_SRC cpp
      int x = 42;
      const int cx = x;
      const int &rx = x;
    #+END_SRC
    - case 1: reference or pointer
      #+BEGIN_SRC cpp
        template<typename T>
        void f(T &param);

        f(x); // T -> int
        f(cx); // T -> const int
        f(rx); // T -> const int &
      #+END_SRC
    - case 2: universal reference
      #+BEGIN_SRC cpp
        template<typename T>
        void f(T &&param);

        f(x); // x is lvalue, T -> int &
        f(cx); // T -> const int &
        f(rx); // T -> const int &
        f(42); // x is rvalue, T -> int &&
      #+END_SRC
    - case 3: neither reference nor pointer
      #+BEGIN_SRC cpp
        template<typename T>
        void f(T param);

        f(x); // T -> int
        f(cx); // T -> int
        f(rx); // T -> int
      #+END_SRC
    - case 4: array or function

      默认推断为指针，除非指定模板参数为引用

*** auto
    #+BEGIN_SRC cpp
      auto x = 42; // case3
      const auto cx = x; // case3
      const auto &cx = x; // case1
      auto &&uref1 = x; // case2: uref1 -> int &
      auto &&uref2 = cx; // case2: uref2 -> const int &
      auto &&uref3 = 42; // case2: uref3 -> int &&

      const char name[] = "beep";
      auto arr1 = name; // arr1 -> const char *
      auto &arr2 = name; // arr2 -> const char (&)[]

      void somefn(int);
      auto func1 = somefn; // func1 -> void (*)(int)
      auto &func2 = somefn; // func2 -> void (&)(int)

      auto x = {27}; // notice: x -> std::initializer_list<int>
    #+END_SRC
    - *auto* 与模板类型推断唯一的不同在于 auto 会将{}包围的初始化列表，推断为 *std::initializer_list*
    - C++14 允许函数返回值使用 *auto* ，但这里 *auto* 的行为方式与模板类型推断一致；C++14 lambda 中的 *auto* 参数也是如此
    - 使用 initializer idiom 来初始化具体类型
      #+BEGIN_SRC cpp
        auto pos_flag = static_cast<bool>(x)
      #+END_SRC
*** decltype
    - *decltype* 通常不做任何修改的返回变量或表达式的类型，非常直观
    - 对容器中的下标操作 *operator[]* 使用 *decltype* 则返回 *T&*
    - *decltype* 常用于模板函数，通过函数的参数推断函数的返回值类型，并置于函数签名结尾
      #+BEGIN_SRC cpp
        template<typename Container, typename Index>
        auto Access(Container &c, Index i)
            -> decltype(c[i]) {
          return c[i];
        }
      #+END_SRC
      这里的 *auto* 没有任何推断作用，只是用于标识尾部的 *decltype* 。C++14 语法允许去掉尾部的 *decltype* ，
      但是由于使用的是模板推断，原本的引用类型 *T&* 被推断为 *T* 。
      #+BEGIN_SRC cpp
        template<typename Container, typename Index>
        auto Access(Container &c, Index i) {
          return c[i];
        }

        std::vector<int> vec;
        ...
        Access(vec, 5) = 10; // Wrong，实际返回值为 int，且是一个 rvalue
      #+END_SRC
    - *decltype(auto)* ? *auto* 说明类型需要被推断， *decltype* 说明推断的时候应使用 *decltype* 的规则；C++14 only.
      #+BEGIN_SRC cpp
        int i = 42;
        const int &ci = i;
        auto a1 = ci; // a1 -> int
        decltype(auto) a2 = ci; // a2 -> const int &
        decltype((i)) a3 = i; // a3 -> int & 因为(i)为表达式且求值结果为左值，decltype 返回引用
        int *pi = 42;
        decltype(*pi) a4 = i; // a4 -> int & 同 a3，*pi 为表达式
      #+END_SRC

    - *std::forward* final version:
      #+BEGIN_SRC cpp
        template<typename Container, typename Index>
        decltype(auto) Access(Container &c, Index i) {
          return std::forward<Container>(c)[i];
        } // for C++14

        template<typename Container, typename Index>
        auto Access(Container &c, Index i)
            -> decltype(std::forward<Container>(c)[i])
        {
          return std::forward<Container>(c)[i];
        } // for C++11
      #+END_SRC

*** Diagnositcs(Boost.TypeIndex)
    #+BEGIN_SRC cpp
      #include <boost/type_index.hpp>
      using boost::typeindex::type_id_with_cvr;
      type_id_with_cvr<T>().pretty_name();
    #+END_SRC

** 类型转换
*** 隐式转换
    #+BEGIN_SRC cpp
      int i = 5;
      double d = 3.14;
      int ival = d + i;
    #+END_SRC
    1. i: int -> double
    2. d + i -> 8.14
    3. 8.14 -> int
*** 显式转换
**** static_cast
     #+BEGIN_SRC cpp
       auto d = static_cast<double>(i);
       void *p;
       auto pd = static_cast<double*>(p);
     #+END_SRC
**** dynamic_cast
     多态指针转换
**** const_cast
     去掉 const
     #+BEGIN_SRC cpp
       const char *pc;
       char *p = const_cast<char *>(pc)
     #+END_SRC
     常常用于函数重载的情况
**** reinterpret_cast
     用来处理无关类型之间的转换，字面意思“重新解释（类型的比特位）”，避免使用。
* 容器
** 数组
   - 声明
     #+BEGIN_SRC cpp
       int *ptrs[10]; //指针数组，指针都指向一个 int 对象
       int &refs[10]; //语法错误：不存在引用的数组
       int (*pArray)[10]; //指向一个 int 数组
       int (&rArray)[10]; //引用一个 int 数组

       using int_array = int[10];
       int_array *pArray; //指向一个 int 数组，更简洁
     #+END_SRC
   - 使用数组初始化 vector
     #+BEGIN_SRC cpp
       int array[] = {1,5,3,6,9};
       std::vector<int> vec(std::begin(array), std::end(array));
     #+END_SRC
   - 多维数组
     #+BEGIN_SRC cpp
       int array[2][3] = {2,5,7,5,3,1};
       for (auto &row: array)
         for (auto col: row)
             std::cout << col << std::endl;
     #+END_SRC
     - 2 行 3 列数组，使用 for range 时，外层循环要用引用，为了避免数组被自动转成指针

** iterator
   - C++11 引入 cbegin 和 cend，调用他们返回一个 const_iterator，支持只读访问。
   - C++11 引入全局函数 begin 和 end，定义在 iterator 头文件中。
     #+BEGIN_SRC cpp
       int test[] = {1,5,6,8,3,4};
       for (auto it = std::begin(test);
            it != std::end(test); it++) {
         std::cout << *it << std::endl;
       }
     #+END_SRC
   - 迭代器循环体内不能执行改变迭代器容量的操作，如执行会使迭代器失效。

** C 风格字符串
   常用方法 strlen, strcmp, strcat, strcpy
   - c_str

     string 对象成员方法，返回 const char*，指向其内部的内容。
     #+BEGIN_SRC cpp
       std::string s("hello world!");
       auto c = s.c_str();
       s = "hello"; // cout << c print 'hello'
     #+END_SRC
* 移动语义
** std::move & std::forward
   - *std::move* 实际只做右值转换，不做任何 move 的事情
   - *std::forward* 当参数是通过右值初始化时， *std::forward* 将其转化成右值
     #+BEGIN_SRC cpp
       template<typename T>
       void process(const int &n);
       void process(int &&n);

       void forward_test(T &&param) {
         process(std::forward<T>(param));
       }

       int a = 0;
       forward_test(a); //lvalue->process
       forward_test(std::move(a)); // rvalue->process, n in process initialized by rvalue
     #+END_SRC
** universal reference
   当"T&&"引用遇上类型推断时，则为 universal 引用；其余时候为右值引用
   #+BEGIN_SRC cpp
     template<typename T>
     void f(T &&param); // param is universal reference

     int &&var1 = 1;
     auto &&var2 = var1; // var2 is universal reference
   #+END_SRC
* lambda
** C++14 lambda hints
   #+BEGIN_SRC cpp
     auto func = [data = std::move(data)] {...}; // C++14 init capture
     auto func = [](auto &&x) { return normalize(std::forward<decltype(x)>x); }; // C++14 forward lambda
   #+END_SRC
* 辅助调试
  - NDEBUG 宏
  - assert 宏
** 辅助变量
   #+BEGIN_EXAMPLE
   __func__, __FILE__, __LINE__, __TIME__, __DATE__
   #+END_EXAMPLE
