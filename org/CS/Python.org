#+TITLE: Python参考手册
#+KEYWORDS: python
#+OPTIONS: H:2 toc:2 num:3 ^:nil
#+SETUPFILE: ../configOrg/level1.org
* 入门知识
** 关于整除
3.0以后 "//"为整数除法运算符
#+begin_src python
  eg: 
  #3.0以前的情况
  1.0/2.0 = 0.5    1//2 = 0   1/2 =0
  #3.0以后
  1/2 = 0.5    1//2 = 0
#+end_src
** 幂运算注意
#+begin_src python
  (-3) ** 2
  #=>9
#+end_src
** 常用运算函数
| 函数名 | 说明                     |
|--------+----------------------------|
| pow    | 幂运算                     |
| abs    | 取绝对值                   |
| round  | 浮点数四舍五入取整         |
| sqrt   | 求根运算                   |
| *str*  | 将值转换成格式合理的字符串 |
** 导入模块
*** import 模块名 as 别名
#+begin_src python
  import math
  math.floor(32.9)
  #=>32.0
#+end_src
*** from 模块名 import 函数名 as 函数别名
调用时可省略模块名
#+begin_src python
  from math import sqrt
  sqrt(9)
  #=> 3.0
#+end_src
** 垃圾回收机制
#+begin_src python
  x=1#1所在内存块引用计数升为1
  y=x#引用计数升为2
  x=None#引用计数降为1
  y
  #y => 1
  y=None#引用计数降为0
  #引用计数为0的内存块，python垃圾回收器会去处理它
#+end_src
#+BEGIN_VERSE
也可以显式的del y，将彻底删除y引用，x的值不受影响。
y=None实际上是指向空，但是y引用仍然存在。
#+END_VERSE
* 数据结构
** 序列
*** 序列包括列表、字符串 、元组
*** 基本操作
#+begin_src python
  numbers = [1,2,3,4,5,6,7,8,9,10] #声明
  
  numbers[3:6] #Slice 分片操作
  #=> [4,5,6] 第二个索引号的元素不包含
  
  numbers[-3:]
  #=> [8,9,10]
  
  numbers[0:10:2]
   #=> [1,3,5,7,9]
  
  numbers[10:0:-2]
  #=> [10,8,6,4,2]
  
  [1,2,3] + [4,5,6]
  #=> [1,2,3,4,5,6]
  
  [42] *6
  #=> [42,42,42,42,42,42]
#+end_src
*** in运算符
#+begin_src python
  5 in numbers 
  #=> True or False
#+end_src
*** 长度、最大值、最小值(len, max, min)
#+begin_src python
  len(numbers)
  #=> 10
#+end_src
** 列表
#+begin_src python
  helloList = list('Hello')  #字符串转换成字符列表
  #=>['H','e','l','l','o']
  ''.join(helloList)  #将字符列表转换成字符串
  #=>'Hello'
#+end_src
*** 列表可以修改
#+begin_src python
  #delete element
  numbers[5] = 64
  del numbers[5]
  #分片插入元素
  numbers[5:5] = [6,6]
  
  #分片删除元素
  numbers[2:8] = []
#+end_src

#+BEGIN_SRC python
  name = list('perl')
  name[2:] = list('ar')
  # name => ['p', 'e', 'a', 'r']
#+END_SRC
*** 列表方法
**** append
     #+begin_src python
     lst= [1,2,3]
     lst.append(4)
     lst
     #=> [1,2,3,4]
     #+end_src
**** count
     某个元素出现的次数
     #+begin_src python
     [1,5,6,7,53,1,5].count(1)
     #=> 2
     #+end_src
**** extend
     比lst1=lst1+lst2效率高
     #+begin_src python
     lst1.extend(lst2)
     #+end_src
**** index
     #+begin_src python
     ['who','where'].index('who')
     #=> 0
     #+end_src
**** insert
     #+begin_src python
     [1,2,3,4,5].insert(2, 'e')
     #=> [1,2,'e',3,4,5]
     #+end_src
**** pop
     移除列表中的一个元素(默认最后一个)，并返回该元素的值
     #+begin_src python
     x=[1,2,3]
     x.pop()
     #=> 3
     x
     #=> [1,2]     
     #+end_src
     注：使用pop可以实现数据结构——栈
**** remove 
     移除第一个匹配项
     #+begin_src python
     [1,2,3,4,5,6,7,8].remove(5)
     #=> [1,2,3,4,6,7,8]
     #+end_src
**** reverse
**** sort
     #+begin_src python
     x.sort()#x顺序已改变
     y = sorted(x)#y为x排序后的列表
     #+end_src
     
     #+BEGIN_VERSE
     sort 可选参数(也适用于sorted)：
     一、比较函数（见下一节）
     二、key
     x.sort(key=len)
     三、reverse
     x.sort(reverse=True)
     #+END_VERSE
**** 自定义排序(比较函数)
     #+BEGIN_VERSE
     自定义compare(x, y)
     x<y时返回负数，x>y时返回正数，x=y时返回0
     内建cmp函数例子：
     #+END_VERSE
     #+begin_src python
     cmp(42, 32)
     #=> 1
     cmp(99, 100)
     #=> -1
     cmp(5,5) 
     #=> 0
     numbers.sort(cmp)
     #+end_src
*** 空列表 []
*** 空元素列表 [None]
** 元组
   元组不能被修改
*** 声明
    #+begin_src python
    1,2,3 or (1,2,3)
    #=> (1,2,3)
    () #空元组
    #=> ()
    (1,) or 1, 
    #=> (1,)
    3*(40+2,)
    #=>(42,42,42)
    #+end_src
*** tuple函数
    传入序列，返回元组
    #+begin_src python
    tuple([1,2,3])
    #=> (1,2,3)
    #+end_src
*** 使用元组的场合
- 元组可以在映射中当作键使用，列表不行(详见第四章)
- 元组是很多内建方法的返回值。必须处理他们。
** 字符串
*** 基本操作
    所有标准的序列操作对字符串同样适用，唯一需要记住，字符串是不可变的。
*** 格式化操作符
#+begin_src python
  format = "Hello, %s. %s enough for ya?"
  values = ('world', 'Hot')
  print format % values
  #=>Hello, world. Hot enough for ya?
#+end_src
*** 常用方法
**** list, tuple
list将字符串转为列表，tuple转为元组
**** find
     #+begin_src python
     x.find("abc")
     #=>返回index
     #+end_src
    
**** join[fn:1]
     #+begin_src python
     seq = ['1','2','3']
     sep = '+'
     sep.join(seq)
     #=> '1+2+3'
     #+end_src

**** lower,upper,title
     title功能： 单词首字母大写

**** replace
     #+begin_src python
     x.replace('123', '456')
     #+end_src

**** split是join的逆方法
     #+begin_src python
     '/usr/bin/env'.split('/')
     #=>['','usr','bin','env']
     #+end_src
     split不提供参数时，默认根据空白字符分割，包括tab、换行符等。

**** strip
     去除两侧空格，也可传参数，去除指定的头尾字符

**** translate
     #+BEGIN_VERSE
     同replace 区别在于只处理单个字符。同时进行多个替换。
     有时比replace效率高的多。
     转换之前，需要完成一张转换表。可用string中的maketrans
     #+END_VERSE
     #+begin_src python
     maketrans('cs', 'kz')
     #+end_src

*** 原始字符串(raw string)
#+BEGIN_VERSE
使字符串中的转义符无效
r'c:\newtest.txt'
\n不会被解释为换行符
#+END_VERSE
** 字典
当索引不好用时使用
*** 创建
#+begin_src python
  phonebook={'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}#直接创建
  phonebook['Cecil']
  #=> '3258'
  
  phonebook={}
  phonebook['Denver'] = '5345'
  phonebook
  #=> { 'Denver': '5345' }
#+end_src
*** 使用dict函数初始化
    #+begin_src python
    items = [('name', 'Gumby'), ('age', 42)]
    d = dict(items)
    d
    #=> {'age': 42, 'name': 'Gumby'}

    d=dict(name='Gumby', age=42) #另一种声明
    #+end_src
*** 基本字典操作
    #+begin_src python
     len(d)
     del d[k]
     k in d#(检查是否存在k键)
    #+end_src
    自动添加，对不存在的键复制等于创建了一个新项

*** 字典的字符串格式化
字符串 % 字典名
#+begin_src python
  "Cecil's phone number is %(Cecil)s." % phonebook
  #=>"Cecil's phone number is 3258."
#+end_src
*** 字典方法
**** clear
     #+begin_src python
     x={}
     y=x
     x['key'] = 'value'
     y
     #=> {'key': 'value'}
     #+end_src
     #+BEGIN_VERSE
     一、x = {} =>y没变
     二、x.clear() => y {}
     #+END_VERSE

**** copy & deepcopy
     #+begin_src python
     x = {'key1': 'value1', 'key2': 'value2'}
     y = x.copy()
     #+end_src
     #+BEGIN_VERSE
     一、y.remove('key2')
     y和x 均受影响

     二、y['key1'] = 'value3'
     y受影响，x不受

     deepcopy避免了该问题，无论y怎么处理，x都不会变。
     #+END_VERSE

**** fromkeys
     使用给定的键建立字典，值默认都为None
     #+begin_src python
     dict.fromkeys(['name', 'age'])
     #+end_src
     也可自己提供值的默认值
     #+begin_src python
     dict.fromkeys(['name', 'age'], 'unknown')    
     #+end_src

**** get
     更宽松的访问字典项方法
     #+begin_src python
     d={}
     d['name']
     #=> 出错
     d.get('name')
     #=> None    
     #+end_src

**** has_key
     #+begin_example
     has_key相当于 k in d。python3.0不包含该方法。
     #+end_example

**** items & iteritems
     字典项以列表形式返回
     #+begin_src python
     d = {'key1': 'value1', 'key2': 'value2'}
     d.items()
     #=> [('key1', 'value1'), ('key2', 'value2')]
     it = d.iteritems()
     list(it)
     #=> [('key1', 'value1'), ('key2', 'value2')]
     #+end_src

**** keys & iterkeys
     键以列表形式返回

**** values & itervalues
     值以列表形式返回

**** pop
     pop用来获得对应于给定键的值，然后删除该项。
     #+begin_src python
     d.pop('key1')
     #+end_src

**** popitem
     #+BEGIN_VERSE
     类似于list.pop
     因为字典没有顺序的概念，pop出一个随机项。
     用处：若想一个接一个地处理并移除项，用该方法。
     #+END_VERSE

**** setdefault
     #+begin_src python
     d.setdefault('name', 'N/A')
     #字典中无该键返回如下：
     #=> 'N/A'
     #字典中有{'name': 'Gumby'}
     #=> 'Gumby'
     #+end_src

**** update
     利用一个字典项更新另外一个字典
     #+begin_src python
     d.update(x) #更新源d
     #+end_src

** 其他
*** set
#+BEGIN_VERSE
set位于sets模块中。python2.3以前需用import sets。
#+END_VERSE
#+begin_src python
set([0,1,2,3,0,1,2,3,4,5])#set是由序列(或其他可迭代对象)构建的。
#=>set([0,1,2,3,4,5])#相同的成员会被忽略。
set(['fee', 'fie', 'foe'])
#=>set(['foe', 'fee', 'fie'])#与字典一样，顺序是未知的
#+end_src
**** 集合操作
#+begin_src python
  a = set([1,2,3])
  b = set([2,3,4])
  a | b
  #=>set([1,2,3,4])
  c = a & b
  #=>set([2,3])
  c.issubset(a)
  #=>True
  c >= a
  #=>False
  a.intersection(b)
  #=>set([2,3])
  a.difference(b)
  #=>set([1])
  a-b
  #=>set([1])
  a.symmetric_difference(b)
  #=>set([1,4])
  a.copy() is a
  #=>False
#+end_src
*** heap
#+BEGIN_VERSE
优先序列的一种，以任意顺序追加元素。使用pop方法获取最小元素。
效率要比列表的min方法高。
堆算法：i位置处的元素总是比2*i以及2*i+1位置处的元素小。
#+END_VERSE
| heappush(heap, x)    | 将x加入堆            |
| heappop(heap)        | 将堆中最小元素返回   |
| heapify(list)        | 将列表转为堆         |
| heapreplace(heap, x) | pop出最小元素，加入x |
| nlargest(n, iter)    | 返回iter中第n大的元素 |
| nsmallest(n, iter)   | 返回iter中第n小的元素 |
#+begin_src python
  from heapq import *
  from random import shuffle
  data=range(10)
  shuffle(data)
  heapify(data)
  heappush(data, 0.4)
  heap
  #=>[0, 0.4, 4, 5, 1, 8, 9, 6, 7, 3, 2]
  heappop(data)
  #=>0
#+end_src
heapq中的nlargest和nsmallest 使用堆算法从可迭代对象中获取最大最小值
#+begin_src python
data=range(10)
shuffle(data)
nlargest(1, data)
#=>9
nsmallest(1,data)
#=>0
#+end_src
*** deque
#+BEGIN_VERSE
Double-ended queue双端队列
#+END_VERSE
#+begin_src python
  from collections import deque
  q = deque(range(5))
  q.append(5)#默认在队列右端追加
  q.appendleft(6)
  q
  #=>deque([6,0,1,2,3,4,5])
  q.pop()#默认从队伍右端pop出元素
  #=>5
  q.popleft()
  #=>6
  q.rotate(3)#右移三个元素
  #=>deque([2,3,4,0,1])
  q.rotate(-1)#左移一个元素
  #=>deque([3,4,0,1,2])
#+end_src

* 语句
** 赋值语句
*** 多个变量赋值
    #+begin_src python
    x, y, z = 1, 2, 3
    #+end_src
    
*** 交换变量
    #+begin_src python
    x, y = y, x
    #+end_src
*** 序列解包(sequence unpacking)
    #+begin_src python
    values = 1, 2, 3
    values
    #=> (1, 2, 3)
    x, y, z = values
    x
    #=> 1    
    #+end_src

    常用于函数方法返回元组时
    #+begin_src python
    key, value = scoundrel.popitem()    
    #+end_src

    python 3.0 特殊解包
    #+begin_src python
    a, b, rest* = [1, 2, 3, 4]
    rest
    #=> [3, 4]    
    #+end_src

*** 链式赋值
    #+begin_src python
    x = y = somefunction()
    #等同于
    y = somefunction()
    x = y
    #不一定等价于
    x = somefunction()
    y = somefunction()
    #+end_src

*** 增量赋值
    与其他语言差不多+=、*=等

** if语句
    #+BEGIN_VERSE
    如下会被视为False:
    False None 0 "" () [] {}
    其他非空值被视为True
    #+END_VERSE
    #+begin_src python
    True == 1 #=> True
    False == 0 #=> True
    #+end_src**** bool函数
     #+begin_src python
     bool('test')
     #=> True
     bool(42)
     #=> True
     bool('')
     #=> False
     #+end_src

**** if 语句写法
     #+begin_src python
     if true:
     .....
     if 条件1 and 条件2:
     and, or, not     
     #+end_src

**** 更多比较运算符
     #+begin_src python
     x is y  #x、y是同一个对象
     x is not y
     x in y
     x not in y
     #+end_src
     
     注：0<age<100 的形式也是可以的
     
     #+begin_src python
     #字符串可以根据字母顺序进行比较
     "a"<"b" => True  
     [1,2] < [2,1] #比较第一个值
     [2, [1, 4]] < [2, [1, 5]]   
     #+end_src

** 断言语句
#+begin_src python
  age = -1
  assert 0<age<100, 'message' #or assert 0<age<100
  #=>breakdown     
#+end_src
** while语句
#+begin_src python
  x=1
  while x<=100:
      print x
      x += 1     
#+end_src
** for语句
     #+begin_src python
     for number in range(1, 100):
         print number   
     #+end_src
     range包含下限1，不包含上限100[fn:2]
     
     #+begin_src python
     #循环遍历字典
     for key in d:
         print key, d[key]     
     #+end_src

** 拓展
*** 列表推导式(轻量级循环)
#+begin_src python
  [x*x for x in range(10)]
  #=> [0, 1, 4, 9, 25, 36, 49, 64, 81]      
  
  #可加条件：
  [x*x for x in range(10) if x % 3 ==0]
  #=>[0, 9, 36, 81]
  
  [(x, y) for x in range(3) for y in range(3)]
  #=>[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]
  
  #等同于
  result = []
  for x in range(3):
      for y in range(3):
  result.append((x, y))
#+end_src
*** 序列合并迭代(zip)
合并两个序列为一个元组列表
#+begin_src python
  names = ['name1', 'name2']
  ages = [12, 45]
  zip(names, ages)
  #=> [('name1', 12), ('name2', 45)]
  
  #解包元组，遍历
  for name, age in zip(names, ages):
      print name, 'is', age, 'years old'     
#+end_src
*** 编号迭代(enumerate)
      enumerate函数可以在提供索引功能的序列中，迭代返回键值对。
      #+begin_src python
      for index, string in enumerate(strings):
          if 'xxx' in string:
	  strings[index] = '[censored]'      
      #+end_src
*** 翻转和排序迭代(reversed, sorted)
      #+BEGIN_VERSE
      reversed, sorted与序列方法reverse, sort差不多，区别在于reverse和sort改变原调用对象
      sorted函数返回列表
      reversed函数返回一个可迭代对象      
      #+END_VERSE
      #+begin_src python
      list(reversed('Hello,World!'))
      #=>'!dlroW,olleH'
      #+end_src

*** for...else语句
      #+begin_src python
      for n in range(99, 81, -1):
          root = sqrt(n)
          if root == int(root):
              print n
              break
      else:
          print "Didn't find it!"      
      #+end_src
      break直接进入else语句块
* 函数
** 定义函数
   #+begin_src python
   def fibs(num):
       'generate fib sequence'
       result = [0, 1]
       for i in range(num-2):
           result.append(result[-2] + result[-1])
       return result
   #+end_src
** 参数
*** 基本
#+BEGIN_VERSE
函数内改变参数变量的值，不会改变外部传入变量的值。即值传递方式。
可变的数据结构，如列表。即引用传递方式。    
#+END_VERSE
*** 不可变的数据结构，改变传入值的方法
- 使用返回值
    #+begin_src python
    def inc(x): return x+1    
    #+end_src

- 包在列表中传递
    #+begin_src python
    def inc([x]): x[0] = x[0] + 1
    foo = [10]
    inc(foo)
    foo 
    #=> 11
    #+end_src
*** 参数过多，顺序难记
#+begin_src python
  def hello(greeting, name):
      print '%s, %s' % (greeting, name)
  
  hello('Hello', 'world')#参数顺序难记时，使用 参数名=传入值 的形式
  hello(greeting='Hello', name='world')
#+end_src
*** 参数默认值
#+begin_src python
  def hello2(greeting='Hello', name='world'): #提供默认值
      print '%s, %s!' % (greeting, name)
  hello2()
  #=>Hello, world!
#+end_src
*** 任意数量的参数
**** 参数定义时加上'*'
#+begin_src python
  def print_params(title, *params):
      print title, params#传入的params参数会作为元组使用
  print_params('Print params', 'param1', 'param2')
  #=>Print params
  #=>Print params ('param1', 'param2')
      
  print_params('Nothing')
  #=>Nothing ()    
#+end_src
**** 参数定义时加上'**'
#+begin_src python
  def print_params2(**params):
      print params#传入的params参数会作为字典使用
  print_params2(x=1, y=2, z=3)
  #=>( 'x' : 1, 'y' : 2, 'z' : 3)     
#+end_src
*** 将元组和字典作为参数(以上逆过程)
    #+begin_src python
      #序列用法
      def  add(x, y): return x + y
      params = (1, 2)
      add(*params)#加上*
      #=>3

      #字典用法
      def hello3(greeting='Hello', name='world'):
          print '%s, %s!' % (greeting, name)
      params = {'name': 'Sir Robin', 'greeting': 'Well met'}
      hello3(**params)#加上**
      #=>Well met, Sir Robin!
    #+end_src
*** 变量作用域
    #+begin_src python
    scope = vars()#vars()返回全局变量的字典
    x=1
    scope['x']
    #=>1
    scope['x'] += 1
    x
    #=>2
    #+end_src
#+BEGIN_VERSE
以上代码说明：
赋值语句实际上是在一个全局变量字典中建立了一个键值对，
只不过这个字典是对外隐藏的。这个“不可见”字典就是变量的作用域。
能够创建变量作用域的代码段有def、class、lamda。
#+END_VERSE
**** 函数内访问全局变量
    在函数作用域内调用同名全局变量，需使用globals()['globalName']
    #+begin_src python
    def combine(param):
        print param + globals()['param']
    param = 'berry'
    combine('Shrub')
    #=>Shrubberry
    #+end_src

**** 函数内改变全局变量
    #+begin_src python
    x=1
    def change_global():
        global x
        x = x + 1
    change_global()
    x
    #=>2
    #+end_src

*** 递归
    #+begin_src python
    def power(x, n):
        if n == 0:
	return 1
        else:
	return x * power(x, n-1)
    #+end_src

** 查看函数说明
fibs.__doc__ 可访问函数说明、help(fibs) 更好用
** 空返回值
函数如果无返回值，返回None
** 闭包
*** 快速预览
以下是一段简单的闭包代码示例：
#+begin_src python
  def foo():
      m=3
      n=5
      def bar():
          a=4
          return m+n+a
      return bar
  
  >>>bar =  foo()
  >>>bar()
  12
#+end_src
#+BEGIN_VERSE
说明：
bar在foo函数的代码块中定义。我们称bar是foo的内部函数。

在bar的局部作用域中可以直接访问foo局部作用域中定义的m、n变量。
简单的说，这种内部函数可以使用外部函数变量的行为，就叫闭包。

那么闭包内部是如何来实现的呢？
我们一步步来，先看两个python内置的object: <code>和<cell>
#+END_VERSE
*** code object
#+BEGIN_VERSE
code object是python代码经过编译后的对象。
它用来存储一些与代码有关的信息以及bytecode。

以下代码示例，演示了如何通过编译产生code object
以及使用exec运行该代码，和使用dis方便地查看字节码。

code object还有很多的特性可以访问。详细请看官方文档。
#+END_VERSE
#+begin_src python
  import dis
  code_obj = compile('sum([1,2,3])',  '', 'single')

  >>>exec(code_obj)
  6

  >>> dis.dis(code_obj)
    1           0 LOAD_NAME                0 (sum)
                3 LOAD_CONST               0 (1)
                6 LOAD_CONST               1 (2)
                9 LOAD_CONST               2 (3)
               12 BUILD_LIST                   3
               15 CALL_FUNCTION          1
               18 PRINT_EXPR          
               19 LOAD_CONST               3 (None)
               22 RETURN_VALUE        
#+end_src
#+BEGIN_VERSE
那么，这跟我们的例子有什么关系？
#+END_VERSE
#+begin_example
  >>> foo.func_code
  <code object foo at 01FE92F0, file "<pyshell#50>", line 1>
#+end_example
#+BEGIN_VERSE
我们可以看到，函数定义好之后，就可以通过[函数名.func_code]
访问该函数的code object，之后我们会用到它的一些特性。
#+END_VERSE
*** cell object
#+BEGIN_VERSE
cell对象的引入，是为了实现被多个作用域引用的变量。
对每一个这样的变量，都用一个cell对象来保存 *其值* 。

拿之前的示例来说，m和n既在foo函数的作用域中被引用，又在bar
函数的作用域中被引用，所以m, n引用的值，都会在一个cell对象中。

可以通过内部函数的__closure__或者func_closure特性查看cell对象：
#+END_VERSE
#+begin_example
  >>> bar = foo()
  >>> bar.__closure__
  (<cell at 0x01FE8DF0: int object at 0x0186D888>, <cell at 0x01F694B0: int object at 0x0186D870>)
#+end_example
#+BEGIN_VERSE
这两个int型的cell分别存储了m和n的值。
无论是在外部函数中定义，还是在内部函数中调用，引用的指向都是cell对象中的值。

注：内部函数无法修改cell对象中的值，如果尝试修改m的值，编译器会认为m是函数
bar的局部变量，同时foo代码块中的m也会被认为是函数foo的局部变量，就会再把m
认作闭包变量，两个m分别在各自的作用域下起作用。
#+END_VERSE
*** 闭包分析
- 使用dis[fn:3]模块分析foo的bytecode。
#+begin_example
  2          0 LOAD_CONST              1 (3)
              3 STORE_DEREF               0 (m)
  
  3          6 LOAD_CONST              2 (5)
              9 STORE_DEREF               1 (n)
  
  4          12 LOAD_CLOSURE         0 (m)
              15 LOAD_CLOSURE         1 (n)
              18 BUILD_TUPLE              2
              21 LOAD_CONST             3 (<code object bar at 018D9848, file "<pyshell#1>", line 4>)
              24 MAKE_CLOSURE         0
              27 STORE_FAST               0 (bar)
  
  7          30 LOAD_FAST                 0 (bar)
              33 RETURN_VALUE    
#+end_example
#+BEGIN_VERSE
进行逐行分析：

*LOAD_CONST  1 (3)* ：
将foo.func_code.co_consts ~[1]~ 的值"3"push进栈。

*STORE_DEREF  0 (m)* ：
从栈顶Pop出"3"包装成cell对象存入cell与自由变量的存储区的第0槽。
将cell对象的地址信息赋给变量m(闭包变量名记录在func_code.cellvars)。
func_code.cellvars的内容为('m', 'n')

*LOAD_CLOSURE  0 (m)* ：
将变量m的值push进栈，类似如下信息：
<cell at 0x01D572B0: int object at 0x0180D6F8>

*LOAD_CLOSURE  1 (n)* ：
类似变量m的处理，不在累述。

当前栈区状态：
#+END_VERSE
| 1 | <cell at 0x01D572B0: int object at 0x0180D6F8> |
| 2 | <cell at 0x01D86510: int object at 0x0180D6E0> |
| 3 | ...                                            |
#+BEGIN_VERSE

*BUILD_TUPLE  2* ：
将栈顶的两项取出，创建元组，并将该元组push进栈。

*LOAD_CONST  3* ：
从foo.func_code.co_consts ~[3]~ 取出，该项为内部函数bar的code object的地址，将其push进栈
<code object bar at 018D9848, file "<pyshell#1>", line 4>

栈区状态：
#+END_VERSE
| 1 | <code object bar at 018D9848, file "<pyshell#1>", line 4>                                        |
| 2 | (<cell at 0x01D572B0: int object at 0x0180D6F8>, <cell at 0x01D86510: int object at 0x0180D6E0>) |
| 3 | ...                                                                                              |
#+BEGIN_VERSE

*MAKE_CLOSURE  0* ：
创建一个函数对象，将位于栈顶的code object(bar函数的code)地址信息赋
给该函数对象的func_code特性；
将栈顶第二项(包含cell对象地址的元组)赋给该函数对象的func_closure特性；
最后将该函数对象地址信息push进栈。

*STORE_FAST  0 (bar)* ：
从栈顶取出之前创建的函数对象的地址信息赋给局部变量bar(局部变量名记录在func_code.co_varnames中)
func_code.co_varnames的内容为('bar',)
将变量bar(记录在func_code.cellvars ~[0]~ )绑定栈顶的函数对象地址。
*LOAD_FAST  0 (bar)* ：
将变量bar的值push进栈。

*RETURN_VALUE*
返回栈顶项，print bar可以看到<function bar at 0x01D899F0>

#+END_VERSE
- 再分析bar函数就简单了
#+begin_example
  5           0 LOAD_CONST            1 (4)
               3 STORE_FAST               0 (a)
  
  6           6 LOAD_DEREF               0 (m)
               9 LOAD_DEREF               1 (n)
               12 BINARY_ADD          
               13 LOAD_FAST               0 (a)
               16 BINARY_ADD          
               17 RETURN_VALUE        
#+end_example
#+BEGIN_VERSE
重点是LOAD_DEREF，该方法主要是将cell对象中的object内容push进栈。大致过程如下：

根据变量m的值找到包装在cell内的int object的地址信息
m的值：<cell at 0x01D572B0: int object at 0x0180D6F8>

根据地址取出int值，push进栈。
#+END_VERSE
** 函数柯里化
*** 柯里化(Currying)
一个函数有多个参数，我们希望能固定其中几个参数的值。
#+begin_src python
  from functools import partial
  def foo(a,b,c):
      return a+b+c
  
  foo2 = partial(foo, b=2)
  foo2(a=1, c=3)
  #=>6
#+end_src
#+BEGIN_VERSE
看上去这跟提供参数默认值的情况类似。但默认值只能固定
为单个值，而柯里化能通过泛化出很多个函数，每个函数用
不同的固定值，来看一下 *应用场景* ：
#+END_VERSE
#+begin_src python
  from functools import partial
  bin2dec = partial(int, base=2)
  hex2dec = partial(int, base=16)
#+end_src
#+BEGIN_VERSE
原int方法的定义为：int( x[, base])，base参数的默认为10
经过柯里化之后，可以用如下方式调用：
#+END_VERSE
#+begin_src python
int('15') #=>15  using default base 10
bin2dec('01011') #=>11
hex2dec('67') #=>103
#+end_src
*** 反柯里化(Uncurrying)
#+BEGIN_VERSE
顾名思义，柯里化的逆过程。
将多个只含单个参数的函数模拟成一个多参数函数。
#+END_VERSE
#+begin_src python
  def foo(a):
      def bar(b):
          return a+b
      return bar
#+end_src
你可以像这样调用：foo(1)(4)或(foo(1))(4)，都能得到正确的结果5。
- 那么反柯里化有什么用？
#+BEGIN_VERSE
一些函数式编程语言，就是利用反柯里化来实现多参数函数。
#+END_VERSE
** 拓展
*** 斐波那契数列
    #+begin_src python
    fibs = [0, 1]
    for i in range(8):
        fibs.append(fibs[-2] + fibs[-1])
    fibs
    #=> [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    #抽象成
    fibs(num)   
    #+end_src
*** map/reduce/filter
**** map
map(func, seq1, seq2, ...])
#+begin_src python
  map(lambda x,y: x+y, [1,2,3,4,5], [6,7,8,9,10])#seq1对应arg1, seq2对应arg2
  #=>[7, 9, 11, 13, 15]
#+end_src
**** reduce
#+begin_src python
reduce(func, seq)
等同于func(func(func(seq[0], seq[1]), seq[2])...)
eg:
reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])
#=>15
#+end_src
**** filter
#+BEGIN_VERSE
filter(func, seq)
func需返回布尔值
#+END_VERSE
#+begin_src python
  filter(lambda x: x>3 and True or False, [1,2,3,4,5])
  #=>[4,5]
  filter(lambda x: True if x>3 else False, [1,2,3,4,5])
  #=>[4,5]
#+end_src
* 类
** 定义类
   #+begin_src python
     class Person:
         def setName(self, name):
             self.name = name
     
         def getName(self):
             return self.name
     
         def greet(self):
             print "Hello, world! I'm %s" % self.name
   #+end_src
*** self参数
#+begin_src python
  class A:
      def a(self):
          print 'Hello'

  i = A()
  i.a
  #=><bound method A.a of <__main__.A instance at 0x01E26648>>
  i.a()
  #=>Hello
  #等同于
  A.a(i)
  #=>Hello
#+end_src
*** 函数的变量绑定
#+begin_src python
  class A:
      def a(self):
          print 'Hello'
  def b():
      print 'World'

  i=A()
  i.a=b#i.a是一个特性，可以绑定任何方法
  i.a
  #=><function b at 0x01E279B0>
  i.a()
  #=>World
  A.a(i)
  #=>Hello

  i2=A()
  c=i2.a#c是方法变量
  c
  #=><bound method A.b of <__main__.A instance at 0x01E2F8A0>>
  c()
  #=>Hello
#+end_src

*** 私有成员
#+BEGIN_VERSE
python不直接支持私有成员。
需要程序员自己把握从外部调用实例成员的时机
小技巧：加上双下划线__，使方法变为对外不可见
#+END_VERSE
#+begin_src python
  class Secretive:
      def __inaccessible(self):
          print "You can't find me"
      def accessible(self):
          print "You can find me"
          self.__inaccessible()
  i=Secretive()
  i.__inaccessible()
  #=>Error
  i.accessible()
  #=>You can find me
  #=>You can't find me
#+end_src
**** 内幕
所有的以双下划线开头的成员方法"__方法名"，都被转成"_类名__方法名"
#+begin_src python
  Secretive._Secretive__inaccessible
  #=><unbound method Secretive.__inaccessible>
  i._Secretive__inaccessible()
  #=>You can't find me
#+end_src
**** 使用单下划线
#+BEGIN_VERSE
这更像是一种习惯或者约定，程序员看到'_'开头的方法时，就不应该再从外部访问该方法。
在使用import导入的时候，这些成员也不会被列出。
#+END_VERSE
#+begin_src python
  def _privateMethod():
      print "You should not invoke this from outside"
#+end_src
** 类成员变量(非实例成员)
定义一个Class时，类空间域中的代码都会执行。
#+begin_src python
  class C:
      print "Class C"#会被执行
  #=>Class C
#+end_src
#+begin_src python
  class A:
      count = 0#定义了一个类成员number并初始化为0，有点类似于其他语言的静态成员
      def init(self):
          A.count += 1
  
  m1=A()
  m1.init()
  A.count
  #=>1

  m2=A()
  m2.init()
  A.count
  #=>2

  #实例作用域同样适用
  m1.count
  #=>2
  m2.count
  #=>2
  
  #实例作用域已分开
  m1.count = 5#创建了m1的成员变量count，m1.count不再绑定类变量A.count
  m1.count
  #=>5
  m2.count
  #=>2
  m1.__dict__
  #=>{'count': 5}
#+end_src
** 类静态方法和类方法
#+begin_src python
  class StaticMethodTest:
      def staticMeth():
          print 'calling static method'
      staticMeth=staticmethod(staticMeth)
      def classMeth(cls):
          print 'calling class method'
      classMeth=classmethod(classMeth)    
      def instanceMeth(self):
          print 'calling instance method'
  
  s = StaticMethodTest()
  s.staticMeth()
  #=>calling static method
  s.classMeth()
  #=>calling class method
  s.instanceMeth()
  #=>calling instance method
  StaticMethodTest.staticMeth()
  #=>calling static method
  StaticMethodTest.classMeth()
  #=>calling class method
  StaticMethodTest.instanceMeth()
  #=> unbounded method error
#+end_src

#+begin_src python
  #decorators新语法
  __metaclass__=type
    class StaticMethodTest:
        @staticmethod
        def staticMeth():
            print 'calling static method'
#+end_src
** 属性
*** 适用新式类
#+begin_src python
  __metaclass__=type
  class Retangle:
      def __init__(self):
          self.width=0
          self.height=0
      def setSize(self, size):
          self.width, self.height=size
      def getSize(self):
          return self.width, self.height
      size = property(getSize, setSize)
  
  r = Retangle()
  r.width=10
  r.height=5
  r.size
  #=>(10, 5)
  r.size = 150, 100
  r.width
  #=>150
#+end_src
*** 适用旧式类
- __getattr__(self,name)
- __setattr__(self,name,value)
- __delattr__(self,name)
#+begin_src python
  class Retangle:
      def __setattr__(self, name, value):
          if name =='size':
              self.width, self.height = value
          else:
              self.__dict__[name] = value
      def __getattr__(self,name):
          if name == 'size':
              return self.width, self.height
          else:
              raise AttributeError
#+end_src
#+BEGIN_VERSE
注：只有特性不存在时，才会调用__getattr__。
本例中self.size特性不存在，__getattr__会被调用。
如果访问width特性，则不会调用__getattr__。
#+END_VERSE
** 继承
*** 定义子类
#+begin_src python
  class Parent:
      def init(self):
          print "Init Parent done"
  
  class ChildA(Parent):
      def init(self):#重写父类的init方法
          print "Init Child done"
  
  class ChildB(Parent):
      pass
  
  p = Parent()
  p.init()
  #=>Init Parent done
  a = ChildA()
  a.init()
  #=>Init Chile done
  b = ChildB()
  b.init()
  #=>Init Parent done
#+end_src
*** 查询类继承关系
- issubclass(sub, parent) 判断两个类是否为父子关系
#+begin_src python
  issubclass(ChildA, Parent)
  #=>True
#+end_src
- sub.__bases__ 查找一个类的父类
#+begin_src python
  ChildA
  #=><class __main__.ChildB at 0x01E44EA0>
  ChildA.__bases__#查找父类
  #=>(<class __main__.Parent at 0x01E1F340>,)
#+end_src
*** 查询对象的类别
- isinstance(instance, class) 判断对象是否属于某类
#+begin_src python
  isinstance(a, ChildA)
  #=>True
  isinstance(a, Parent)
  #=>True
#+end_src
- instance or instance.__class__ 查询对象属于哪个类
#+begin_src python
  a
  #=><__main__.ChildA instance at 0x01E181C0>
  a.__class__
  #=><class __main__.ChildA at 0x01E32030>
#+end_src
** 多重继承
#+BEGIN_VERSE
经典类指的是没有继承任何基类直接定义的类。
新式类指的是基类为"object"的类。
- 特性搜寻算法(MRO)
[旧]深度优先，从左到右进行搜索。
[新]广度优先，从继承层次下层从左到右开始搜索。
#+END_VERSE
   #+CAPTION: 
   #+ATTR_HTML: align="center"
   [[file:../resources/python/MultipleInheritance.png]]
经典类算法：
#+begin_src python
  gc=GC()
  gc.foo() # GC==>C1==>P1
  #=>called P1-foo()
  gc.bar() # GC==>C1==>P1==>P2
  #=>called P2-bar()
  C2.bar(gc)#才会调用C2中的bar
  #=>called C2-bar()
#+end_src
#+BEGIN_VERSE
问题在于C2在继承树上与GC更亲近，一般的思维习惯是调用C2

新式类算法：
#+END_VERSE
#+begin_src python
  gc=GC()
  gc.foo() # GC==>C1==>C2==>P1
  #=>called P1-foo()
  gc.bar() # GC==>C1==>C2
  #=>called C2-bar()
#+end_src
新式类可使用__mro__特性查看mro顺序
#+begin_src python
  GC.__mro__
  (<class '__main__.GC'>, <class '__main__.C1'>, <class '__main__.C2'>, <class '__main__.P1'>, <class '__main__.P2'>, <type 'object'>)
#+end_src
** 接口和内省
#+BEGIN_VERSE
*Python不需要单独定义接口或抽象类*
Python变量a，无所谓它是什么类型。调用a.func时，
只要保证对象a中存在特性func就能正常调用。
这就是Python强大的内省机制(即在运行时，获取对象的全部信息)。
#+END_VERSE
- hasattr 检查特性是否存在
#+begin_src python
    class A:
        def printNote(self):
            print "A"
  a = A()
  hasattr(a, 'printNote')
  #=>True
  hasattr(a,'print')
  #=>False
#+end_src
- getattr(obj, 'attr', None) 获取特性信息。第三个参数表示找不到该属性时，返回的值 。
#+begin_src python
  #甚至可以检查是否可调用
  getattr(a,'printNote',None)#3.0中已不再使用, getattr可以使用默认值，此处是None
  #=><bound method A.printNote of <__main__.A instance at 0x01DA4C88>>

  setattr(a,'name','Mr.Gumby')#相对应的方法Setattr
  >>>a.name
  'Mr.Gumby'
#+end_src
** 类的特殊特性总结
| 特性       | 说明                   |
|------------+------------------------|
| __dict__   | 类名字空间的特性字典   |
| __doc__    | 类的文档说明字符串     |
| __name__   | 类的名称               |
| __module__ | 类的模块名             |
| __bases__  | 该类所有父类组成的元组 |
* 异常
** 抛出异常
使用raise语句抛出异常
#+begin_src python
raise Exception('Error occured')
#=>Traceback (most recent call last):
#=>  File "<pyshell#96>", line 1, in <module>
#=>    raise Exception('Error occured')
#=>Exception: Error occured
#+end_src
** 内建异常类
#+BEGIN_VERSE
 参考手册“Built-in Exceptions”一节。
 内建异常都在exceptions模块
 #+END_VERSE
** 自定义异常类
只需创建类时，继承Exception基类即可。
** 捕捉异常
- try/except语句
#+begin_src python
  import exceptions
  try:
      print 5/0
  except ZeroDivisionError:
      print "Error: modulo by zero"
  except (TypeError, NameError), e:#多个异常，放入元组中捕捉，e是异常实例
      print e
#+end_src
注：3.0中改为except(TypeError, NameError) as e
- try/except/else语句
#+BEGIN_VERSE
当未捕捉到异常时，执行else语句块
#+END_VERSE
- try/except/finally
finally语句块无论是否捕捉到异常都会被执行，多用于清理资源。
** 常用异常类列表
| 类名              | 说明                         |
|-------------------+------------------------------|
| Excepition        | 异常基类                     |
| AttributeError    | 特性引用或赋值失败           |
| IOError           | 文件IO异常                   |
| IndexError        | 使用序列中不存在的索引       |
| KeyError          | 使用映射中不存在的键         |
| NameError         | 找不到特性(变量)名           |
| SyntaxError       | 代码语法错误                 |
| TypeError         | 方法传入参数类型错误         |
| ValueError        | 方法传入不合适的值，类型正确 |
| ZeroDivisionError | 除数为0                   |

** DB相关异常列表
| 异常             | 基类          | 说明                         |
|------------------+---------------+------------------------------|
| StandardError    |               | 所有异常的基类               |
| Warning          | StandardError | 非致命错误时引发             |
| Error            | StandardError | 所有错误类型的基类           |
| InterfaceError   | Error         | 接口错误                     |
| DatabaseError    | Error         | 与数据库相关的错误基类       |
| DataError        | DatabaseError | 与数据相关的问题，值超出范围 |
| OperationalError | DatabaseError | 数据库内部操作错误           |
| IntegrityError   | DatabaseError | 关系完整性错误，如键检查失败 |
| InternalError    | DatabaseError | 数据库内部错误               |
| ProgrammingError | DatabaseError | 用户编程错误，如未找到表     |
| NotSupportError  | DatabaseError | 请求不支持的特性，如回滚     |
* 高级特性和隐藏特性
#+BEGIN_VERSE
大多数隐藏特性，只对新式类起作用。可将赋值语句__metaclass__=type放在模块
的最开始，或者定义类时继承自object类，来定义新式类。3.0起没有“旧式“类了。
#+END_VERSE
** __init__、__del__
#+BEGIN_VERSE
分别对应构造和析构方法，构造函数是被使用的最多的隐藏方法。
析构函数由于其内存释放的不确定性，调用时机未知，一般不建议使用。
#+END_VERSE
*** 继承体系中的__init__
#+BEGIN_VERSE
__init__和一般的方法一样，子类会重写父类的构造。
为了调用父类的构造，一般有两种方法：
#+END_VERSE
- 调用未绑定的父类构造方法
#+BEGIN_VERSE
该方法是3.0以前的老方法，属于历史遗留问题。
使用super函数简单明了。
#+END_VERSE
#+begin_src python
  class Drived(Base):
      def __init__(self):
          Base.__init__(self)#调用基类构造
          self.var1=5#自身特性赋值
#+end_src
- 使用super函数
#+BEGIN_VERSE
只适用于新式类。
#+END_VERSE
#+begin_src python
  class Drived(Base):
      def __init__(self):
          super(Drived, self).__init__()
#+end_src
** 集合相关__len__、__getitem__等
需要自行实现的隐藏方法有：
1) __len__(self)
2) __getitem__(self,key)
3) __setitem__(self,key,value)
4) __delitem__(self,key)

注意点：
- 键允许是负整数

#+BEGIN_VERSE
完全自己实现，代价太大，而且不一定实现的很好。
一般的做法：继承UserList, UserString, UserDict
最新版本的python中，可以继承内建类了。可以直接继承内建list类。
#+END_VERSE
#+begin_src python
  class CounterList(list):
      def __init__(self, *args):
          super(CounterList, self).__init__(*args)
          self.counter = 0
      def __getitem__(self, index):
          self.counter += 1
          return super(CounterList, self).__getitem__(index)
#+end_src

** 迭代器__iter__
#+BEGIN_VERSE
迭代器需要实现next方法，如果实现了__iter__方法，说明其是可迭代的。
因为__iter__方法定义，需要返回一个迭代器。
#+END_VERSE
#+begin_src python
  class Fibs:
      def __init__(self):
          self.a = 0
          self.b = 1
      def next(self):
          self.a, self.b = self.b, self.a+self.b
          return self.a
      def __iter__(self):
          return self
  fibs = Fibs()
  for f in fibs:#in关键字后面应跟有可迭代对象
      if f >100:
          print f
          break
  #=>144
  it=iter(fibs)#iter方法返回迭代器
  it.next()
  #=>233
  fibs.next()
  #=>377
#+end_src
*** 从迭代器得到序列
#+begin_src python
  class TestIterator:
      def __init__(self):
          self.value=0
      def next(self):
          self.value += 1
          if self.value > 10: raise StopIteration #没有这行，list会无限循环下去
          return self.value
      def __iter__(self):
          return self
  ti = TestIterator()
  list(ti)
  #=> [1,2,3,4,5,6,7,8,9,10]
#+end_src
** 生成器yield语句
#+BEGIN_VERSE
生成器为了帮助程序员写出非常优雅的代码而出现的。
编写任何程序时不用生成器也是可以的。
生成器是一个包含yield语句的函数，当函数被调用时，函数体中的代码不会被执行，
而返回一个生成器(类似于有next()方法的迭代器)。每次调用next()请求，会执行到
yield语句并返回一个值。return语句意味着生成器要停止执行。
多用于递归。
#+END_VERSE
#+begin_src python
  def simpleGen():
      yield 1
      yield 2
      return
      yield 3
  
  myG=simpleGen()#myG为生成器
  myG.next()#next调用到yield语句得到返回值，并且中止函数运行
  #=>1
  myG.next()#继续函数运行，知道下一个yield语句
  #=>2
  myG.next()#已无未执行的yield语句
  #=>StopIteration exception
#+end_src
#+BEGIN_VERSE
for循环会自动调用next()
for循环捕捉到StopIteration异常时停止。
#+END_VERSE
#+begin_src python
for each in simpleGen():
	print each
1
2
#+end_src
- 通过生成器直接生成列表
#+begin_src python
list(simpleGen())
#=>[1,2]
#+end_src
- 列表推导式和生成推导式
#+begin_src python
  g = (x*x for x in range(2,5))#g是一个生成器
  g.next()
  #=>4
  [x*x for x in range(2,5)]
  #=>[4,9,16]
#+end_src
*** send方法
#+begin_src python
  def repeater(value):
      while True:
          new = (yield value)
          if new is not None: value = new
          
  r = repeater(42)
  r.next()
  #=>42
  r.send("hello world")#yield 语句后的变量被赋值为'hello world'
  #=>'hello world'
  r.next()
  #=>'hello world'
#+end_src
*** throw、close方法
#+BEGIN_VERSE
throw用于在生成器内(yield)引发一个异常。
close用于关闭生成器，关闭之后执行next会接收到StopIteration异常。
#+END_VERSE
*** 旧版的对应方法
#+begin_src python
  def flatten(nested):
      result=[]
      try:
          for sublist in nested:
              for element in flatten(sublist):
                  result.append(element)#对应yield element
      except TypeError:
          result.append(nested)
      return result
#+end_src
*** 借助生成器解决八皇后问题
判断最后一行，指定列号位置放入皇后后是否与之前的皇后位产生冲突
#+begin_src python
  #state[0]=3 表示第一行第四列
  def conflict(state, nextX):
      'state是已放置好的皇后的位置信息，nextX为新增皇后的行位置(对于空state也能正常运作)'
      nextY = len(state)
      for i in range(0, nextY):
          if abs(nextX-state[i]) in (0, nextY-i):
              return True
      return False
#+end_src
递归从第一行开始逐行放入皇后，并判断是否与之前摆放完成的皇后们产生冲突
#+begin_src python
  def queens(n, state=()):
      for pos in range(n):
          if not conflict(state, pos):
              if len(state) == n-1:#表示仅最后一个位置未放置皇后，递归的最终层
                  yield (pos,)
              else:
                  for result in queens(n, state + (pos,)):#当最后一层yield出内容后，此处result才会有结果。
                      yield (pos,) + result

  list(queens(4, (1,)))
  #=>[(3,0,2)]
  list(queens(4))
  #=>[(1,3,0,2), (2,0,3,1)]
#+end_src
让输出变的漂亮一些
#+begin_src python
  def prettyprint(state):
      def line(x, length):
          return '. '*x + 'X ' + '. '*(length-x-1)
      for x in state:
          print line(x, len(state))
  
  import random
  prettyprint(random.choice(list(queens(4))))
  #=>
  . X . . 
  . . . X 
  X . . . 
  . . X . 
  
#+end_src
* 模块
** 导入自定义模块
- 向sys.path中追加(不常用)
#+begin_src python
import sys
sys.path.append('/Home/python')
#+end_src
- 或者直接将模块放置在python的查找目录
#+begin_src python
print(sys.path)#可查看当前python查询目录
pprint.pprint(sys.path)#pprint提供更加智能的打印输出
#+end_src
推荐放置在site-packages目录下
- 使用系统环境变量PYTHONPATH
#+BEGIN_VERSE
Windows用户变量中加入PYTHONPATH项
Linux下在.bashrc中追加：
#+END_VERSE
#+begin_src sh
  export PYTHONPATH=$PYTHONPATH:~/Home/python
#+end_src

- 模块更新后，重载，使用reload()方法

** 仅导入定义，不运行模块内程序
可在模块可执行代码前加上判断：
#+begin_src python
  if __name__ =='__main__': test()
#+end_src
导入的模块的__name__值为模块名。
#+begin_src python
  hello3.__name__
  #=>'hello3'
#+end_src
** 包
#+BEGIN_VERSE
包就是包含模块的文件夹，要将普通的文件夹变为python包，
需要在文件夹下新建一个__init__.py的文件。
导入包中模块的方式如下：
#+END_VERSE
#+begin_src python
import package
import package.module1
from package import module2
#+end_src
** 查看模块说明
首先，需要import对应模块，以内建copy模块为例
#+begin_src python
import copy
#+end_src
*** dir查看
dir列出模块中的类、函数和变量。
#+begin_src python
[n for n in dir(copy) if not n.startswith('_')]#此处用列表推导式过滤掉了系统用的__开头的函数
#=>['Error', 'PyStringMap', 'copy', 'deepcopy', 'dispatch_table', 'error', 'name', 't', 'weakref']
#+end_src
*** __all__变量
#+begin_src python
copy.__all__
#=>['Error', 'copy', 'deepcopy']
#+end_src
#+BEGIN_VERSE
__all__是在源代码copy.py中被设置成'Error', 'copy', 'deepcopy'
__all__用来定义public interface

如果使用from copy import *的话，只能直接使用__all__中的函数。
如要使用PyStringMap，有两种方式：
1) copy.PyStringMap
2) from copy import PyStringMap 之后调用PyStringMap即可

编写自己的模块时，最好要指定__all__，如果未指定，import *会导入所有
非下划线开头的特性。
#+END_VERSE
*** help和__doc__
help更详细一些，会有函数签名。
*** 查看源代码
#+BEGIN_VERSE
__file__变量存放着源代码的路径
一些模块没有__file__变量，可能是用C语言写的。
#+END_VERSE
** 核心模块
*** sys
#+BEGIN_VERSE
sys.argv 获取执行程序所输入的参数列表
sys.exit(0) 退出程序，返回程序运行正常的返回值0
#+END_VERSE
|sys.path|sys.platform|sys.stdin/stdout/stderr|
*** os
#+BEGIN_VERSE
os.path子模块，负责当前操作系统的路径操作。常用os.path.split、os.path.join。
#+END_VERSE
| environ     | 返回系统环境变量字典            |
| system(cmd) | 新建一个子shell，执行系统命令行 |
| sep         | 路径中目录间分隔符              |
| pathsep     | 各路径之间的分隔符              |
| linesep     | 行分隔符                        |
#+BEGIN_VERSE
system(r'c:/"test app.exe"')需要将带空格的目录或文件名用引号包起来，系统才能正常识别
解决方案startfile(path)，例：os.startfile(r'c:/test app.exe')
另外， system函数根据操作系统不同执行方式也不同：
#+END_VERSE
- windows 启动外部程序后，当前python程序仍会继续执行
- linux 启动外部程序后，当前python程序中断，外部程序执行完后，继续执行。

*** fileinput
#+begin_src python
给py文件行末追加行号的例子：
#numberlines.py
import fileinput
for line in fileinput.input(inplace=True):
    line = line.rstrip()
    num = fileinput.lineno()
    print '%-50s # %2i' % (line, num)
#+end_src
对自身进行编辑：
#+begin_src sh
  python  numberlines.py numberlines.py
#+end_src
#+BEGIN_VERSE
fileinput.input用于遍历多个输入流中的行，返回可迭代的对象。
可以用for循环，迭代对列表中的每一行进行处理。
#+END_VERSE
常用方法列表：
| filename    | 返回当前文件名                 |
| lineno      | 累积总行数                     |
| filelineno  | 返回当前文件行数               |
| isfirstline | 检查是否是文件第一行           |
| isstdin     | 当前文件为sys.stdin时返回true |
| nextfile    | 关闭当前文件，移动到下一个文件 |
| close       | 关闭序列，结束迭代             |

*** time
#+BEGIN_VERSE
包含9个整数的元组表示一个时间。
(年, 月, 日, 时, 分, 秒, 周(0~6), 一年中的第几天(366), 夏令时(0,1,-1))
重要的函数列表：
#+END_VERSE
| asctime([tuple])          | 将时间元组转换为字符串                       |
| strptime(string[, format] | 将字符串解析成时间元组                       |
| localtime([secs])         | 将1970年起(具体与平台有关)秒数转换为日期元组 |
| mktime(tuple)             | 将时间元组转换为秒数                         |
| sleep(secs)               | 休眠secs秒                                   |
| time()                    | 当前时间(1970年起的秒数，平台相关            |
*** random
#+BEGIN_VERSE
random生成的是伪随机数。要获取真正的随机性，需调用os模块的urandom函数
random模块常用函数列表：
#+END_VERSE
| random()                           | 返回[0,1)之间的随机实数n                           |
| getrandbits(n)                     | 以长整型的方式返回一个随机二进制数(位数为n)        |
| uniform(a, b)                      | 返回[a,b)之间的随机实数n                           |
| randrange([start,]  stop [,step] ) | 返回range[start, stop)中的随机整数，step必须为整数 |
| choice(seq)                        | 随机返回序列中的一个元素                           |
| shuffle(seq[, random])             | 将序列进行随机排列                                 |
| sample(seq, n)                     | 从序列中选出n个随机元素，同时保证不会选出同一个元素 |
*** shelve
简单的文件数据库方案。
#+begin_src python
  import shelve
  s = shelve.open('D:\\test.dat')#创建简单DB文件
  s['x'] = ['a', 'b', 'c']
  #s['x'].append('d')无效
  
  temp = s['x']
  temp.append('d')
  s['x'] = temp#必须给s['x']特性重新赋值修改才能写入DB文件
  s.close()
  
  s = shelve.open('D:\\test.dat')
  s
  #=>{'x' : ['a', 'b', 'c', 'd']}
#+end_src
pickle模块与shelve密切相关(自动序列化相关)。
*** re(regular expression)
重要函数列表：
| compile(pattern[, flags])            | 根据正则表达式字符串创建模式对象         |
| search(pattern, string[, flags])     | 在字符串中寻找与模式匹配的第一个子字符串 |
| findall(pattern, string              | 列出匹配的所有子字符串                   |
| match(pattern, string[, flags])      | 从给定字符串的开头开始匹配正则表达式 |
| split(pattern, string[, maxsplits=0] | 根据模式的匹配项分割字符串  |
| sub(pat, repl, string[, count=0])    | 将所有pat模式匹配的项用repl替换          |
| escape(string)                       | 将正则表达式特殊字符转义                 |
#+BEGIN_VERSE
complie可以实现一次性创建模式对象，其余方法不必在单独创建模式对象
如pat.search(string)、pat.match(string)
#+END_VERSE
**** 组的运用
#+BEGIN_VERSE
r'www\.(.+)\.com$'
组0表示整个字符串，组1表示(.+)的部分。
关于组的重要函数：
#+END_VERSE
| group([group1, ...]) | 获取给定子模式的匹配项 |
| start([group])       | 返回给定组的匹配项的开始位置 |
| end([group])         | 返回结束位置                 |
| span([group])        | 返回给定组的开始和结束位置   |
#+begin_src python
  m = match(r'www\.(.*)\..{3}', 'www.python.org')
  m.group(1)
  #=>'python'
  m.start(1)
  #=>4
  m.end(1)
  #=>10
  m.span(1)
  #=>(4, 10)
#+end_src
- 运用组进行字符串替换(有用)
#+begin_example
考虑将'*something*'替换成'<em>something</em>'
#+end_example
#+begin_src python
  emphasis_pattern = r'\*([^\*]+)\*'
  re.sub(emphasis_pattern, r'<em>\1</em>', 'Hello, *world*!')#\1代表组1
  #=>'Hello, <em>world</em>!'
#+end_src
- 陷阱
#+begin_src python
  emphasis_pattern = r'\*([.+])\*'
  re.sub(emphasis_pattern, r'<em>\1</em>', '*This* is a *test*')
  #=>'<em>This* is a *test</em>'
  
  #修改版正则表达式如下：
  emphasis_pattern = r'\*([.+?])\*'#组中加上一个? 表示尽可能少的匹配
#+end_src
**** Amazing Template System
#+begin_src python
  #template.py
  import fileinput, re
  field_pat = re.compile(r'\[(.+?)\]')
  scope = {}
  def replacement(match):
      code=match.group(1)
      try:
          return str(eval(code, scope))
      except SyntaxError:
          exec code in scope
          return ''
  
  lines = []
  for line in fileinput.input():
      lines.append(line)
  text = ' '.join(lines)
  print field_pat.sub(replacement, text)
#+end_src
#+begin_example
  #test.txt
  [x=2]
  [y=3]
  The sum of [x] and [y] is [x+y].
#+end_example
#+begin_src python
python template.py test.txt
#=>The sum of 2 and 3 is 5
#+end_src
- execfile()可直接执行含python语法定义的文本文件
- string模块中的Template类提供了非常完美的模板系统
**** 一些提示
- pattern选项(规定出现次数)
| (pattern)?     | pattern为可选项     |
| (pattern)*     | 允许重复0次或者多次 |
| (pattern)+     | 允许重复1次或者多次 |
| (pattern){m,n} | 允许重复m~n次       |
- 字符串开头和结尾
#+BEGIN_VERSE
^和$分别表示匹配开头和结尾。
'^http'只匹配http开头的字符串
#+END_VERSE
- 关于正则表达式的可读性(VERBOSE flag)
#+begin_src python
  emphasis_pattern = re.compile(r'''
      \*    #Beginning emphasis tag -- an asterisk
      (      #Begin group for capturing phrase
      [^\*]+    #Capture anything except asterisks
      )      #End group
      \*    #Ending emphasis tag
      ''', re.VERBOSE)
#+end_src
VERBOSE标记会忽略空白字符、tab、注释等等
*** ConfigParser
配置文件：
#+begin_example
[numbers]
pi: 3.1415926535897931
[messages]
greeting: Welcome
#+end_example
读取配置文件：
#+begin_src python
  from ConfigParser import ConfigParser
  CONFIGFILE = "testconfig.txt"
  config = ConfigParser()
  config.read(CONFIGFILE)
  print config.get('messages', 'greeting')
  print config.getfloat('numbers', 'pi') * (4**2)
#+end_src
*** Logging
#+begin_src python
  import logging
  logging.basicConfig(level=logging.INFO, filename='Mylog.log')
  logging.info('Starting program')
#+end_src
** 其他常用模块
| 模块名       | 说明                                     |
|--------------+------------------------------------------|
| cmath        | 复数运算                                 |
| webbrowser   | 可指定URL打开网页浏览器                  |
| logging      | 记录日志用                               |
| itertools    | 迭代工具                                 |
| bisect       | 实现了二元查找                           |
| functools    | 包含map, filter, reduce                  |
| operator     | 内建的基本运算方法都在此模块             |
| inspect      | 对象查看器                               |
| exceptions   | 异常处理                                 |
| webbrowser   | 网络浏览器相关                           |
| difflib      | 序列间的比较                             |
| hashlib      | 根据字符串计算'签名'，多用在加密和安全性 |
| csv          | 处理csv文件                              |
| datetime     | time不能满足要求时使用，接口更直观       |
| cmd          | 用它编写命令行解释器，可以自定义命令     |
测试分析模块
| timeit  | 衡量代码片段运行时间的工具，用于性能测试 |
| profile | 用于代码片段效率的全面分析               |
| trace   | 判断哪些代码执行了，哪些未执行           |
| dis     | 反汇编模块，查看对应的汇编代码                 |

** 集成其他语言模块
| 语言  | 解决方案   |
|-------+------------|
| C/C++ | SWIG       |
| .Net  | IronPython |
| Java  | JPython    |
** 可在PyPI上寻找python的最新的拓展包
* 文件
** Open
open(name[, module[, buffering]]) 返回一个文件对象
- name 文件名
- module 文件模式(可选)
| 'r' | 读模式                             |
| 'w' | 写模式                             |
| 'a' | 追加模式                           |
| 'b' | 二进制模式(可添加到其他模式中使用) |
| '+' | 读写模式(可添加到其他模式中使用)   |
默认为读模式
- buffering 缓冲(可选)
| 0             | 不使用内存缓冲，直接读写硬盘         |
| 1或者任何负数 | 使用内存缓冲，并且使用默认缓冲区大小 |
| 大于1的数     | 缓冲区大小(单位：字节)               |
** 文件对象的基本方法
*** 读和写
 在一次open-close的区块内，使用Write会重写文件内容。
#+begin_src python
  f = open('test.txt', 'w')
  f.write('Append text.')#重写文件内容
  f.write('Append text2.')#追加内容
  f.close
#+end_src
#+BEGIN_VERSE
读取操作read，不带参数时读取全文，带数字参数时，
读取指定的字符数，并且记录当前位置，下次调用read时，
从该位置继续读取。
#+END_VERSE
#+begin_src python
  f = open('test.txt', 'r')#r也可不加，默认是读取模式打开
  f.read(4)
  #=>'Appe'
  f.read()
  #=>'nd text.'
  f.close()
#+end_src
*** Pipe
管道符号的意义：将前一个命令的stdout作为下一个命令的stdin执行
#+begin_src python
  # somescript.py
  import sys
  text = sys.stdin.read()
  words = text.split()
  wordcount = len(words)
  print 'Wordcount:', wordcount
#+end_src
#+begin_example
  # somefile.txt
  abc def
  ghi
#+end_example
#+begin_src sh
  cat somefile.txt | python somescript.py
  #=>Wordcount:3
#+end_src
*** 随机访问(seek和tell)
| seek(offset[, whenrc]) | 当前位置移动到offset处, whenrc:默认0从文件开头计算偏移，1从前次的位置，2从文件结尾 |
| tell()                 | 返回当前文件的位置(返回值类型：长整型)                                                      |
*** 按行读写
- file.readline() 从当前位置开始直到一个换行符出现(换行符也会被读取)
#+BEGIN_VERSE
可选非负整数作为参数，指定可以读取的最大字符数。
readlines 返回包含所有行的列表
#+END_VERSE
- file.writelines() 参数可以是字符串序列或者None。没有writeline方法， 因为可以使用write。
*** 总是关闭文件
- 可在finally关闭文件
- Python 2.5中引入的with语句
#+begin_src python
  with open("somefile.txt") as somefile:
      do_something(somefile)
  #with语句块结束时，关闭somefile，等同于finally效果
#+end_src
事实上，支持__enter__和__exit__方法的对象，都能使用with语句。
** 迭代处理读取内容
先定义一个处理字符串的方法，后面都会用到：
#+begin_src python
  def process(string):
      print 'Processing: ', string
#+end_src
*** while循环处理每个字符
#+begin_src python
  f = open(filename)
  while True:
      char = f.read(1)
      if not char: break
      process(char)
  f.close()
#+end_src
*** while循环处理每一行
#+begin_src python
  f = open(filename)
  while True:
      line = f.readline()
      if not line: break
      process(line)
  f.close()
#+end_src
*** 一次性读取所有内容
文件不大时使用，非常方便。
#+begin_src python
  f = open(filename)
  for char in f.read():
      process(char)
  #or
  for line in f.readlines():
      process(line)
  f.close
#+end_src
*** fileinput
fileinput是既方便又没有一次性读取的内存占用问题的解决方案。
#+begin_src python
  import fileinput
  for line in fileinput.input(filename):
      process(line)
#+end_src
*** 2.2版起可迭代的文件对象
#+begin_src python
  f = open(filename)
  for line in f:
      process(line)
  f.close
#+end_src
可以更懒，只要open文件是只读模式， *关闭文件不是必须的！*
#+begin_src python
  for line in open(filename):
      process(line)
#+end_src
关闭文件交给python去完成了。
- stdin也是可迭代的类文件对象
- list(open(filename)与readlines达到的效果一样
- firstline, secondline = open(filename) 直接解包放入变量中
* 多线程
* GUI
** GUI库比较
| Tkinter    | 老牌GUI库，半标准。跨平台                 |
| wxPython   | 易用，代码清晰。跨平台。Tkinter的替代方案 |
| PythonWin  | 只支持windows平台                         |
| Java Swing | 只能用于Jython                            |
| PyGTK      | 使用GTK平台。                             |
| PyQt       | 使用QT平台。跨平台                                |
** wxPython
*** 控件布局图
   #+CAPTION: 
   #+ATTR_HTML: align="center"
   [[file:../resources/python/HierarchyOfElements.png]]
*** 自适应控件布局
   #+CAPTION: 
   #+ATTR_HTML: align="center"
   [[file:../resources/python/SizersExample.png]]
*** 简单文本编辑器示例
#+begin_src python
  import wx 
  #load button event handler
  def load(event):
      file = open(filename.GetValue())
      contents.SetValue(file.read())
      file.close()
  
  #save button event handler
  def save(event):
      file = open(filename.GetValue(), 'w')
      file.write(contents.GetValue())
      file.close()
  
  app = wx.App()#每个wxPython程序都是一个wx.App的实例
  win = wx.Frame(None, title = 'Simple Editor', size=(410,335))
  
  bkg = wx.Panel(win)
  
  loadButton = wx.Button(bkg, label='Open')
  loadButton.Bind(wx.EVT_BUTTON, load)
  
  saveButton = wx.Button(bkg, label='Save')
  saveButton.Bind(wx.EVT_BUTTON, save)
  
  filename = wx.TextCtrl(bkg)
  contents = wx.TextCtrl(bkg, style=wx.TE_MULTILINE | wx.HSCROLL)
  
  hbox = wx.BoxSizer()#自适应水平BoxSizer
  hbox.Add(filename, proportion=1, flag=wx.EXPAND)#proportion表示所占当前BoxSizer的比例
  hbox.Add(loadButton, proportion=0, flag=wx.LEFT, border=5)
  hbox.Add(saveButton, proportion=0, flag=wx.LEFT, border=5)
  
  vbox = wx.BoxSizer(wx.VERTICAL)#自适应垂直BoxSizer
  vbox.Add(hbox, proportion=0, flag=wx.EXPAND | wx.ALL, border=5)
  vbox.Add(contents, proportion=1,
           flag=wx.EXPAND | wx.LEFT | wx.BOTTOM | wx.Right, border=5)
  
  bkg.SetSizer(vbox)
  win.Show()
  
  app.MainLoop()#开始MainLoop，它的角色是处理事件
#+end_src
   #+CAPTION: 
   #+ATTR_HTML: align="center"
   [[file:../resources/python/SampleEditor.png]]
** Qt
* 数据库
** 连接
连接参数列表
| dsn      | 数据源名称(必填项) |
| user     | 用户名             |
| password | 用户密码           |
| host     | 主机名             |
| database | 数据库名           |
connect函数返回连接对象，连接对象支持的方法如下：
| close()    | 关闭连接                                 |
| commit()   | 提交挂起的事务，数据库不支持则什么也不做 |
| rollback() | 回滚挂起的事务(可能数据库不支持)         |
| cursor()   | 返回连接的游标对象                       |
** 查询
查询主要靠游标对象，cursor()返回游标对象，支持方法有：
| callproc(name[, params])   | 使用给定的名字(参数可选)调用已命名的数据库程序 |
| close()                    | 关闭游标                                       |
| execute(oper[, params])    | 执行SQL操作                                    |
| executemany(oper, pseq)    | 执行SQL序列                                    |
| fetchone()                 | 把查询结果中的下一行保存为序列，或者None       |
| fetchmany([size])          | 获取查询结果中的多行，默认尺寸arraysize        |
| fetchall()                 | 将(剩余)所有的行输出[序列的序列]               |
| nextset()                  | 跳至下一个可用的结果集                         |
| setinputsizes(sizes)       |  为参数预先定义内存区域                                   |
| setoutputsize(size[, col]) | 为获取的大数据值设定缓冲区尺寸                 | 
游标对象特性：
| description | 结果列描述的序列(只读) |
| rowcount    | 结果中的行数(只读)     |
| arraysize   | fetchmany中返回的行数，默认为1 |
** 数据类型
| ROWID    | 行ID列   |
| NUMBER   | 数字列   |
| BINARY   | 二进制列 |
| STRING   | 字符串列 |
| DATETIME | 日期/时间列 |
类型构造函数
| Date(year, month, day)          |
| Time(hour, minute, second)      |
| Timestamp(y, mon, d, h, min, s) |
| DateFromTicks(ticks)            |
| TimeFromTicks(ticks)            |
| TimestampFromTicks(ticks)       |
| Binary(string)                  |
** 示例
*** SQLite
#+begin_src sh
  sqlite3 test.db
  sqlite> create table tbl1(one varchar(10), two smallint);
  sqlite> insert into tbl1 values('hello!', 10);
  sqlite> insert into tbl1 values('goodbye', 20);
  sqlite> select * from tbl1;
  hello!|10
  goodbye|20
#+end_src
#+begin_src python
  import sqlite3
  conn = sqlite3.connect(r'test.db')
  curs = conn.cursor()
  curs.execute('Select * from tbl1')
   #=><sqlite3.Cursor object at 0x01D1DA60>
  curs.fetchall()
   #=>[(u'hello!', 10), (u'goodbye', 20)]
  curs.execute('Insert into tbl1 values (\'greeting!\', 40)')
  curs.fetchall()
  #=>[(u'hello!', 10), (u'goodbye', 20), (u'greeting!', 40)]
  conn.commit()
  conn.close()
#+end_src
* 网络
** socket
*** 构造
socket对象可选参数列表：
1) 地址族 默认socket.AF_INET
2) 流  默认socket.SOCK_STREAM(基于TCP) 或者 数据报 socket.SOCK_DGRAM(基于UDP)
3) 使用的协议 默认0
*** Server
- bind 绑定地址，参数为(host, port)元组
- listen 只有一个参数，指定允许排队等待的连接数目
- accept
#+BEGIN_VERSE
该方法会阻塞直到有客户端连接，而后返回一个(client, address)的元组。
当前accept处理完之后，会调用另一个accept()，即队列方式。
注意：使用这种方式称为同步网络编程。
#+END_VERSE
***  send, recv
- send 参数传入字符串
- recv 参数传入接收数据的最大字符数，1024是个较好的选择。
*** 简单示例
#+begin_src python
  #socket server test
  import socket
  s = socket.socket()
  host = socket.gethostname()
  port =1234
  
  s.bind((host, port))
  s.listen(5)
  while True:
      c, addr = s.accept()
      print 'Got connection from', addr
      c.send('Thank you for connectin')
      c.close()
#+end_src
#+begin_src python
  #socket client test
  import socket
  s = socket.socket()
  host = socket.gethostname()
  port = 1234
  
  s.connect((host, port))
  print s.recv(1024)
  s.close()
#+end_src
命令行调用结果：
- Server端
   #+CAPTION: 
   #+ATTR_HTML: align="center"
   [[file:../resources/python/SocketServerResult.png]]
- Client端：
   #+CAPTION: 
   #+ATTR_HTML: align="center"
   [[file:../resources/python/SocketClientResult.png]]

** urllib, urllib2
#+BEGIN_VERSE
这两个模块几乎可以把任何URL所指向的东西用做程序的输入。
urllib2更好一些，需要使用http验证、cookie或者要为自己的协议
写扩展程序时，使用urllib2。
#+END_VERSE
- urllib.urlopen(url) 返回一个类文件对象
- urllib.urlretrieve(url, filename) 将url获取的内容保存成本地文件
#+BEGIN_VERSE
注意：filename默认None，不指定的话，文件会临时存放在某位置，
用open函数可以打开它。清理临时文件，调用urlcleanup函数。
#+END_VERSE
urllib的其他一些功能：
| quote(string[, safe])      | 负责转移成url字符串 |
| quote_plus(string[, safe]) | 在quote的基础上，将空格转为'+' |
| unquote(string)            | 与quote相反                    |
| unquote_plus(string)       | 与quote_plus相反               |
| urlencode(query[, doseq]   | 把映射或者包含两个元素的元组的序列转换成URL格式字符串 |
** webservice
** 其他网络模块
| asyncore           | 异步socket处理程序             |
| asynchat           | asynchat的加强版               |
| cgi                | 基本的CGI支持                  |
| Cookie             | Cookie对象操作，主要用于服务器 |
| cookielib          | 客户端cookie支持               |
| email              | E-mail消息支持                 |
| ftplib             | FTP客户端模块                  |
| httplib            | HTTP客户端模块                 |
| imaplib            | IMAP4客户端模块                |
| mailbox            | 读取几种邮箱的格式             |
| nntplib            | NNTP客户端模块                 |
| poplib             | POP客户端模块                  |
| robotparser        | 支持解析Web服务器的robot文件   |
| SimpleXMLRPCServer | 简单的XML-RPC服务器            |
| smtpd              | SMTP服务器模块                 |
| smtplib            | SMTP客户端模块                 |
| telnetlib          | Telnet客户端模块               |
| urlparse           | 支持解析URL                    |
| xmlrpclib          | XML-RPC的客户端支持            |
* 测试
** 调试
*** 命令行方式
启动调试器python -m pdb test.py
*** IDLE方式
#+begin_src python
  __DEBUG = True
  def test():
      a = 5
      if __DEBUG:
          import pdb
          pdb.set_trace()
      b = 4
      print a + b
#+end_src
#+begin_example
  pdb.run('mymodule.test()')
  > <string>(1)<module>()
  (Pdb) c
  > d:\home\temp\mymodule.py(7)test()
  -> b = 4
  (Pdb) l
    2     def test():
    3         a = 5
    4         if __DEBUG:
    5             import pdb
    6             pdb.set_trace()
    7  ->     b = 4
    8         print a + b
    9     
  [EOF]
#+end_example
*** 常用指令
| 命令            | 用途                       |
| break 或 b      | 设置断点                   |
| continue   或 c | 继续执行程序               |
| list 或 l       | 查看当前行的代码段         |
| step 或 s       | 进入函数                   |
| return 或 r     | 执行代码直到从当前函数返回 |
| exit 或 q       | 中止并退出                 |
| next 或 n       | 执行下一行                 |
| pp              | 打印变量的值               |
| help            | 帮助                       |

** doctest
#+begin_src python
  #mytest.py
  def square(x):
      '''
      Square a number and returns the result.
  
      >>> square(2)
      4
      >>> square(3)
      8
      '''
      return x*x
  
  if __name__=='__main__':
      import doctest, mytest
      doctest.testmod(mytest)
#+end_src
以上例子，doctest.testmod会检查文档中'>>>'，并执行例子进行检查。
#+begin_example
$ python mytest.py

**********************************************************************
File "/home/chrischen/temp/mytest.py", line 7, in mytest.square
Failed example:
    square(3)
Expected:
    8
Got:
    9
**********************************************************************
1 items had failures:
   1 of   2 in mytest.square
***Test Failed*** 1 failures.
#+end_example
python mytest.py -v 可以获得更多输出。
** unittest
假设要写一个模块，my_math，测试其中计算乘积的函数product。<
#+begin_src python
  import unittest, my_math
  class ProductTestCase(unittest.TestCase):
      def testIntegers(self):
          for x in xrange(-10, 10):
              for y in xrange(-10, 10):
                  p=my_math.product(x, y)
                  self.failUnless(p == x*y, 'Integer multiplication failed')
  
      def testFloats(self):
          for x in xrange(-10, 10):
              for y in xrange(-10, 10):
                  x = x/10.0
                  y = y/10.0
                  p = my_math.product(x, y)
                  self.failUnless(p == x*y, 'Float multiplication failed')
      
      if __name__ == '__main__': unittest.main()
#+end_src
#+BEGIN_VERSE
unittest.main()负责实例化所有unittest.TestCase的子类，运行所有名字以test开头的函数。
failUnless检查结果给出错误提示。下表列出其他的检查方法：
#+END_VERSE
| assert_(expr[, msg]), failUnless                              | 如果表达式为假则失败                        |
| failIf(expr[, msg])                                           | 与assert相反                                |
| assertEqual(x, y[, msg]), failUnlessEqual                     | 两个值不同则失败                            |
| assertNotEqual(x, y[,msg]), failIfEqual                       | 两个值相同则失败                            |
| assertAlmostEqual(x,y[, places[,msg]]), failUnlessAlmostEqual | 类似于assertEqual，处理float的方式上不同    |
| assertNotAlmostEqual(x,y[, places[,msg]]), failIfAlmostEqual  | 与assertAlmostEqual相反                     |
| assertRaises(exc, callable, ...), failUnlessRaises            | 调用callable，引发exc异常，则成功；否则失败 |
| fail([msg])                                                   | 无条件失败                                       |
unittest模块会区分由异常引发的错误和调用failUnless而导致的失败。
** 代码检查
*** PyLint
#+BEGIN_VERSE
需先安装astng和logilab-common
安装方式都是：python setup.py install
使用pylint modulename：
python my_math
报告包含：Raw metrics、Statistics by type、Duplication、Messages by category、Messages、Global evaluation
PyLint的更多功能
#+END_VERSE
- pyreverse: an UML diagram generator
- symilar: an independent similarities checker
- *epylint*: Emacs and Flymake compatible Pylint
- pylint-gui: a graphical interface
#+BEGIN_VERSE
还可以选择PyChecker，更老牌的代码检查工具。
在Python中使用命令行工具的方式是使用subprocess模块。
#+END_VERSE
** 性能测试
*** profile模块(标准库)
#+begin_src python
  import profile
  from my_math import product
  profile.run('product(1, 2)')
#+end_src
结果如下：
#+begin_example
     4 function calls in 0.024 seconds
  
     Ordered by: standard name
  
     ncalls  tottime  percall  cumtime  percall filename:lineno(function)
          1    0.024    0.024    0.024    0.024 :0(setprofile)
          1    0.000    0.000    0.000    0.000 <string>:1(<module>)
          1    0.000    0.000    0.000    0.000 my_math.py:1(product)
          1    0.000    0.000    0.024    0.024 profile:0(product(1, 2))
          0    0.000             0.000          profile:0(profiler)
#+end_example
- 还可以以编程的方式分析结果
#+begin_src python
  import pstats
  p = pstats.Stats('my_math.profile')
#+end_src
对p对象进行分析即可。
- 另一个选择hotshot模块

** 其他可选工具
py.test, nose, trace.py(覆盖率), PyUnit(GUI单元测试)
* 发布程序
** 制作安装脚本
使用distutils模块编写setup.py
#+begin_src python
  from distutils.core import setup
  setup(name='my_math',
        version='1.0',
        description='A simple example',
        author='ChrisChen',
        py_modules=['my_math'])
#+end_src
#+begin_example
  python setup.py install
#+end_example
#+BEGIN_VERSE
setuptools项目基于distutils，但提供了更多的功能。
另外，目前为止，没有标准的Uninstall命令。需要手动卸载。
#+END_VERSE
** 制作安装包
- 使用命令制作压缩包：
#+begin_example
python setup.py sdist
#+end_example
- 关于MANIFEST文件
#+BEGIN_VERSE
在创建发布程序的时候，程序同时自动创建MANIFEST文件，该文件
包含所有文件的列表。
在此之前可以提供MANIFEST.in文件作为输入，此文件时MANIFEST 的模板。
可以用如下命令来指定需要包含的文件。
#+END_VERSE
#+begin_example
  include somedir/somefile.txt
  include somedir/*
#+end_example
- MANIFEST的更新
#+BEGIN_VERSE
当需发布的文件目录发生改变时，需要手动删除由发布程序自动生成的MANIFEST
文件，要不然发布程序会直接读取之前的MANIFEST文件，而不会重新生成。
#+END_VERSE
- Windows发布
#+begin_example
  python setup.py bdist --format=wininst
#+end_example
直接产生一个win32exe文件。注意用此方式发布的安装包非常基础。
- Linux RPM发布
#+begin_example
  python setup.py bdist --format=rpm
#+end_example
** py2exe
#+BEGIN_VERSE
py2exe直接将python运行环境打包，用户不必单独安装python解释器。
配合Inno Setup可完成“真正的安装程序”。
#+END_VERSE
* 实用的内建函数
| 函数                        | 说明                                              |
|-----------------------------+---------------------------------------------------|
| dir([obj])                  | 显示对象的属性，参数省略时，显示全局变量名        |
| help([obj])                 | 显示对象的文档字符串                              |
| int(obj)                    | 将一个对象转换为整形                              |
| len(obj)                    | 返回对象的长度                                    |
| open(fn, mode)              | 以相应的mode方式(r读w写)打开一个文件名为fn的文件  |
| range([start,] stop [,step] | 返回整数列表，起始值start，结束值stop-1，步长step |
| raw_input([str])            | 等待用户输入一个字符串，str为提示信息             |
| str(obj)                    | 将一个对象转换为字符串                            |
| type(obj)                   | 返回对象的类型(返回值本身是一个type对象)          |
** pass
      #+BEGIN_VERSE
      pass 函数什么事情都不做 用作预留占位符
      python空代码块是非法的。需要如下做：
      #+END_VERSE
      #+begin_src python
      if x==0:
          pass
      #+end_src
** del
      #+begin_src python
      x=1
      del x
      x
      #=>报错，del不但删除内容，也删除变量名
      x=1
      y=x
      del x
      y
      #=>1 原因：该情况del只删除了名称      
      #+end_src
** exec和eval
- exec
#+BEGIN_VERSE
exec执行字符串中的python语句
(风险极大，慎重，并且是很严重的安全漏洞)
#+END_VERSE
      #+begin_src python 
      exec "print 'Hello,world!'"     
      #+end_src
      字符串代码，单独一个命名空间
      #+begin_src python
      scope={}
      exec 'sqrt = 1' in scope
      scope['sqrt']
      #=>1
      len(scope)
      #=>2
      scope.keys()
      #=> ['sqrt', '__builtins__']      
      #+end_src
- eval
#+BEGIN_VERSE
eval会计算python表达式(字符串形式书写)，返回结果值
赋值语句不能使用eval(抛出SyntaxError)，只能用exec执行
#+END_VERSE    
      #+begin_src python
      eval(raw_input('Enter an arithmetic expression: '))      
      #+end_src

      eval同样也可使用命名空间
      #+begin_src python
      scope = {}
      scope['x'] = 2
      scope['y'] = 3
      eval('x * y', scope)
      #=>6      
      #+end_src

* 一些提示
*** 关于变量作用域
#+BEGIN_VERSE
python2.1以前，支持三种作用域，分别为局部、全局、内置作用域
2.1实现了对闭包的支持，引入了嵌套作用域，[[closure][查看更多信息]]。
变量的查找顺序为LEGB(Local, Enclosing, Global, Built-in)
#+END_VERSE
*** input与raw_input
#+BEGIN_VERSE
input只支持合法的python表达式
raw_input所有输入以字符串形式作为原始数据 尽可能使用raw_input
#+END_VERSE
*** 长字符串 跨越多行
#+BEGIN_VERSE
使用三个单引号或者三个双引号
''' blablabla
blablabla...'''
注：三引号内的单引号和双引号，可以不用转义符号
#+END_VERSE
*** 普通字符串忽略代码中的换行符
换行处加上\
#+begin_src python
  " 1 + 2 + \
  4 + 5"
  #=>"1 + 2 + 4 + 5"
#+end_src
*** 关于表示路径的转义
#+begin_src python
  r'C:\TestFolder\test.txt'
#+end_src
*** Unicode 字符串
#+begin_src python
  u'Hello World!'
#+end_src
在python 3.0以上，所有字符串都为unicode字符串
*** 使用逗号打印多个表达式
    #+begin_src python
    print 'Age', 42, '?'
    #+end_src
*** ASCII码转换
chr(n) & ord(c)
#+begin_src python
  chr(number)
  #=>对应的char
  ord(char)
  #=>对应的ASCII码编号
#+end_src
*** 检查特性是否为字符串
#+BEGIN_VERSE
通过和字符串拼接来检查参数类型是否为字符串
以下代码检查参数如果是字符串，是则抛出异常。
#+END_VERSE
#+begin_src python
  try: var + ' '
  except TypeError: pass
  else: raise TypeError
#+end_src
*** python虚拟环境
可使用virtualenv，适用情况：
1) 使用多个python版本进行开发，环境变量只能设一个。
2) site-packages在多人共享的开发机上，没有写入权限。
*** Emacs python IDE
我的选择：
| 使用模块                 | 说明                  | 备选方案        |
| auto-complete, yasnippet | 代码补全              | pymacs          |
| pylint+flymake           | 代码检查              | pyflakes        |
| ipython                  | 解释器                | python自带shell |
| dss-completion.el        | ipython下ac的自动补全 |                 |
| PyQt                     | GUI开发               | wxPython        |
| ropemacs                 | 重构工具              |                 |
*** 推荐工具包
ipython, pip, virtualenv, pylint(logilab_astng, logilab_common), py2exe, pyQt
- pip 常用命令
#+BEGIN_VERSE
pip install SomePackage==1.0
pip show --files SomePackage
pip list --outdated
pip install --upgrade SomePackage
pip uninstall SomePackage
#+END_VERSE
* Footnotes
[fn:1] 最常用的例子：'\\'.join(dirs)

[fn:2] range(1,100)实际是1~99

[fn:3] 函数经过编译的bytecode，实际上放在func.func_code.co_code中，dis模块对其做了解析，使其更容易阅读。

