#+TITLE: Common Lisp
#+KEYWORDS: Common Lisp
#+OPTIONS: H:2 toc:2 num:3 ^:nil
#+SETUPFILE: ../configOrg/level1.org
* 安装
Install Slime, SBCL
- windows下定义环境变量SBCL_Home
* 函数
** 参数
参数四种类型按解析顺序列出：必要形参，optional形参，rest形参，keyword形参。
*** 注意点
#+BEGIN_VERSE
避免&optional与&key混合使用，为保持更好的扩展性，应使用&key。
&rest与&key一同使用时，两者都会解析。例如：
#+END_VERSE
#+BEGIN_SRC lisp
  (defun foo (&rest values &key a b)
    (list rest a b)
  
  (foo :a 1 :b 2) -> ((:A 1 :B 2) 1 2)
#+END_SRC
** 返回值
使用RETURN-FROM从函数中间返回，需传入函数名。
#+BEGIN_SRC lisp
  (return-from foo return-value)
#+END_SRC

** 函数对象
以下两种形式都返回函数对象
#+BEGIN_SRC lisp
  #'foo
  (function foo)
#+END_SRC
调用函数对象，通过FUNCALL和APPLY
#+BEGIN_SRC lisp
  (foo 1 2 3)
  =
  (funcall #'foo 1 2 3)
#+END_SRC

*** 函数作为参数
- funcall
  #+BEGIN_SRC lisp
    (defun double-v (x) (* 2 x))
    
    (defun mapp (fn &rest values)
      (list (dolist (x values) (print (funcall fn x)))))
    
    (mapp #'(lambda (x) (+ x 1)) 1 2 3)
    (mapp (lambda (x) (+ x 1)) 1 2 3) 
    (mapp #'double-v 1 2 3)
  #+END_SRC

- apply
  
  apply第二个参数接受列表参数
  #+BEGIN_SRC lisp
    (defun foo (fn arg1 arg2 arg3)
      ...)
    
    (apply #'foo args)
    (apply #'foo #'fn args)
  #+END_SRC
  #+BEGIN_VERSE
  apply允许像第二种方式那样，“孤立”头几个参数，
  最后传入一个包含所有剩余参数的列表。
  #+END_VERSE
    
** lambda
*** funcall调用
#+BEGIN_SRC lisp
  (funcall #'(lambda (x y) (+ x y)) 2 3) -> 5
#+END_SRC

*** lambda作为函数名调用
#+BEGIN_SRC lisp
  ((lambda (x y) (+ x y)) 2 3) -> 5
#+END_SRC
#+BEGIN_VERSE
说明lambda表达式用在任何一个正常函数名可以出现的地方，
都是合法的。
实际不会如上述例子这么做。
#+END_VERSE
* 变量
** 词法(lexical)变量
*** Let
形式：(let (variable*) body-form*)
#+BEGIN_SRC lisp
  (let ((x 10) (y 20) z)
    ...)
#+END_SRC

- let声明的变量，作用域仅是let语句内。
- body中最后一个表达式返回的值，将作为let表达式的值返回。
**** let*
let*允许变量引用变量列表中早先引入的变量
#+BEGIN_SRC lisp
  (let* ((x 1)
         (y (+ x 1)))
    (list x y))
#+END_SRC
等同于嵌套的let
#+BEGIN_SRC lisp
  (let ((x 1))
    (let ((y (+ x 10)))
      (list x y))
#+END_SRC
*** 闭包
#+BEGIN_SRC lisp
  (let ((count 0) #'(lambda () (setf count (1+ count)))))
#+END_SRC
其中的匿名函数被称为一个闭包

** 动态(dynamic)变量
#+BEGIN_VERSE
有时被称为特殊(special)变量。通常用作全局变量。
其特殊是因为其作用域是动态作用域，运行时决定。

每个动态变量都会对应一个全局绑定关系栈，遇到局部重名定义或者新绑定时，
将新的关系压入栈，离开该作用时出栈。

声明有 *defvar* 和 *defparameter* 两种方式。
前者在发现变量已被定义时，不进行赋值。后者总是进行赋值。

*defvar* 还可以不使用初始值。这样的变量称为未绑定的(unbound)。

局部变量也可以声明为动态变量，使用 *declare* ，一般不常用。
#+END_VERSE

- defvar
  #+BEGIN_SRC lisp
    (defvar *count* 0
      "Count of ...")
  #+END_SRC

- defparameter
  #+BEGIN_SRC lisp
    (defparameter *gap* 0.001
      "Gaps of ...")
  #+END_SRC

*** 注意点
将全局对象的改变限定在函数体内，可使用 *let* 对全局对象进行重新绑定。
#+BEGIN_SRC lisp
  (defvar *x* 10)
  (defun foo () (print *x*))
  (defun bar ()
    (let (*x* 20) (foo))
    (foo))
  
  (bar)
  ->
  20
  10
#+END_SRC
** 常量
形式：(defconstant name initial-value [document-string])
- 可在名字后面加上“+”约定常量
  
  并没有*全局变量*这么通用。


** SETF
#+BEGIN_VERSE
形式：(setf place value)
setf是一个宏，赋值前先检查place的形式，并分析成适当的
底层操作来修改那个位置。

当该位置是变量时，展开成一个对特殊操作符setq的调用，
setq可以访问到词法和动态绑定。守旧的lisp程序员仍然使用setq进行赋值。

多值赋值：
(setf x 1 y 2)

setf返回最后一个被赋值的值
(setf x (setf y (random 10) z 3))
-> x == z == 3
#+END_VERSE

** 其他常用操作
假设x=20, y=5, z=15
*** ROTATEF
两两交换
#+BEGIN_SRC lisp
  (rotatef x y z)
  ->
  x=5, y=15, z=20
#+END_SRC

*** SHIFTF
#+BEGIN_SRC lisp
  (shiftf x y z)
  ->
  x=5, y=15, z=15
#+END_SRC
z之后没有元素了，保持原值。
