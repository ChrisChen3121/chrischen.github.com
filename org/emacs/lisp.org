#+TITLE: Common Lisp
#+KEYWORDS: common Lisp
#+OPTIONS: H:2 toc:2 num:2 ^:nil
#+LANGUAGE: zh-CN
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* 安装
Install Slime, SBCL
- windows 下定义环境变量 SBCL_Home
* 输入输出
** format
   #+BEGIN_SRC lisp
     (format t "~A plus ~A equals ~A. ~%" 2 3 (+ 2 3))
   #+END_SRC
** read
* 符号
  #+BEGIN_SRC lisp
    'Artichoke
  #+END_SRC
  符号（通常）不对自身求值，所以要是想引用符号，应该像上例那样用'引用它。
  - 符号的用途是作为变量的名字，符号必须要被引用，不然会被当作变量。

* 列表
  #+BEGIN_SRC lisp
    '(my 3 "Sons")
  #+END_SRC
  使用列表必须要引用，不然 Lisp 会以为这是个函数调用。
  #+BEGIN_SRC lisp
    (list 'my (+ 2 1) "Sons") ; 使用 list 函数创建列表
    ;=> (MY 3 "Sons")
  #+END_SRC
** 空列表
    () or nil
** 创建
*** cons
     #+BEGIN_SRC lisp
       (setf x (cons 'a nil))
     #+END_SRC
     - consp: 检查是否一个 object 为 cons 对象
*** make-list
** 索引
   - nth, nthcdr, last, car, cdr, first -> tenth
** 深拷贝
   - copy-list
   - copy-tree
   - substitute
   - subst

     替换子树里的所有元素
** map
*** mapcar
    #+BEGIN_SRC lisp
      (mapcar #'(lambda (x) (+ x 10))
              '(1 2 3))
      ;; => (11 12 13)
      (mapcar #'list
              '(a b c)
              '(1 2 3 4)) ; 多列表
      ;; => ((A 1) (B 2) (C 3))
    #+END_SRC
*** maplist
    #+BEGIN_SRC lisp
      (maplist #'(lambda (x) x)
               '(a b c))
      ;; => ((A B C) (B C) (C))
    #+END_SRC

* 函数
** 参数
   参数四种类型按解析顺序列出：必要形参，optional 形参，rest 形参，keyword 形参。
*** 注意点
    避免&optional 与&key 混合使用，为保持更好的扩展性，应使用&key。
    &rest 与&key 一同使用时，两者都会解析。例如：
    #+BEGIN_SRC lisp
      (defun foo (&rest values &key a b)
        (list rest a b)
      (foo :a 1 :b 2); -> ((:A 1 :B 2) 1 2)
    #+END_SRC
# ** 返回值
#    使用 RETURN-FROM 从函数中间返回，需传入函数名。
# #+BEGIN_SRC lisp
#   (return-from foo return-value)
# #+END_SRC

** 函数对象
   #+BEGIN_SRC lisp
     (function +)
     ;or
     #'+
     (apply #'+ '(1 2 3))
   #+END_SRC
   #'作为 function 的缩写
*** lambda
    #+BEGIN_SRC lisp
      (funcall #'(lambda (x y) (+ x y)) 2 3) ;=>5
      ((lambda (x y) (+ x y)) 2 3) ;=>5
    #+END_SRC

* 变量
** 词法(lexical)变量
*** Let
  #+BEGIN_SRC lisp
    (let ((x 10) (y 20))
      (+ x y))
  #+END_SRC
  - let 声明的变量，作用域仅是 let 语句内。
  - body 中最后一个表达式返回的值，将作为 let 表达式的值返回。

**** let*
     let*允许变量引用变量列表中早先引入的变量
     #+BEGIN_SRC lisp
       (let* ((x 1)
              (y (+ x 1)))
         (list x y))
     #+END_SRC
     等同于嵌套的 let
     #+BEGIN_SRC lisp
       (let ((x 1))
         (let ((y (+ x 10)))
           (list x y))
     #+END_SRC

*** 闭包
    #+BEGIN_SRC lisp
      (let ((count 0) #'(lambda () (setf count (1 + count)))))
    #+END_SRC
    其中的匿名函数被称为一个闭包

** 动态(dynamic)变量
   有时被称为特殊(special)变量。通常用作全局变量。
   其特殊是因为其作用域是动态作用域，运行时决定。

   每个动态变量都会对应一个全局绑定关系栈，遇到局部重名定义或者新绑定时，
   将新的关系压入栈，离开该作用时出栈。

   声明有 *defvar* 和 *defparameter* 两种方式。

*** defvar
  #+BEGIN_SRC lisp
    (defvar *count* 0
      "Count of ...")
  #+END_SRC
  - *defvar* 在发现变量已被定义时，不进行赋值
  - *defvar* 还可以不使用初始值。这样的变量称为未绑定的(unbound)。
  - 局部变量也可以声明为动态变量，使用 *declare* ，一般不常用。

*** defparameter
    #+BEGIN_SRC lisp
      (defparameter *gap* 0.001
        "Gaps of ...")
    #+END_SRC

*** defconstant
    #+BEGIN_SRC lisp
      (defconstant +limit 12345)
    #+END_SRC
    - 可在名字后面加上“+”约定为常量
    - 没有全局变量这么通用

*** boundp
    boundp 检查是否为一个全局变量

*** 局部重绑定
    将全局对象的改变限定在函数体内，可使用 *let* 对全局对象进行重新绑定。
  #+BEGIN_SRC lisp
    (defvar *x* 10)
    (defun foo () (print *x*))
    (defun bar ()
      (let (*x* 20) (foo))
      (foo))

    (bar)
    ;->
    ;20
    ;10
  #+END_SRC

** 赋值
   *setf* 可以用来给全局或局部变量赋值。
   #+BEGIN_SRC lisp
     (setf *glob* 98)
   #+END_SRC
   如果 setf 的第一个实参是符号（symbol），且符号不是某个局部变量的名字，则 setf 把这个符号设为全局变量
   #+BEGIN_SRC lisp
     (setf x (list 'a 'b 'c))
   #+END_SRC
   给列表元素引用赋值
   #+BEGIN_SRC lisp
     (setf (car x) 'n)
   #+END_SRC

** 类型
   #+BEGIN_SRC lisp
     (typep 27 'integer)
   #+END_SRC

** 等式
   *eql* 比较是否为同一对象， *equal* 比较对象内容。本质上 *equal* 若它的参数打印出的值相同时，返回真。

* 控制语句
** if
   if 是特殊的操作符。不能用函数来实现，因为实参在函数调用时永远会被求值，
   而 if 的特点是，只有最后两个实参的其中一个会被求值。if 的最后一个实参是选择性的。
   如果忽略它的话，缺省值是 nil。
** and & or
   and 和 or 是宏。宏和特殊的操作符一样，可以绕过一般的求值规则。
** do macro
   #+BEGIN_SRC lisp
     (do ((VAR INIT [STEP])...) (END-TEST [RESULT...]) BODY...)
   #+END_SRC
** dolist
   遍历列表
* 数据结构
** 二叉树
   car 代表左子数，cdr 代表右子数
