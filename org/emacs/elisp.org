#+TITLE: elisp
#+AUTHOR: ChrisChen
#+EMAIL: chrischen3121@gmail.com
#+OPTIONS: H:3 toc:2 num:2 ^:nil
#+LANGUAGE: en-US
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* Char Representation
  - ~?\U, ?\u, ?\x, ?\101~
  - ~?^I, ?\C-I, ?\M-I ?\S-I~

* Symbol
  Symbols are a fundamental type of data in Lisp and are used extensively. A
  symbol in Lisp is a stand-alone word.
** Creating Symbols
   #+BEGIN_SRC elisp
     (symbol-name 'foo)

     ;; returns a newly-allocated, uninterned symbol whose name is NAME (which must be a string)
     (make-symbol "foo")

     ;; returns the interned symbol.  If OBARRAY is omitted, the value of the global variable 'obarray' is used
     (intern "foo" other-obarray)

     ;; returns the symbol in OBARRAY whose name is NAME, or‘nil’ if OBARRAY has no symbol with that name.
     (intern-soft "foo")

     ;; map on obarray
     (mapatoms functions &optional obarray)

     ;; deletes SYMBOL from the obarray OBARRAY
     (unintern symbol obarray)
   #+END_SRC

* Sequence
  an ordered set of elements
** lists
   #+BEGIN_SRC elisp
     (eq () nil) ; -> t
     (A 2 "A") ; A list of three elements.
   #+END_SRC
   A cons cell is made for each element.  The CAR slot of the cons cell holds
   the element, and its CDR slot refers to the next cons cell of the list, which
   holds the next element in the list. The CDR slot of the last cons cell is set
   to hold 'nil'.

** arrays(fixed-length)
* Special Symbols
  ~'nil~, ~'t~

* Special Forms
  Special forms are something like built-in macros, examples: ~if~, ~progn~

* defs
  - ~defconst~: ~defconst symbol value [doc-string]~, should not be changed by the user or by other programs.
  - ~defvar~: ~defvar symbol [value [doc-string]]~, define global variables
  - ~defun~: define global functions
  - ~let~: define local variables
  - ~flet~: define local functions

** examples
   #+BEGIN_SRC elisp
     (defvar bar 23
       "The normal weight of a bar.")
     (defconst float-pi 3.141592653589793
       "The value of Pi.")

     ;; (let ((variable value)
     ;;       (variable value)
     ;;       …)
     ;;   body…)
     (let ((a 5)
           (b 6))
       (+ a b))

     ;; (flet ((function_name (arguments)
     ;;                       ...function body...))
     ;;   ...body...)
     (flet ((f (n)
               (+ n 10))
            (g (n)
               (- n 3)))
       (g (f 5)))
   #+END_SRC

* Association List(alist)
  #+BEGIN_SRC elisp
    (defvar *dict* '((key1 value1)
                     (key2 value2)
                     (key3 value3)))

    (assoc 'key1 *dict*) ; -> (key1 value1)
  #+END_SRC

* Quasiquoting[`]
  #+BEGIN_SRC elisp
    `(there are ,(+ 1 4) apples) ; -> there are 5 apples
    `(there are (+ 1 4) apples) ; -> there are (+ 1 4) apples
  #+END_SRC

* Function Operator[#']
  ~#'sqrt~ will be converted to ~(function sqrt)~ by Lisp reader

* Useful Functions & Marcos
  - ~ash~: shift
  - ~car~, ~cdr~, ~cons~, ~cadr~, ~cadadr~, ...
  - ~defvar~, ~setq~, ~setf~, ~let~
  - ~cl-flet~: defining local function, ~cl-labels~
  - ~()~, ~'()~, ~'nil~, ~nil~ are all false
  - ~mapcar~, ~apply~

** conditionals
   ~if~, ~when~, ~unless~, ~cond~, ~or~, ~case~, ~and~
*** ~when~, ~unless~
    Eliminates the pain of ~progn~
*** ~cond~
    The ~cond~ form is the classic way to do branching in
    Lisp. Through the liberal use of parentheses, it allows for an
    implicit ~progn~, can handle more than one branch, and can even
    evaluate several conditions in succession.
    - using last ~t~ condition to guarantee that at least the last
      branch will be evaluated.
*** ~case~
    - ~otherwise~ like ~default~ in other language

** ~push/assoc~ idiom
   The ~assoc~ command always returns the first item it finds in a list. Using
   the ~push~ and ~assoc~ commands together allows us to pretend that values in
   an alist are changing, while still preserving old values(keep history of all
   old values).
* Print & Read
** Print
   - ~print~: computer-friendly print
   - ~prin1~: like ~print~ but not print ~#/newline~
   - ~princ~: human-friendly print

** Read
   - ~read~: computer-friendly read
   - ~read-line~: human-friendly read(common lisp)

* Code & Data
  #+BEGIN_SRC elisp
    '(+ 1 2) ;data mode
    (+ 1 2) ;code mode
    (defvar *foo* '(+ 1 2))
    (eval *foo*)
  #+END_SRC
* List Functions
** ~cons~
   When you call ~cons~, the Lisp compiler typically allocates a small chunk of memory, the =cons cell=,
   that can hold two references to the objects being linked.
   #+BEGIN_SRC elisp
     (cons 'chicken 'cat) ; -> (CHICKEN . CAT) The dot in the middle makes this a cons cell
     (cons 'chicken 'nil) ; -> (CHICKEN) nil is a special symbol that is used to terminate a list in Lisp
     (cons 'chicken ())   ; -> (CHICKEN)
     (cons 'pork '(beef chicken))                 ; -> (PORK BEEF CHICKEN)
     (cons 'pork (cons 'beef (cons 'chicken ()))) ;-> what is really happening underneath
   #+END_SRC
   *In Lisp, a chain of cons cells and a list are exactly the same thing.*

** ~car~ and ~cdr~
   #+BEGIN_SRC elisp
     (car '(pork beef chicken))              ; -> PORK
     (cdr '(pork beef chicken))              ; -> (BEEF CHICKEN)
     (car (cdr '(pork beef chicken)))        ; -> BEEF
     (cadr '(pork beef chicken))             ; -> BEEF shortcut
   #+END_SRC

* Loop
  - ~loop~: loop forever
* Loading Process
- add to ~load-path~
- ~load-file~
- ~provide~, ~require~
** autoload
Things that can be auto-loaded generally involve anything "definable",
such as functions, macros, major or minor modes, groups, classes, and
so on.
#+BEGIN_SRC elisp
  (autoload 'some-function "some-file")

  ;;;###autoload
  (defun my-function ()
    ;; Source code...
    )

  ;;;###autoload
  (require 'helm)
#+END_SRC

** Eval after load
#+BEGIN_SRC elisp
  (with-eval-after-load 'helm
    ;; Code
    )
#+END_SRC

** use-package
