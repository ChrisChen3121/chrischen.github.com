#+TITLE: C++ Concurrency
#+KEYWORDS: c++
#+OPTIONS: H:3 toc:2 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+SETUPFILE: ../../org-templates/level-1.org
* Managing threads
** Daemon Threads
    #+BEGIN_SRC cpp
      std::thread t(do_background_work);
      t.detach();
    #+END_SRC

** Passing Arguments
   The arguments are *copied* into thread's internal storage by default. Use /std::ref/ to bind a reference argument.
   #+BEGIN_SRC cpp
     std::thread t(update_ref_data, std::ref(data)); // use std::move for move scenario
   #+END_SRC

** RAII(Resource Acquisition Is Initialization)
   Use RAII to avoid use of /try/catch/ blocks. Instances of std::thread are *movable*, but aren't *copyable*
   #+BEGIN_SRC cpp
     class ScopedThread {
     public:
       explicit ScopedThread(std::thread t) : t_(std::move(t)) {
         if (!t_.joinable())
           throw std::logic_error("No thread");
       }
       ~ScopedThread() { t_.join(); }
       ScopedThread(const ScopedThread &) = delete;
       ScopedThread &operator=(const ScopedThread &) = delete;

     private:
       std::thread t_;
     };

     ScopedThread t(std::thread(some_func));
   #+END_SRC

** hardware_concurrency
   #+BEGIN_SRC cpp
     std::cout << std::thread::hardware_concurrency() << "\n";
   #+END_SRC
* Sharing data
** Avoiding Deadlock
*** *std::lock*
    A function that can lock two or more mutexes at once without risk of deadlock
    #+BEGIN_SRC cpp
      std::lock(mu1, mu2);
      std::lock_guard<std::mutex> lock_a(mu1, std::adopt_lock);
      std::lock_guard<std::mutex> lock_b(mu2, std::adopt_lock);
    #+END_SRC
** Lazy Initialization
*** std::once_flag & std::call_once
     #+BEGIN_SRC cpp
       std::shared_ptr<some_resource> resource_ptr;

       void init_resource() {
         resource_ptr.reset(new some_resource);
       }

       void foo() {
         static std::once_flag resource_flag;
         std::call_once(resource_flag, init_resource());
         resource_ptr->do_something();
       }
     #+END_SRC

*** static(C++11)
    #+BEGIN_SRC cpp
      SomeClass &get_instance() {
        static SomeClass instance;
        return instance;
      }
    #+END_SRC

** Reader-writer Mutex
   - boost::shared_mutex
   - readers: shared_lock
   - writers: unique_lock

** More Approach
*** software transactional memory(STM)
    like transaction in database, this is an active research area.

* Paradigm
  - FP style

    Use future can be passed around between threads to allow the result of one computation to depend on the result of another, without any explicit access to shared data.

  - CSP(Communicating Sequential Processes)

    See atm example

* Synchronizing Concurrent Operations
** Condition Variables
   - example: Thread-safe Queue
   #+BEGIN_SRC cpp
      template <typename T> class threadsafe_queue {
      public:
        threadsafe_queue() {}
        threadsafe_queue(const threadsafe_queue &other) {
          std::lock_guard<std::mutex> lk(other.mu_);
          data_queue_ = other.data_queue_;
        }

        bool empty() const {
          std::lock_guard<std::mutex> lk(mu_);
          return data_queue_.empty();
        }

        void push(T new_value) {
          std::lock_guard<std::mutex> lk(mu_);
          data_queue_.push(new_value);
          data_cond_.notify_one(); // notify_all
        }
        void wait_and_pop(T &value) {
          std::unique_lock<std::mutex> lk(mu_);
          data_cond_.wait(lk, [this] { !data_queue_.empty(); }); // unlock->wait->lock
          value = data_queue.front();
          data_queue.pop();
        }

      private:
        mutable std::mutex mu_; // const member func like empty can lock mu_
        std::queue<T> data_queue_;
        std::condition_variable data_cond_;
      };
   #+END_SRC
** std::future<> & std::async
   only moveable, wrapped by unique_ptr
   #+BEGIN_SRC cpp
     std::future<data> result = std::async(find_the_answer);
     do_other_things();
     std::cout << result.get() << "\n";
   #+END_SRC
   options: std::launch::async, std::launch::deferred

*** std::shared_future
    copyable, wrapped by shared_ptr
    - operations on copied shared_future are thread-safe
    - std::future -> std::shared_future
    - access to the same shared state from multiple threads is safe if each thread does it through its own *copy* of a ~shared_future~ object.

** std::packaged_task<>
   std::packaged_task<> ties a future to a function or callable object.
   #+BEGIN_SRC cpp
     std::packaged_task<int(int, int)> some_task(task_func);
     auto result = some_task.get_future();
     std::thread t{std::move(some_task), a, b};
     result.get();
     t.join();
   #+END_SRC

*** when to use
    - used as a building block for thread pools
    - task management schemes

*** specialization of std::packaged_task<>
   #+BEGIN_SRC cpp
     template <> class packaged_task<std::string(std::vector<char> *, int)> {
     public:
       template <typename Callable> explicit packaged_task(Callable &&f);
       std::future<std::string> get_future();
       void operator()(std::vector<char> *, int);
     };
   #+END_SRC

** std::promise<>
   - std::promise<> stores a return value or exception
   std::promise<T> provides a means of setting a value (of type T), which can later be read through an associated std::future<T> object.
   The waiting thread could block on the future, while the thread providing the data could use the promise half of the pairing to set
   the associated value and make the future ready.
   #+BEGIN_SRC cpp
     void do_work(std::promise<int> promise) {
       prepare_data();
       promise.set_value(42);
     }

     void do_work(std::promise<void> barrier) {
       std::this_thread::sleep_for(std::chrono::seconds(1));
       barrier.set_value();
     }

     int main() {
       std::promise<int> promise;
       std::future<int> future = promise.get_future();
       std::thread worker(do_work, std::move(promise));
       future.wait();
       std::cout << future.get() << "\n";
       worker.join();

       // Demonstrate using promise<void> to signal state between threads.
       std::promise<void> barrier;
       std::future<void> barrier_future = barrier.get_future();
       std::thread new_work_thread(do_work, std::move(barrier));
       barrier_future.wait();
       new_work_thread.join();
       return 0;
     }
   #+END_SRC
*** set_exception()
    #+BEGIN_SRC cpp
      try {
        some_promise.set_value(calculate_value());
      } catch (...) {
        some_promise.set_exception(std::copy_exception(std::logic_error("foo")));
        //alternative some_promise.set_exception(std::current_exception());
      }
    #+END_SRC
    - std::current_exception()
    - prefer the ~copy_exception~ way: Not only does it simplify the code, but it also provides the compiler with greater opportunity to optimize the code.
    - a call to get() rethrows that stored exception

* Useful tools
  - std::ref
  - std::distance(iter1, iter2)
  - std::advance(iter, distance)
  - list::splice:
  - std::partition
  - std::ostream_iterator
** std::mem_fn
   useful for std algorithms
   #+BEGIN_SRC cpp
     class SomeClass {
       void some_func() {}
     };

     auto some_func = std::mem_fn(&SomeClass::some_func);
     SomeClass s;
     some_func(s);
     std::some_algo(iter1, iter2, some_func);
   #+END_SRC

** Time Facilities
*** Clocks
**** now
     #+BEGIN_SRC cpp
       auto time_point = std::chrono::some_clock::now();
     #+END_SRC

**** tick period
     - std::ratio<1, 25> ticks every 1/25 seconds
     - std::ratio<5, 2> ticks every 2.5 seconds

     There’s *no guarantee* that the observed tick period in a given run of the program matches the specified period for that clock.

**** steady_clock
     If a clock ticks at a uniform rate and can’t be adjusted, the clock is said to be a steady clock.
     Steady clocks are important for *timeout calculations*.(system_clock can be changed)

**** high
     /high_resolution_clock/ provides the smallest possible tick period of all the library-supplied clocks.

*** Durations
    std::duration<representation, std::ratio<>>
    - example millisecond duration: std::chrono::duration<double, std::ratio<1,1000>>
    - std::chrono::duration_cast<>: floor(high_resolution)

    The time for a duration-based wait is measured using a steady clock internal to the library, even if the system clock was adjusted during the wait

*** Time points
    std::chrono::time_point<clock, duration>
    - time_since_epoch() returns a duration value specifying the length of time since the clock epoch to that particular time point

*** wait_for & wait_until
    - Clock adjustments are taken into account by the /wait_until/
