#+TITLE: Operating Systems
#+KEYWORDS: OS
#+OPTIONS: H:3 toc:2 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SETUPFILE: ../../org-templates/level-1.org
* Represeting Infomation
** Integer
*** Integer Limits
    $$TMax_w = 2^{w-1}-1\quad TMin_w = - 2^{w-1}\quad UMax_w = 2^w-1\quad UMin_w = 0$$
*** Binary2Integer
    $$B2U_w(\overrightarrow{x})\doteq\sum_{i=0}^{w-1}x_i2^i$$
**** Twos' Complement
     $$B2T_w(\overrightarrow{x})\doteq-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$$
**** Sign-Magnitude
     - used in floating number
     $$B2S_w(\overrightarrow{x})\doteq(-1)^{x_{w-1}}\cdot(\sum_{i=0}^{w-2}x_i2^i)$$

*** Transform between signed and unsigned
**** $T2U_w(x)$
     $$B2U_w(\overrightarrow{x})-B2T_w(\overrightarrow{x})=x_{w-1}(2^{w-1}+2^{w-1})=x_{w-1}2^w$$
     $$B2U_w(\overrightarrow{x})=x_{w-1}2^w + B2T_w(\overrightarrow{x})$$
     Let $\overrightarrow{x}=T2B_w(x)$ , Then：
     $$T2U_w(x)=B2U_w(T2B_w(x)) = x_{w-1}2^w + B2T_w(T2B_w(x)) = x_{w-1}2^w + x$$
     bit $x_{w-1}$ is the sign bit, giving:
     $$T2U_w(x) = \begin{cases}
     x+2^w, & x\le 0 \\
     x, & x>0 \\
     \end{cases}$$
**** $U2T_w(x)$
     $$U2T_w(u)=B2T_w(U2B_w(u))=-u_{w-1}2^w+u$$
     $$U2T_w(u) = \begin{cases}
     u, & u<2^{w-1} \\
     u - 2^w, & u\ge2^{w-1} \\
     \end{cases}$$

*** Small size to big size
     1) Change the size(fill 0 or 1 depends on signed/unsigned)
     2) Convert signed/unsigned

*** Big size to small size
    - Unsigned big2small：$B2U_k([x_{k-1},x_{k-2},\cdots,x_0])=B2U_w([x_{w-1},x_{w-2},\cdots,x_0])\mod 2^k$
    - Signed big2small：$B2T_k([x_{k-1}, x_{k-2}, \cdots, x_0])=U2T_k(B2U_k([x_{k-1},x_{k-2},\cdots,x_0])$

** Floating Point
*** Fractional Binary Numbers
**** Fractional Decimal
     $$d=\sum_{i=-n}^m10^i\times{d_i}$$
     Consider Fractional decimal $12.34_{10}$
     $$ 1\times{10^1} + 2\times{10^0} + 3\times{10^{-1}} + 4\times{10^{-2}}=12\frac{34}{100}$$
**** Fractional Binary
     $$b=\sum_{i=-n}^m2^i\times{b_i}$$
     eg:  $101.11_2$
     $$ 1\times{2^2} + 0\times{2^1} + 1\times{2^0} + 1\times{2^{-1}} + 1\times{2^{-2}} = 5\frac{3}{4}$$
*** IEEE Floating-Point
    $$V=(-1)^{s}\times{M}\times{2^E}$$
    - sign s: negative(s=1) positive(s=0), Sign-Magnitude
    - significand M: a fractional binary number, /n/ bits
    - exponent E: weights the value by a power of 2, /k/ bits
    - $Bias = 2^{k-1} -1$
**** float(single-precision)
     s=1, k=8, n=23 yielding a 32-bit representation, Bias = 127
**** double(double-precision)
     s=1, k=11, n=52, yielding a 64-bit representation, Bias = 1023
**** Nomalized Values
     Condition: exp is not all zeros(0) & not all ones(255 for single, 2047 for double)
     | s | exp neither all 1 nor all 0 | frac |
     $E = e - Bias$, e is the unsigned number, Hance, the range of $E$ is
     - $-126\leq{E}\leq{+127}$ for single
     - $-1022\leq{E}\leq{+1023}$ for double

     $M=1+f$ where $0\leq{f}<1$ having binary representation $0.f_{n-1}...f_1f_0$
     so that, M is in the range $1\leq{M}<2$ This implied leading 1 is a trick
     for getting an additional bit of precision for free.
**** Denormalized Values
     Condition: exp is all zeros
     | s | all 0 | frac |
     Serve two purposes:
     - represent 0 (all bits are zero)
     - represent numbers that are very close to 0.0

**** Spacial Values
     Condition: exp is all ones
     - infinity
       | s | all 1 | 0 |
     - NaN
       | s | all 1 | $\ne 0$ |

**** Examples
     8-bit floating-point format
| Description     | bits       |  e |  E | $2^E$          | f             | M              | $2^E\times{M}$   | V               |  Decimal |
|-----------------+------------+----+----+----------------+---------------+----------------+------------------+-----------------+----------|
| Zero            | 0 0000 000 |  0 | -6 | $\frac{1}{64}$ | $\frac{0}{8}$ | $\frac{0}{8}$  | $\frac{0}{512}$  | 0               |      0.0 |
| Smallest pos.   | 0 0000 001 |  0 | -6 | $\frac{1}{64}$ | $\frac{1}{8}$ | $\frac{1}{8}$  | $\frac{1}{512}$  | $\frac{1}{512}$ | 0.001953 |
| Largest denorm. | 0 0000 111 |  0 | -6 | $\frac{1}{64}$ | $\frac{7}{8}$ | $\frac{7}{8}$  | $\frac{7}{512}$  | $\frac{7}{512}$ | 0.005859 |
| Smallest norm.  | 0 0001 000 |  1 | -6 | $\frac{1}{64}$ | $\frac{0}{8}$ | $\frac{8}{8}$  | $\frac{8}{512}$  | $\frac{1}{64}$  | 0.013672 |
| One             | 0 0111 000 |  7 |  0 | 1              | $\frac{0}{8}$ | $\frac{8}{8}$  | $\frac{8}{8}$    | 1               |      1.0 |
| Largest norm.   | 0 1110 111 | 14 |  7 | 128            | $\frac{7}{8}$ | $\frac{15}{8}$ | $\frac{1920}{8}$ | 240             |    240.0 |
| Infinity        | 0 1111 000 |  - |  - | -              | -             | -              | -                | $\infty$        |        - |

* Manipulating Infomation
** Integer arithmatic
*** Unsigned Addition
\[ x+^u_wy= \left\{
  \begin{array}{l l}
    x+y & \quad x+y<2^w\\
    x+y-2^w & \quad 2^w\le x+y<2^{w-1}
   \end{array} \right.\]
Same as  $x+^u_wy=(x+y) \mod 2^w$
#+BEGIN_VERSE
When overflow occured, $sum=x+y-2^w$
Because $y < 2^w$
We have $sum = x +(y-2^w) < x$
sum < x means it did overflow.
#+END_VERSE
*** Unsigned Negation
\[ -^u_wx= \left\{
  \begin{array}{l l}
    x & \quad x=0\\
    2^w-x & \quad x>0
   \end{array} \right.\]
*** Two's Complement Addition
1) from signed operand to unsigned
2) excute unsigned addition(truncate the overflow)
$$x+^t_wy\doteq U2T_w(T2U_w(x)+^u_wT2U_w(y))$$
$$=U2T_w[(x_{w-1}2^w+x+y_{w-1}2^w+y) \mod 2^w]$$
\[ x+^t_wy= \left\{
  \begin{array}{l l}
    x+y-2^w & \qquad x+y\ge 2^{w-1} \quad Positive \ overflow\\
    x+y & \qquad -2^{w-1}\le x+y<2^{w-1} \quad Normal\\
    x+y+2^w & \qquad x+y<-2^{w-1} \quad Negative \ overflow
   \end{array} \right.\]
Example:
|      $x$ |      $y$ |      $x+y$ | $x+^t_4y$ |
|----------+----------+------------+-----------|
| -8(1000) | -5(1011) | -13(10011) |   3(0011) |
*** Two's Complement Negation
\[ -^t_wx= \left\{
  \begin{array}{l l}
    -2^{w-1} & \qquad x=-2^{w-1} \\
    -x & \qquad x>-2^{w-1} \\
   \end{array} \right.\]
Two Clever Ways:
**** One Way
1) complement the bits
2) increment by 1
|       x |       ~x | incr(~x) |
|---------+----------+----------|
| 0101(5) | 1010(-6) | 1011(-5) |
**** Another Way
Condition: $x\neq 0$
1) Split the bit vector into two parts.(the boundary is the rightmost 1)
2) Complement each bit on the left part.
| x            | -x          |
|--------------+-------------|
| /101/ 1 (-5) | /010/ 1 (5) |
*** Unsigned Mutliplication
    $0\le x,y\le 2^{w}-1$ Hence,
    $$0\le x\cdot y\le2^{2w}-2^{w+1}+1$$
    This could require as many as 2w bits to represent.
    $$ x \times ^u_wy=(x\cdot y)\ mod\ 2^w$$
*** Two's Complement Multiplication
    $-2^{w-1}\le x,y \le 2^{w-1}-1$ Hence,
    $$ -2^{2w-2}+2^{w-1} \le x\cdot y \le 2^{2w-2}$$
    Also need 2w bits to represent.
    $$ x \times ^t_wy = U2T_w((x\cdot y)\ mod\ 2^w) $$
*** Reduce Mutiplication by shift and addition
    Motivation Mutiplication requires 10 or more clock cycles. shift and addition requires 1 clock cycle.
    $$ x \times ^t_w2^k  = x << k$$
**** two forms:
    $$(x << n) + (x << n-1) + \dots + (x << m)$$
    $$(x << n+1) - (x << m)$$
    - eg: $14$ can be rewrite as $(x<<4) - (x<<1)$ or $(x<<3) + (x<<2) + (x<<1)$

    Assuming additions and subtractions have comparable cost, then we have:
    - $n = m$ , use Form1.
    - $n = m+1$ , use either Form1 or Form2.
    - $n > m+1$ , use Form2.
*** Reduce Division by shift
    Division require 30 or more clock cycles.
**** Logical Shift
     $x \div 2^k = x>>k$ where $0 \le{k} < w$ and $x\ge 0$

**** Arithmatic Shift
     $x \div 2^k = x>>k$ where $0\le{k} < w$
     Follow the above, we'll find -7/2 yield -4 not -3, corrected by 'biasing' the value before shifting.
     - $x \div 2^k = (x+ 2^k - 1) >> k$ where $x < 0$
** Floating Operation
*** Round
    - Round-to-even eg: 1.5 approximate 2, 2.5 approximate 2 (DEFAULT) avoid statistical bias
    - Round-toward-zero eg:-1.5 approximate -1, 1.5 approximate 1
    - Round-down eg: 1.5 approximate 1
    - Round-up eg: 1.5 approximate 2
*** Arithmatic Operation
    $$x+^fy=Round(x+y)$$
    - Compute $x+y$ first, then round
* Program Structure
** Processor State
*** program counter(%eip)
    Indicates the address in memory of the next instruction to be executed
*** integer register
    Contain eight named locations storing 32-bit values
*** condition code register
    Hold status information about the most recently executed arithmetic or logical instruction
*** floating-point register
    Store floating-point data

** Asm
   #+BEGIN_SRC sh
     gcc -Og -S xxx.c # c -> asm
     objdump -d xxx.o # obj -> asm: disassemble
   #+END_SRC

** Data Formats
   | C declaration | Intel            | Assembly code suffix | Size(bytes) |
   |---------------+------------------+----------------------+-------------|
   | char          | Byte             | b                    |           1 |
   | short         | Word             | w                    |           2 |
   | int           | Double word      | l                    |           4 |
   | long          | Quad word        | q                    |           8 |
   | char *        | Quad word        | q                    |           8 |
   | float         | Single precision | s                    |           4 |
   | double        | Double precision | l                    |           8 |

** Interger Registers
   | 63-32 | 31-16 | 15---8 | 7---0 | use             |
   |-------+-------+--------+-------+-----------------|
   | %rax  | %eax  | %ax    | %al   | return value    |
   | %rbx  | %ebx  | %bx    | %bl   | callee reserved |
   | %rcx  | %ecx  | %cx    | %cl   | 4th argument    |
   | %rdx  | %edx  | %dx    | %dl   | 3th argument    |
   | %rsi  | %esi  | %si    | %sil  | 2nd argument    |
   | %rdi  | %edi  | %di    | %dil  | 1st argument    |
   | %rbp  | %ebp  | %bp    | %bpl  | callee reserved |
   | %rsp  | %esp  | %sp    | %spl  | stack pointer   |
   | %r8   | %r8d  | %r8w   | %r8b  | 5th argument    |
   | %r9   | ...   | ...    | ...   | 6th argument    |
   | %r10  | ...   | ...    | ...   | caller reserved |
   | %r11  | ...   | ...    | ...   | caller reserved |
   | %r12  | ...   | ...    | ...   | callee reserved |
   | %r13  | ...   | ...    | ...   | callee reserved |
   | %r14  | ...   | ...    | ...   | callee reserved |
   | %r15  | ...   | ...    | ...   | callee reserved |

** Operand Specifiers
*** Access from three sources
    1. immediate: for constant values
    2. register: denotes the contents of one of the registers. $R[E_a]$
    3. memory: memory location. $M[Addr]$

    | Form               | Operand Value                 | Access way          |
    |--------------------+-------------------------------+---------------------|
    | \(\$Imm\)          | $Imm$                         | Immediate           |
    | $r_a$              | $R[r_a]$                      | Register            |
    | $Imm$              | $M[Imm]$                      | Absolute            |
    | $(r_a)$            | $M[R[r_a]]$                   | Indirect            |
    | $Imm(r_b)$         | $M[Imm+R[r_b]]$               | Base + displacement |
    | $(r_b,r_i)$        | $M[R[r_b]+R[r_i]]$            | Indexed             |
    | $Imm(r_b,r_i)$     | $M[Imm+R[r_b]+R[r_i]]$        | Indexed             |
    | $(,r_i,s)$         | $M[R[r_i]\cdot s]$            | Scaled Indexed      |
    | $Imm(,r_i,s)$      | $M[Imm+R[r_i]\cdot s]$        | Scaled Indexed      |
    | $(r_b, r_i, s)$    | $M[R[r_b]+R[r_i]\cdot s]$     | Scaled Indexed      |
    | $Imm(r_b, r_i, s)$ | $M[Imm+R[r_b]+R[r_i]\cdot s]$ | Scaled Indexed      |

** Basic Operations
*** Data Movement
    | *MOV*  S,D | D \leftarrow S |
    |------------+----------------|
    | movb       | byte           |
    | movw       | word           |
    | movl       | double word    |
    | movq       | quad word      |
    | movabsq    | abs quad word  |

**** small src $\to$ large dest
     - ZeroExtend
       | *MOVZ*  S, R | R\leftarrow ZeroExtend(S) |
       eg: movzbl, movzbw, movzwl, movzbq, movzwq
     - SignExtend
       | *MOVS*  S, R | R\leftarrow SignExtend(S) |
       eg: movsbw, movsbl, movswl, movsbq, movswq, movslq, cltq
       - cltq: %rax $\leftarrow$ SignExtend(%eax)

**** push onto the program stack
     *pushq S*
     1. R[%rsp] $\leftarrow$ R[%rsp] - 8
     2. M[R[%rsp]] $\leftarrow$ S
     #+BEGIN_SRC asm
       subq $8,%rsp // Decrement stack pointer
       movq %rbp,(%rsp) //Store %rbp on stack
     #+END_SRC

**** pop from the program stack
     *popq D*
     1. D $\leftarrow$ M[R[%rsp]]
     2. R[%rsp] $\leftarrow$ R[%rsp + 8]
     #+BEGIN_SRC asm
       movq (%rsp),%rax //Read %rax from stack
       addl $4,%esp  //Increment stack pointer
     #+END_SRC

*** Arithmetic & Logical Operations
**** unary operations
     | leaq  S,D | D <- &S             |
     | inc D     | D <- D+1            |
     | dec D     | D <- D-1            |
     | neg D     | D <- -D             |
     | not D     | D <- ~D(complement) |
**** binary operations
     | binary op | second operand: src & dest |
     | add S,D   | D <- D+S                   |
     | sub S,D   | D <- D-S                   |
     | imul S,D  | D <- D*S                   |
     | xor S,D   | D <- D^S                   |
     | or S,D    | D <- D\vert{}S             |
     | and S,D   | D <- D&S                   |
**** shift operations
     | sal k,D | D <- D<<k                   |
     | shl k,D | D <- D<<k(same as sal)      |
     | sar k,D | D <- D>>k(arithmetic shift) |
     | shr k,D | D <- D>>k(logical shift)    |

*** Special Arithmetic Operations
    imul also support one-operand operaion.
    | imulq S | R[%edx]:R[%eax] <- S*R[%eax] (Signed)                |
    | mulq S  | R[%edx]:R[%eax] <- S*R[%eax] (Unsigned)              |
    | clto    | R[%edx]:R[%eax] <- SignExtend(R[%eax]) (-> 16 bytes) |
    | idivq S | R[%edx] <- R[%edx]:R[%eax] mod S;(Signed)            |
    |         | R[%eax] <- R[%edx]:R[%eax] / S;(Signed)              |
    | divq S  | like idivq S (Unsigned)                              |

** Control
*** Condiction Register
**** condiction flags
     | CF | carry flag            |
     | ZF | zero flag             |
     | SF | sign flag(neg number) |
     | OF | overflow flag         |
     - Example: For t=a+b,
      | CF | (unsigned)t < (unsigned)a  | Unsigned Overflow |
      | ZF | (t == 0)                   | Zero              |
      | SF | (t < 0)                    | Negative          |
      | OF | (a<0 == b<0)&&(t<0 != a<0) | Signed Overflow   |
**** CMP & TEST instructions
     These two instructions that set the condiction code without updating their destination.
     | cmp $S_1,S_2$  | $S_2-S_1$     | cmpb, cmpw, cmpl, cmpq     |
     | test $S_1,S_2$ | $S_1$ & $S_2$ | testb, testw, testl, testq |
*** Accessing the Condition Codes
    There are three common ways of using the condition codes.
**** SET Instruntions
     - set directly
       | Instruction	 | Synonym	 | Effect   | Set condition      |
       |---------------+-----------+----------+--------------------|
       | sete D        | setz      | D <- ZF  | Equal/zero         |
       | setne D       | setnz     | D <- ~ZF | Not Equal/not zero |
       | sets D        |           | D <- SF  | Negative           |
       | setns D       |           | D <- ~SF | Nonnegative        |
     - signed group
       | setg D  | setnle | D <- ~(SF^OF) & ~ZF   | >  |
       | setge D | setnl  | D <- ~(SF^OF)         | >= |
       | setl D  | setnge | D <- SF^OF            | <  |
       | setle D | setnge | D <- (SF^OF) \vert ZF | <= |
     - unsigned group
       | seta D  | setnbe | D <- ~CF & ~ZF    | >  |
       | setae D | setnb  | D <- ~CF          | >= |
       | setb D  | setnae | D <- CF           | <  |
       | setbe D | setna  | D <- CF \vert  ZF | <= |
**** JUMP instructions
     - jump
       | Instruction  | Synonym       | Condition |
       |--------------+---------------+-----------|
       | jmp Label    | direct jump   | 1         |
       | jmp *Operand | indirect jump | 1         |
       | je L         | jz            | ZF        |
       | jne L        | jnz           | ~ZF       |
       | js L         |               | SF        |
       | jns L        |               | ~SF       |
     - signed group
       | jg L  | jnle | ~(SF^OF)&~ZF     | >  |
       | jge L | jnl  | ~(SF^OF)         | >= |
       | jl L  | jnge | SF^OF            | <  |
       | jle L | jng  | (SF^OF)\vert{}ZF | <= |
     - unsigned group
       | ja L  | jnbe | ~CF & ~ZF   | >  |
       | jae L | jnb  | ~CF         | >= |
       | jb L  | jnae | CF          | <  |
       | jbe L | jna  | CF\vert{}ZF | <= |
**** conditional MOVE instructions
     | Instruction | Synonym | Condition        |
     |-------------+---------+------------------|
     | cmove S, R  | cmovz   | ZF               |
     | cmovne      | cmovnz  | ~ZF              |
     | cmovs       |         | SF               |
     | cmovns      |         | ~SF              |
     | cmovg       | cmovnle | ~(SF^OF)&~ZF     |
     | cmovge      | cmovnl  | ~(SF^OF)         |
     | cmovl       | cmovnge | SF^OF            |
     | cmovle      | cmovng  | (SF^OF)\vert{}ZF |
     | cmova       | cmovnbe | ~CF&~ZF          |
     | cmovae      | cmovnb  | ~CF              |
     | cmovb       | cmovnae | CF               |
     | cmovbe      | cmovna  | CF\vert{}ZF      |

*** Statements in C
**** if
     - General in C
       #+BEGIN_SRC text
         if (test-expr)
            then-statement
         else
            else-statement
       #+END_SRC
     - normal form with goto statement
       #+BEGIN_SRC text
             t = test-expr;
             if (t)
                goto true;
             else-statement
             goto done;
         true:
             then-statement
         done:
       #+END_SRC
     - assembly form
       #+BEGIN_SRC text
             t = test-expr;
             if (!t)
                goto false-label;
             then-statement
             goto done;
         false-label:
             else-statement
         done:
       #+END_SRC
     - when there is no else-statement.
       #+BEGIN_SRC text
             t = test-expr;
             if (!t)
                goto done;
             then-statement
         done:
       #+END_SRC

**** ? condtion
     #+BEGIN_SRC text
       v = test-expr ? then-expr : else-expr;
     #+END_SRC
     - standard form
      #+BEGIN_SRC text
            if (!test-expr)
                goto false;
            v = then-expr;
            goto done;
        false:
            v = else-expr;
        done:
      #+END_SRC
    - more abstract form
      #+BEGIN_SRC text
        vt = then-expr;
        v = else-expr;
        t = test-expr;
        if (t) v = vt;
      #+END_SRC

**** do...while
     #+BEGIN_SRC text
       do
           body-statement
       while (test-expr)
     #+END_SRC
     - goto version
      #+BEGIN_SRC text
        loop:
            body-statement
            t = test-expr;
            if (t)
               goto loop;
        done:
      #+END_SRC

**** while
     #+BEGIN_SRC text
       while (test-expr)
           body-statement
     #+END_SRC
     - goto version
      #+BEGIN_SRC text
        t = test-expr
        if (!t)
           goto done;
        loop:
           body-statement
           if (t)
              goto loop;
        done:
      #+END_SRC

**** for
     #+BEGIN_SRC text
       for (init-expr; test-expr; update-expr)
           body-statement
     #+END_SRC
     - Equivalent to while loop
      #+BEGIN_SRC text
        init-expr;
        while (test-expr)
            body-statement
            update-expr;
      #+END_SRC
     - goto vesion:
      #+BEGIN_SRC text
        init-expr;
        t = test-expr;
        if (!t)
           goto done;

        loop:
           body-statement
           update-expr;
           if (t)
              goto loop;
        done:
      #+END_SRC
**** switch
     Compilers uses the *jump table* to achieve conditional jumping. Think of jump table as an array of function pointers.
     #+BEGIN_SRC c
       switch (n) {
         case 100:
           ...;
           break;
         case 102:
           ...;
           break;
         case 103:
           ...;
           break;
         case 105:
           ...;
           break;
         default:
           break;
       }
     #+END_SRC

     - impl
       #+BEGIN_SRC c
         loc_A:
           ...
         loc_B:
           ...
         ...

         static void *jt[5] = {
           &&loc_A, &&Loc_B, &&loc_C, &&loc_def, &&loc_D
         };
         unsigned long index = n-100;
         if (index > 4)
           goto loc_def;
         goto *it[index];

       #+END_SRC

     - jump table in asm
       #+BEGIN_SRC asm
           .section .rodata
           .align 8 // Align address to multiple of 8
         .L4:
           .quad .L3 // case 100: loc_A
           .quad .L8 // case 101: default
           .quad .L5 // case 102: loc_B
           .quda .L6 // case 103: loc_C
           .quda .L7 // case 105: loc_D
           .quda .L8 // default
       #+END_SRC

** Procedure
   Suppose procedure P(the caller) calls procedure Q(the callee).
*** Stack Frame
    - caller's frame:
      | arg n                                                 |
      | ...                                                   |
      | arg 1                                                 |
      | return address(push callee's return address to stack) |
      | callee's frame                                        |

    - callee's frame:
      | Saved %rbp  |
      | Saved registers, local var, temporaries   |
      | Argument build area (%rsp stack pointer)  |
      | *-stack top-*                             |
*** Procedure Call
    Instructions:
    | call Label    | procedure call           |
    | call *Operand | procedure call           |
    | ret           | return from call         |

    Example:
    #+BEGIN_SRC text
      400540 <multstore>:
        400540: 53        push %rbx
        400541: 48 89 d3  mov  %rdx,%rbx
        ...
        40054d: c3        retq

      .caller:
        400563: e8 d8 ff ff ff      callq   400540 <multstore>
        400568: 48 8b 54 24 08      mov     0x8(%rsp),%rdx
    #+END_SRC

**** call
     <before>%rip(PC counter): 0x400563, %rsp: 0x7fffffffe840
     1. push a return address on the P's stack
     2. set %rip to the start of Q

     <after>%rip: 0x400540, %rsp: 0x7fffffffe838(-8bytes)

**** ret
     1. pop value from return address

     <after>%rip: 0x400568, %rsp: 0x7fffffffe840

     - use 0x8(%rsp) to access return value from callee.

** Array Allocation
*** 1d-array
    $$\&A[i] = \&A[0] + i\cdot sizeof(type)$$
*** 2d-array
    for an array declare as D[R][C],
    $$\&D[i][j] = \&D[0] + sizeof(type)\cdot (C\cdot i + j)$$
    - Example
      s: start address  t: type size  declaration: A[R][C]
      | A[0][0] | s         |
      | A[0][1] | s+t       |
      | A[1][0] | s+Ct      |
      | A[1][2] | s+(C+2)t  |
      | A[3][4] | s+(3C+4)t |
*** variable-size array
    #+BEGIN_SRC c
      int var_ele(long n, int A[n][n], long i, long j) {
        return A[i][j];
      }
    #+END_SRC
    #+BEGIN_SRC asm
      //n in %rdi, A in %rsi, i in %rdx, j in %rcx
      var_ele:
        imulq	%rdx, %rdi  // Compute n*i -> %rdi
        leaq	(%rsi,%rdi,4), %rax // Compute &A[0]+4(n*i) -> %rax
        movl	(%rax,%rcx,4), %eax // Read from M[&A[0]+4(n*i)+4j] -> %eax
        ret
    #+END_SRC

* Storage
** Disk
terms: track, sector, cylinder

*** Access time
- seek time 3~9ms
- rotational latency $T_{max}=\frac{1}{RPM}\cdot60\cdot1000 ms$
- transfer time $T{avg}=\frac{1}{RPM}\cdot\frac{1}{avg sectors/track}\cdot60\cdot1000 ms$

** Locality
#+BEGIN_VERSE
Programs that repeatedly reference the same variables enjoy good temporal locality.

For programs with stride-k reference patterns, the smaller the stride the better
the spatial locality. Programs with stride-1 reference patterns have good spatial
locality. Programs that hop around memory with large strides have poor spatial locality.

Loops have good temporal and spatial locality with respect to instruction
fetches. The smaller the loop body and the greater the number of loop iterations,
the better the locality.
#+END_VERSE
