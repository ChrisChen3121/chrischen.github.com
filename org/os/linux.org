#+TITLE: Linux Administration
#+KEYWORDS: design pattern
#+OPTIONS: H:3 toc:2 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SETUPFILE: ../../org-templates/level-1.org
* findutils
** which
** whereis
   searches a broader range of system directories and is independent of your shell’s search path
** locate
   consults a precompiled index of the filesystem to locate file

* Help
** man
   #+BEGIN_SRC shell
     man -k regexp
     man -f command # list all sections
   #+END_SRC

*** manpath
    Use *manpath* to see locations of the man files

* Users and groups
** /etc/passwd
*** Login name
*** Encrypted password placeholder
- actual password in */etc/shadow*
- change password restriction by editing */etc/login.defs*
*** UID (user ID) number
*** Default GID (group ID) number
*** GECOS information
    Use *finger* command to interpert GECOS,
    use *chfn* to change GECOS
    - full name
    - office number and building
    - office telephone extension
    - home phone number

*** Home directory
*** Login shell
    Use *chsh* to change login shell listed in */etc/shells*.

** /etc/shadow
- Login name *required*
- Encrypted password *required*
- Date of last password change
- Minimum number of days between changes
- Maximum number of days between password changes
- Number of days in advance to warn users about password expiration
- Linux: Days after password expiration that account is disabled
- Account expiration date
- A reserved field that is currently always empty

** /etc/group
- Group name
- Encrypted password or a placeholder
- GID number
- List of members, separated by commas
It is possible to enter a group password to allow users not belonging to
a group to enter it with the *newgrp* command.

A password can be set with the *gpasswd* command

A user’s personal group should contain only that user. If you want to let users
share files by way of the group mechanism, create separate groups for that purpose
** users basic
*** Required
**** Sign policy agreement
**** Edit the *passwd* and *shadow* files to define user
     Use *vipw* to edit *passwd* and *shadow*
**** Add the user to the /etc/group file(optional)
     If the new user should be a member of more groups than just the default group
     specified in the passwd file, you must edit the /etc/group file and add the user’s
     login name to each of the additional groups.
**** Set an initial password
     Use *passwd*
**** Create, *chown*, and *chmod* the user’s home directory.
     #+BEGIN_SRC bash
       sudo chown -R newuser:newgroup ~newuser
     #+END_SRC
**** Configure roles and permissions(RBAC)

*** For the user
**** Copy default startup files to the user’s home directory.
**** Set the user’s mail home and establish mail aliases.

*** For administrator
**** Verify that the account is set up correctly.
**** Add the user’s contact information and account status to your database.

*** Verification
    #+BEGIN_SRC bash
      $ pwd /* verify home directory */
      $ ls -al /* check owner/group of startup files */
    #+END_SRC

** *useradd* command
*** examples
    #+BEGIN_SRC bash
      sudo useradd -c "David Hilbert" -d /home/math/hilbert -g hilbert -G famous -m -s /bin/tcsh hilbert
    #+END_SRC
*** ubuntu
    Ubuntu provides two ways to add users: *adduser* and *useradd*. *adduser* is a Perl
    wrapper for useradd that is a bit more helpful (makes home directories, copies in
    startup files, etc.).
    - *adduser* is configured in */etc/adduser.conf*
    - *adduser* has a twin *addgroup* and cousins *deluser* and *delgroup*.

** Disabling logins
   - *usermod -L* to lock user
   - *usermod -U* to unlock user
** Centralizing account management
*** LDAP
*** Identity management systems
* Shell command
** Filters
   - cut: separate lines into fields
   - sort: sort lines
   - uniq: print unique lines
   - wc: count lines, words, and characters
   - tee: copy input to two places
   - head & tail
   - grep: g/regular-expression/p
** try to write script
   #+BEGIN_SRC bash
     find . -name '*log '
     find . -type f -name '*.log '
     find . -type f -name '*.log ' | grep -v .do-not-touch
     find . -type f -name '*.log ' | grep -v .do-not-touch | while read fname
     do
     echo mv $fname ${fname/.log/.LOG/}
     done
     # finally
     find . -type f -name '*.log ' | grep -v .do-not-touch | while read fname; do
         echo mv $fname ${fname/.log/.LOG/}; done | bash -x
   #+END_SRC
   *bash -x* prints each command before executing it. Use *fc* to transfer last command to editor.
** args
   - $0: name of the script
   - $1: first argument
   - $#: the number of arguments
   - $*: contains all the arguments at once

   - echo $?: the exit status of the last command executed
** Control flow
*** *if* clause
   #+BEGIN_SRC bash
     if [condition]
     then dosomething
     elif [condition]
     then dosomething
     else dosomething
     fi
   #+END_SRC
*** *case* clause
    #+BEGIN_SRC bash
      case $message_level in
          0) message_level_text="Error" ;;
          1) message_level_text="Warning" ;;
          2) message_level_text="Info" ;;
          3) message_level_text="Debug" ;;
          ,*) message_level_text="Other"
      esac
    #+END_SRC
*** comparison operators
   | String | Numeric |
   |--------+---------|
   | x = y  | x -eq y |
   | x != y | x -ne y |
   | x < y  | x -lt y |
   | x <= y | x -le y |
   | x > y  | x -gt y |
   | x >= y | x -ge y |
   | -n x   | -       |
   | -z x   | -       |
*** bash file operators
   | Operator        | True if                            |
   |-----------------+------------------------------------|
   | -d file         | file exists and is a directory     |
   | -e file         | file exists                        |
   | -f file         | file exists and is a regular file  |
   | -r file         | You have read permissions on file  |
   | -s file         | file exists and is not empty       |
   | -w file         | You have write permissions on file |
   | file1 -nt file2 | file1 is newer than file2          |
   | file1 -ot file2 | file1 is order than file2          |
*** Loops
    #+BEGIN_SRC bash
      for var in stuff; do
          ...
      done

      while cond; do
          ...
      done

      for ((i=0; i < count; i++)); do
          ...
      done
    #+END_SRC
*** $(())
    The $((...)) notation forces numeric evaluation,
    #+BEGIN_SRC bash
    $((counter++))
    $(($a+$b))
    #+END_SRC
*** Array
    Use *${array_name[subscript]}* to access individual elements.
    The subscripts * and @ refer to the array as a whole, and the special
    forms *${#array_name[*]}* and *${#array_name[@]}* yield the number of elements in the array.
* Booting
  1. Loading BIOS/UEFI from NVRAM
  1. Probe for hardware
  1. Select boot device(disk, network,...)
  1. Identify EFI system partition
  1. Load boot loader(e.g. GRUB)
  1. Determine which kernel to boot
  1. Load kernel
  1. Instantiate kernel data structures
  1. Start init/systemd as PID 1
  1. Execute startup scripts
  1. Running system
** BIOS vs. UEFI
*** Legacy BIOS(Basic Input/Output System)
    BIOS assumes that the boot device starts with a record called the MBR.
    MBR reads and executes the second-stage boot loader(volume boot record)
*** UFEI(Unified Extensible Firmware Interface)
    The UEFI specification includes a modern disk partitioning scheme known as GPT(GUID Partition Table).

# ** GRUB: The grand unified boot loader
# *** GRUB Legacy
# **** config files
#      */boot/grub/menu.lst* or */boot/grub/grub.conf*
# **** specify kernel boot-time options
# *** GRUB 2
# ** Kernel initialization
#    Path of kernel */boot/vmlinuz*. Two stage to load process.
#    1. ROM loads *bootloader*, outside the domain of UNIX
#    1. bootloader loads and starts the kernel
# ** Hardware configuration
#    /Preserved/
# ** Spontaneous processes
# ** Operator intervention (recovery mode only)
# *** Edit Configure file
#     Remount with read and write mode, then
#     #+BEGIN_SRC shell
#       mount -o rw,remount /
#     #+END_SRC
# ** Execution of startup scripts
# *** Run level
#     - 0: the system is completely shut down.
#     - 1 and S: represent single-user mode.
#     - 2 through 5 include support for networking.
#     - 6: is a "reboot" level
# *** /etc/init.d
#     Scripts are kept here
# *** /etc/inittab
#     The */etc/inittab* file tells init what to do at each run level.

# *** *telinit*
#     The *telinit* command changes *init* ’s run level once the system is up. For example,
#     *telinit* 3 forces init to go to run level 3. *telinit* ’s most useful argument is -q, which
#     causes init to reread the */etc/inittab* file.

# *** CentOS
#     At each run level, *init* invokes the script */etc/rc.d/rc* with the
#     new run level as an argument.
# **** old *chkconfig*
# **** new: *systemd*
# **** */etc/rc.d/rc.local* script: runs at boot time
# **** */etc/sysconfig*: configurations for sys process

# *** Ubuntu
# **** old *upstart*
#     Use *upstart* instead of *init*, and use */etc/event.d* instead of *inittab*.
#     Run-level scripts are stored in /etc/rc*.d/rc
#     - *update-rc.d*
#       example:
#       #+BEGIN_SRC shell
#         sudo update-rc.d cups start 80 2 3 4 5 . stop 20 S 1 6 .
#       #+END_SRC
# **** new: *systemd*

# ** Boot process completion
