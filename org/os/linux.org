#+TITLE: Linux Administration
#+KEYWORDS: design pattern
#+OPTIONS: H:3 toc:2 num:3 ^:nil
#+LANGUAGE: en-US
#+AUTHOR: ChrisChen
#+EMAIL: ChrisChen3121@gmail.com
#+SETUPFILE: ../../org-templates/level-1.org
* findutils
** which
** whereis
   searches a broader range of system directories and is independent of your shell’s search path
** locate
   consults a precompiled index of the filesystem to locate file
   -

* Help
** man
   #+BEGIN_SRC shell
     man -k regexp
     man -f command # list all sections
   #+END_SRC

*** manpath
    Use *manpath* to see locations of the man files

* Users and groups
** /etc/passwd
*** Login name
*** Encrypted password placeholder
- actual password in */etc/shadow*
- change password restriction by editing */etc/login.defs*
*** UID (user ID) number
*** Default GID (group ID) number
*** GECOS information
    Use *finger* command to interpert GECOS,
    use *chfn* to change GECOS
    - full name
    - office number and building
    - office telephone extension
    - home phone number

*** Home directory
*** Login shell
    Use *chsh* to change login shell listed in */etc/shells*.

** /etc/shadow
- Login name *required*
- Encrypted password *required*
- Date of last password change
- Minimum number of days between changes
- Maximum number of days between password changes
- Number of days in advance to warn users about password expiration
- Linux: Days after password expiration that account is disabled
- Account expiration date
- A reserved field that is currently always empty

** /etc/group
- Group name
- Encrypted password or a placeholder
- GID number
- List of members, separated by commas
It is possible to enter a group password to allow users not belonging to
a group to enter it with the *newgrp* command.

A password can be set with the *gpasswd* command

A user’s personal group should contain only that user. If you want to let users
share files by way of the group mechanism, create separate groups for that purpose
** users basic
*** Required
**** Sign policy agreement
**** Edit the *passwd* and *shadow* files to define user
     Use *vipw* to edit *passwd* and *shadow*
**** Add the user to the /etc/group file(optional)
     If the new user should be a member of more groups than just the default group
     specified in the passwd file, you must edit the /etc/group file and add the user’s
     login name to each of the additional groups.
**** Set an initial password
     Use *passwd*
**** Create, *chown*, and *chmod* the user’s home directory.
     #+BEGIN_SRC bash
       sudo chown -R newuser:newgroup ~newuser
     #+END_SRC
**** Configure roles and permissions(RBAC)

*** For the user
**** Copy default startup files to the user’s home directory.
**** Set the user’s mail home and establish mail aliases.

*** For administrator
**** Verify that the account is set up correctly.
**** Add the user’s contact information and account status to your database.

*** Verification
    #+BEGIN_SRC bash
      $ pwd /* verify home directory */
      $ ls -al /* check owner/group of startup files */
    #+END_SRC

** *useradd* command
*** examples
    #+BEGIN_SRC bash
      sudo useradd -c "David Hilbert" -d /home/math/hilbert -g hilbert -G famous -m -s /bin/tcsh hilbert
    #+END_SRC
*** ubuntu
    Ubuntu provides two ways to add users: *adduser* and *useradd*. *adduser* is a Perl
    wrapper for useradd that is a bit more helpful (makes home directories, copies in
    startup files, etc.).
    - *adduser* is configured in */etc/adduser.conf*
    - *adduser* has a twin *addgroup* and cousins *deluser* and *delgroup*.

** Disabling logins
   - *usermod -L* to lock user
   - *usermod -U* to unlock user
** Centralizing account management
*** LDAP
*** Identity management systems
* Shell command
** Filters
   - cut: separate lines into fields
   - sort: sort lines
   - uniq: print unique lines
   - wc: count lines, words, and characters
   - tee: copy input to two places
   - head & tail
   - grep: g/regular-expression/p
** try to write script
   #+BEGIN_SRC bash
     find . -name '*log '
     find . -type f -name '*.log '
     find . -type f -name '*.log ' | grep -v .do-not-touch
     find . -type f -name '*.log ' | grep -v .do-not-touch | while read fname
     do
     echo mv $fname ${fname/.log/.LOG/}
     done
     # finally
     find . -type f -name '*.log ' | grep -v .do-not-touch | while read fname; do
         echo mv $fname ${fname/.log/.LOG/}; done | bash -x
   #+END_SRC
   *bash -x* prints each command before executing it
** args
   - $0: name of the script
   - $1: first argument
   - $#: the number of arguments
   - $*: contains all the arguments at once

   - echo $?: the exit status of the last command executed
** Control flow
*** *if* clause
   #+BEGIN_SRC bash
     if [condition]
     then dosomething
     elif [condition]
     then dosomething
     else dosomething
     fi
   #+END_SRC
*** *case* clause
    #+BEGIN_SRC bash
      case $message_level in
          0) message_level_text="Error" ;;
          1) message_level_text="Warning" ;;
          2) message_level_text="Info" ;;
          3) message_level_text="Debug" ;;
          ,*) message_level_text="Other"
      esac
    #+END_SRC
*** comparison operators
   | String | Numeric |
   |--------+---------|
   | x = y  | x -eq y |
   | x != y | x -ne y |
   | x < y  | x -lt y |
   | x <= y | x -le y |
   | x > y  | x -gt y |
   | x >= y | x -ge y |
   | -n x   | -       |
   | -z x   | -       |
*** bash file operators
   | Operator        | True if                            |
   |-----------------+------------------------------------|
   | -d file         | file exists and is a directory     |
   | -e file         | file exists                        |
   | -f file         | file exists and is a regular file  |
   | -r file         | You have read permissions on file  |
   | -s file         | file exists and is not empty       |
   | -w file         | You have write permissions on file |
   | file1 -nt file2 | file1 is newer than file2          |
   | file1 -ot file2 | file1 is order than file2          |
*** Loops
    #+BEGIN_SRC bash
      for var in stuff; do
          ...
      done

      while cond; do
          ...
      done

      for ((i=0; i < count; i++)); do
          ...
      done
    #+END_SRC
*** $(())
    The $((...)) notation forces numeric evaluation,
    #+BEGIN_SRC bash
    $((counter++))
    $(($a+$b))
    #+END_SRC
