#+TITLE: 高性能Python
#+KEYWORDS: python
#+OPTIONS: H:2 toc:2 num:3 ^:nil
#+SETUPFILE: ../configOrg/level1.org
* Profiling
** CPU
- simple /time/ module
  #+BEGIN_SRC python
    import time
    start_time = time.time()
    fn()
    end_time = time.time()
    print end_time - start_time #seconds
  #+END_SRC
- decorator
  #+BEGIN_SRC python
    from functools import wraps
    def timefn(fn):
        @wraps(fn)
        def measure_time(*args, **kwargs):
            t1 = time.time()
            result = fn(*args, **kwargs)
            t2 = time.time()
            print t2 - t1
            return result
        return measure_time

    @timefn
    def measure_fn(arg1, arg2):
        ...
  #+END_SRC
- %timeit in IPython
- unix /time/ command
  might be useful if you start lots of fresh processes.
  #+BEGIN_SRC sh
    /usr/bin/time -p python xxx.py
    /usr/bin/time --verbose python xxx.py
  #+END_SRC

- cProfile
  #+BEGIN_SRC sh
    python -m cProfile -s cumulative xxx.py
  #+END_SRC
  #+BEGIN_VERSE
  -s cumulative: sort by cumulative time spent
  record profiling:
  #+END_VERSE
  #+BEGIN_SRC sh
    python -m cProfile -o profile.stats xxx.py
  #+END_SRC
  #+BEGIN_SRC python
    import pstats
    p = pstats.Stats("profile.stats")
    p.sort_stats("cumulative")
    p.print_stats()
    p.print_callers() #locate the most expensive parents
    p.print_callees()
  #+END_SRC
  - visualize a profile file: runsnake
  - line_profiler
** memory
- memory_profiler
  #+BEGIN_SRC sh
    python -m memory_profiler xxx.py
    #or
    mprof run xxx.py
    mprof plot
  #+END_SRC
- heapy
  #+BEGIN_VERSE
  /pip install guppy/ first.
  Add following to your code.
  #+END_VERSE
  #+BEGIN_SRC python
    from guppy import hpy; hp = hpy()
    hp.setrelheap()#set checkpoint
    print hp.heap()#print heap usage since last checkpoint
  #+END_SRC
- dowser??
** work with UT
Add following at the top of unittest code.
#+BEGIN_SRC python
  # for line_profiler
  if '__builtin__' not in dir() or not hasattr(__builtin__, 'profile'):
      def profile(func):
          def inner(*args, **kwargs):
              return func(*args, **kwargs)
          return inner

  # for memory_profiler
  if 'profile' not in dir():
      def profile(func):
          def inner(*args, **kwargs):
              return func(*args, **kwargs)
          return inner

#+END_SRC

* Lists and tuples
** Sort algorithm
*** Tim sort
#+BEGIN_VERSE
built-in sort algorithm
(it hybridizes insertion and merge sort algorithms).
#+END_VERSE

*** bisect
#+BEGIN_VERSE
*bisect* provides support for maintaining a list in
sorted order without having to sort the list after each insertion.
#+END_VERSE
#+BEGIN_SRC python
import bisect
alist=[]
bisect.insort(alist, 5)
bisect.insort(alist, 3)
bisect.insort(alist, 20)
bisect.insort(alist, 17)
print alist
#=> [3, 5, 17, 20]
#+END_SRC

** list vs. tuple
*** list
dynamic arrays, mutable and allow for resizing.
- resizing
  The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
  # #+BEGIN_SRC c
  #   new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6);
  #   new_allocated += newsize;
  # #+END_SRC

*** tuple
static arrays, immutable
- instantiating a list can be 5.1x slower than instantiating a tuple
