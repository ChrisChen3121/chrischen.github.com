<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>设计模式</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="设计模式"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-06-09T16:52+0800"/>
<meta name="author" content="ChrisChen"/>
<meta name="description" content=""/>
<meta name="keywords" content="design pattern"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../css/stylesheet.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div>


<div id="content">
<h1 class="title">设计模式</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 OO基本原则</a></li>
<li><a href="#sec-2">2 策略模式</a></li>
<li><a href="#sec-3">3 状态模式</a></li>
<li><a href="#sec-4">4 观察者模式</a></li>
<li><a href="#sec-5">5 模板方法</a></li>
<li><a href="#sec-6">6 装饰者模式</a></li>
<li><a href="#sec-7">7 单件模式</a></li>
<li><a href="#sec-8">8 工厂模式</a></li>
<li><a href="#sec-9">9 命令模式</a></li>
<li><a href="#sec-10">10 适配器模式</a></li>
<li><a href="#sec-11">11 代理模式</a></li>
<li><a href="#sec-12">12 外观模式</a></li>
<li><a href="#sec-13">13 迭代器模式</a></li>
<li><a href="#sec-14">14 桥接模式</a></li>
<li><a href="#sec-15">15 生成器模式</a></li>
<li><a href="#sec-16">16 组合模式</a></li>
<li><a href="#sec-17">17 责任链模式</a></li>
<li><a href="#sec-18">18 一些OO提示</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> OO基本原则</h2>
<div class="outline-text-2" id="text-1">

<p>S.O.L.I.D
</p><ul>
<li>单一职责原则
</li>
<li>开放封闭原则
</li>
<li>子类替换原则
</li>
<li>接口隔离原则
</li>
<li>依赖倒置原则
</li>
</ul>


</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><a name="Strategy" id="Strategy"></a><span class="section-number-2">2</span> 策略模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">行为型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 概述</h3>
<div class="outline-text-3" id="text-2-1">

<p>定义一系列算法，分别封装起来，使它们之间可以相互替换。
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 适用性</h3>
<div class="outline-text-3" id="text-2-2">

<ul>
<li>一些 <b>相关</b> 的类接口一致，仅仅是行为有异
</li>
<li>使算法使用的数据结构不暴露于客户
</li>
<li>一个类定义了多种行为，且这些行为在类中是以多个条件语句的形式出现的
</li>
</ul>


</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 结构</h3>
<div class="outline-text-3" id="text-2-3">



<p>
<img src="../resources/OO/Strategy.png"  alt="../resources/OO/Strategy.png" />
</p>
</div>

</div>

<div id="outline-container-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> 角色</h3>
<div class="outline-text-3" id="text-2-4">

<ul>
<li>Context

<p class="verse">
维护一个Strategy对象的引用<br/>
可开放接口，让Strategy访问其数据<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-2-5" class="outline-3">
<h3 id="sec-2-5"><span class="section-number-3">2.5</span> 优点</h3>
<div class="outline-text-3" id="text-2-5">

<ul>
<li>定义一组可供重用的算法（共通内容可放置于基类）
</li>
<li>替代继承使用组合，更灵活，不用硬编码至Context中
</li>
<li>消除条件语句
</li>
<li>客户代码可以动态的选择具体算法
</li>
</ul>


</div>

</div>

<div id="outline-container-2-6" class="outline-3">
<h3 id="sec-2-6"><span class="section-number-3">2.6</span> 缺点</h3>
<div class="outline-text-3" id="text-2-6">

<ul>
<li>客户代码必须了解到具体算法之间的区别（增加耦合）

<p>
  Gof建议：仅当不同行为是与客户相关的行为有关时，才使用Strategy模式
</p>
</li>
<li>Strategy和Context之间的通信开销

<p>
  各具体算法所需要的参数不一样，但是接口共享。导致需要额外增加两边接口，导致这两个类更紧密的耦合
</p>
</li>
<li>增加了对象的数目

<p>
  参考<a href="#Flyweight">Flyweight</a>模式
</p></li>
</ul>


</div>

</div>

<div id="outline-container-2-7" class="outline-3">
<h3 id="sec-2-7"><span class="section-number-3">2.7</span> 实现</h3>
<div class="outline-text-3" id="text-2-7">


</div>

<div id="outline-container-2-7-1" class="outline-4">
<h4 id="sec-2-7-1"><span class="section-number-4">2.7.1</span> 需定义Context和Strategy之间数据交换的接口</h4>
<div class="outline-text-4" id="text-2-7-1">

<ul>
<li>方法一 Push：将数据作为参数放在Strategy的接口AlgorithmInterface()中。

<p>
  缺点：Context可能发送一些Strategy不需要的数据。
</p>
</li>
<li>方法二 Pull：Context将自身作为参数传递给Strategy，Strategy再调用Get获取数据。

<p>
  缺点：Context必须为Strategy定义一堆更精细的Get接口。（C++中可使用友元）
</p></li>
</ul>


</div>

</div>

<div id="outline-container-2-7-2" class="outline-4">
<h4 id="sec-2-7-2"><span class="section-number-4">2.7.2</span> 将Strategy作为C++模板参数</h4>
<div class="outline-text-4" id="text-2-7-2">




<pre class="src src-cpp"><span style="color: #1e90ff; font-weight: bold;">template</span> &lt;<span style="color: #1e90ff; font-weight: bold;">typename</span> <span style="color: #daa520;">Strategy</span>&gt;
<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Context</span>
{
<span style="color: #1e90ff; font-weight: bold;">private</span>:
    <span style="color: #daa520;">Strategy</span> <span style="color: #008b8b;">theStrategy</span>;
<span style="color: #1e90ff; font-weight: bold;">public</span>:
    <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">ContextInterface</span>() {theStrategy.AlgorithmInterface()}
};
</pre>

<ul>
<li>不再需要Strategy抽象基类。
</li>
<li>避免多态，使用模板在编译时就绑定Strategy和Context，提高运行效率，牺牲了动态绑定的灵活性。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2-8" class="outline-3">
<h3 id="sec-2-8"><span class="section-number-3">2.8</span> 相关模式</h3>
<div class="outline-text-3" id="text-2-8">

<p><a href="#sec-3">State</a> <a href="#sec-3-6-1">两者区别</a>、<a href="#sec-5">Template Method</a>
</p></div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><a name="State" id="State"></a><span class="section-number-2">3</span> 状态模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">行为型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> 概述</h3>
<div class="outline-text-3" id="text-3-1">

<p>对象的行为随着内部状态的改变而改变。
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 适用性</h3>
<div class="outline-text-3" id="text-3-2">

<ul>
<li>一个对象的行为取决于它的状态，并且需要在 <b>运行时</b> 根据它的状态改变它的行为
</li>
<li>大量的依赖于对象状态的分支 <b>条件语句</b> 是一个信号，通常可以用State模式进行改造。
</li>
</ul>


</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> 结构</h3>
<div class="outline-text-3" id="text-3-3">



<p>
<img src="../resources/OO/State.png"  alt="../resources/OO/State.png" />
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> 优点</h3>
<div class="outline-text-3" id="text-3-4">

<ul>
<li>易扩展新的状态，只需定义新的子类
</li>
<li>State对象可以被多个Context对象共享

<p class="verse">
条件：状态 <b>对象</b> 不能持有自己的状态实例。需要将状态实例指定到一个静态变量中(可用单件模式实现)<br/>
<br/>
如果状态需要利用Context中的数据或方法，可在Handle()方法传入Context的引用。<br/>
<br/>
这种实现不再需要State类保存自身的引用，可实现没有内部状态只有行为的轻量级对象。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> 实现</h3>
<div class="outline-text-3" id="text-3-5">


</div>

<div id="outline-container-3-5-1" class="outline-4">
<h4 id="sec-3-5-1"><span class="section-number-4">3.5.1</span> 谁定义状态转换</h4>
<div class="outline-text-4" id="text-3-5-1">

<ol>
<li>可由Context全权负责状态转移
</li>
<li>通常由State具体类自身指定它们的后继状态更方便灵活

<p class="verse">
可以给Context增加一个接口，让State子类对象显式地设定Context的内部状态。<br/>
由State子类来指定状态转移的缺点是，增加了子类之间的依赖。<br/>
</p>


</li>
</ol>


</div>

</div>

<div id="outline-container-3-5-2" class="outline-4">
<h4 id="sec-3-5-2"><span class="section-number-4">3.5.2</span> 可使用表驱动法</h4>
<div class="outline-text-4" id="text-3-5-2">

<ul>
<li>State模式主要对状态相关的行为进行建模
</li>
<li>而表驱动着重于定义状态的转换，通常表的key表示某一状态，Value为它的后继状态。
</li>
</ul>


</div>

</div>

<div id="outline-container-3-5-3" class="outline-4">
<h4 id="sec-3-5-3"><span class="section-number-4">3.5.3</span> 创建和销毁State对象</h4>
<div class="outline-text-4" id="text-3-5-3">

<ul>
<li id="sec-3-5-3-1">面临权衡：(1)需要时创建；(2)提前创建所有的State子类对象<br/>
<ol>
<li>将要进入的状态在运行时是不可知的，且上下文不经常改变状态时，选择(1)。
</li>
<li>另外，当State对象存储大量的信息时，使用(1)。
</li>
<li>当状态频繁变化时，第(2)种方法更好。Context对象需保存所有State子类对象的引用(不宜扩展)。
</li>
</ol>


</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-3-6">

<p><a href="#sec-2">Strategy</a>、<a href="#sec-5">Template Method</a>
</p>
</div>

<div id="outline-container-3-6-1" class="outline-4">
<h4 id="sec-3-6-1"><a name="diff-between-strategy-and-state" id="diff-between-strategy-and-state"></a><span class="section-number-4">3.6.1</span> 与Strategy模式的区别</h4>
<div class="outline-text-4" id="text-3-6-1">

<p>意图：
</p><ul>
<li>Strategy定义的是一组平行的算法，这些算法有着共同的目标。
</li>
<li>State模式更关注根据内在状态的不同，执行不同的行为，这些行为可能目的完全不同。
</li>
</ul>

<p>客户角度：
</p><ul>
<li>State模式：通常的用法，状态通常跟着Context的行为而改变，对客户来说状态转换规则是不可见的。
</li>
<li>Strategy模式：为了灵活，通常是由客户来指定具体的策略。
</li>
</ul>

<p>总结：
</p><ul>
<li>Strategy模式提供了一个继承之外更具弹性的替换方案。
</li>
<li>State模式更多的用来避免Context中过多的分支语句。
</li>
</ul>


</div>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><a name="Observer" id="Observer"></a><span class="section-number-2">4</span> 观察者模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">行为型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 概述</h3>
<div class="outline-text-3" id="text-4-1">

<p>定义对象之间一对多的依赖，当一个对象状态发生变化时，所有依赖于它的对象都得到通知。
</p>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 结构</h3>
<div class="outline-text-3" id="text-4-2">



<p>
<img src="../resources/OO/Observer.png"  alt="../resources/OO/Observer.png" />
</p>
<p>
当一个观察者接收到改变指示后，流程图如下所示：
</p>


<p>
<img src="../resources/OO/ObserverSeq.png"  alt="../resources/OO/ObserverSeq.png" />
</p>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> 优点</h3>
<div class="outline-text-3" id="text-4-3">

<ul>
<li>Subject和Observer间是抽象耦合

<p class="verse">
因为是非紧密耦合，Subject和Observer可以来自于系统中的不同的抽象层次<br/>
低层次Subject一样可以通知高层次Observer，使用该模式不会破坏系统层次<br/>
这就是抽象Subject和Observer的作用。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> 缺点</h3>
<div class="outline-text-3" id="text-4-4">

<ul>
<li>来自某一观察者的意外更新

<p class="verse">
某个观察者更新了主题的状态，导致其他观察者也发生了改变。<br/>
如果更新准则定义或维护不当，常常会引起错误的更新。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-4-5" class="outline-3">
<h3 id="sec-4-5"><span class="section-number-3">4.5</span> 实现</h3>
<div class="outline-text-3" id="text-4-5">


</div>

<div id="outline-container-4-5-1" class="outline-4">
<h4 id="sec-4-5-1"><span class="section-number-4">4.5.1</span> 主题与观察者的关联方式</h4>
<div class="outline-text-4" id="text-4-5-1">

<ul>
<li>主题跟踪观察者最简单的方式是保存观察者们的引用
</li>
<li>另一种方式是维护一份主题与观察者之间的映射表
</li>
</ul>


</div>

</div>

<div id="outline-container-4-5-2" class="outline-4">
<h4 id="sec-4-5-2"><span class="section-number-4">4.5.2</span> 观察多个主题</h4>
<div class="outline-text-4" id="text-4-5-2">


<p class="verse">
某些情况下，观察多个主题是有意义的，例如：一个表格对象依赖于多个数据源。<br/>
需要扩展Update接口使观察者知道是哪一个主题送来的。<br/>
主题可以简单的将自己作为观察者Update接口的参数，让观察者知道应去检查哪一个目标。<br/>
</p>


</div>

</div>

<div id="outline-container-4-5-3" class="outline-4">
<h4 id="sec-4-5-3"><span class="section-number-4">4.5.3</span> 谁触发更新</h4>
<div class="outline-text-4" id="text-4-5-3">

<p>Notify谁来调用？
</p>
<ul>
<li>由主题对象的状态设定操作自动调用。
<ul>
<li>优点：客户不需要调用Notify。
</li>
<li>缺点：多个连续的设定操作会产生多次连续更新，可能效率较低。(关键还是要看需求：在更新状态的时候是否需要通知)

</li>
</ul>

</li>
<li>客户负责调用Notify
<ul>
<li>优点：客户可以在一系列状态设定操作之后一次性通知更新。
</li>
<li>缺点：给客户增加了触发更新的责任。客户忘记的话，容易出错。
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-4-5-4" class="outline-4">
<h4 id="sec-4-5-4"><span class="section-number-4">4.5.4</span> 主题删除时，应通知观察者置空主题引用</h4>
<div class="outline-text-4" id="text-4-5-4">


</div>

</div>

<div id="outline-container-4-5-5" class="outline-4">
<h4 id="sec-4-5-5"><span class="section-number-4">4.5.5</span> 在发出通知前，确保主题的状态自身是一致的</h4>
<div class="outline-text-4" id="text-4-5-5">

<p>反例如下：
</p>


<pre class="src src-c++"><span style="color: #daa520;">void</span> <span style="color: #ff6347;">MySubject</span>::<span style="color: #00008b; font-weight: bold;">Operation</span> (<span style="color: #daa520;">int</span> <span style="color: #008b8b;">newValue</span>)
{
  <span style="color: #ff6347;">BaseClassSubject</span>::Operation(newValue);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20808;&#35302;&#21457;&#20102;&#36890;&#30693;</span>
  _myInstVar += newValue;<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21518;&#20462;&#25913;&#33258;&#36523;&#29366;&#24577;</span>
}
</pre>

<p>
可以使用<a href="#sec-5">模板方法</a>发送通知来避免这种错误。(模板方法规定好修改状态和触发通知的顺序)
</p>
</div>

</div>

<div id="outline-container-4-5-6" class="outline-4">
<h4 id="sec-4-5-6"><span class="section-number-4">4.5.6</span> 推拉模型的取舍</h4>
<div class="outline-text-4" id="text-4-5-6">

<ul>
<li>推模型(大多数情况使用它)
<ul>
<li>Update参数传入的信息可能有很多，并非是所有观察者都需要的。
</li>
<li>主题对观察者所需要的信息的假定并不总是正确。

</li>
</ul>

</li>
<li>拉模型
<ul>
<li>Update传入主题的引用。
</li>
<li>观察者自己向主题获取信息。
</li>
<li>缺点：可能需要调用多个接口以搜集全观察者自己需要的状态。(耦合度增加)
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-4-5-7" class="outline-4">
<h4 id="sec-4-5-7"><span class="section-number-4">4.5.7</span> 只关注感兴趣的改变</h4>
<div class="outline-text-4" id="text-4-5-7">

<p>扩展主题的注册接口，加入interest参数
</p>


<pre class="src src-c++"><span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20027;&#39064;</span>
<span style="color: #daa520;">void</span> <span style="color: #ff6347;">Subject</span>::<span style="color: #00008b; font-weight: bold;">Attach</span>(<span style="color: #daa520;">Observer</span>*, <span style="color: #daa520;">Aspect</span>&amp; <span style="color: #008b8b;">interest</span>);
<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#35266;&#23519;&#32773;</span>
<span style="color: #daa520;">void</span> <span style="color: #ff6347;">Observer</span>::<span style="color: #00008b; font-weight: bold;">Update</span>(<span style="color: #daa520;">Subject</span>*, <span style="color: #daa520;">Aspect</span>&amp; <span style="color: #008b8b;">interest</span>);
</pre>


</div>

</div>

<div id="outline-container-4-5-8" class="outline-4">
<h4 id="sec-4-5-8"><span class="section-number-4">4.5.8</span> 封装复杂的更新语义(ChangeManager)</h4>
<div class="outline-text-4" id="text-4-5-8">


<p class="verse">
当主题与观察者之间的依赖关系特别复杂时，<br/>
需要一个ChangeManager对象来维护这些关系。<br/>
<br/>
目的：尽量减少观察者反映其主题的状态变化所需的工作量。<br/>
例子：如果一操作涉及到几个主题，就必须保证所有的主题都更改完了，再<br/>
一并通知它们的观察者。<br/>
</p>


<p>
该对象主要有 <b>三个职责</b> ：
</p><ul>
<li>管理主题与观察者之间的映射表，提供接口来维护这个映射表。
</li>
<li>定义一个特定的更新策略。
</li>
<li>根据一个主题的请求，更新所有它的观察者。
</li>
</ul>

<p>详细参考：<a href="#sec-4-6">基于ChangeManager的Observer模式</a>
</p>
</div>
</div>

</div>

<div id="outline-container-4-6" class="outline-3">
<h3 id="sec-4-6"><a name="ChangeManager-Observer" id="ChangeManager-Observer"></a><span class="section-number-3">4.6</span> 扩展</h3>
<div class="outline-text-3" id="text-4-6">

<p>基于ChangeManager的Observer模式
</p>

<p>
<img src="../resources/OO/ObserverWithChangeManager.png"  alt="../resources/OO/ObserverWithChangeManager.png" />
</p>
<p>
具体更新策略由具体的ChangeManager来决定：
</p><ul>
<li>SimpleChangeManager总是更新每一个主题的所有观察者
</li>
<li>DAGChangeManager实现多个主题变更时，只更新观察者一次
</li>
</ul>


</div>

</div>

<div id="outline-container-4-7" class="outline-3">
<h3 id="sec-4-7"><span class="section-number-3">4.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-4-7">

<ul>
<li>ChangeManager是一个<a href="#Mediator">Mediator</a>模式的实例
</li>
<li>ChangeManager通常是<a href="#sec-7">Singleton</a>模式
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><a name="Template-Method" id="Template-Method"></a><span class="section-number-2">5</span> 模板方法 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">行为型</span>&nbsp;<span class="_">类</span></span></h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 概述</h3>
<div class="outline-text-3" id="text-5-1">


<p class="verse">
最基本的设计模式，代码复用的基本技术<br/>
定义一系列算法的骨架，将其中的一些步骤延迟到子类中。<br/>
使子类可以不改变一个算法的结构，而重定义算法的某些特定步骤。<br/>
</p>


</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 适用性</h3>
<div class="outline-text-3" id="text-5-2">

<ul>
<li>多个子类中存在一些公共行为，需要提取出来，做法如下：
<ol>
<li>识别代码中不同部分
</li>
<li>提取出新的函数
</li>
<li>用一个新的模板方法替换原算法(公共部分放于其中)
</li>
</ol>

</li>
<li>控制子类扩展，模板方法只在特定点调用子类方法
</li>
</ul>

</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> 结构</h3>
<div class="outline-text-3" id="text-5-3">



<p>
<img src="../resources/OO/TemplateMethod.png"  alt="../resources/OO/TemplateMethod.png" />
</p>
</div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 优点</h3>
<div class="outline-text-3" id="text-5-4">

<ul>
<li>提供了反向的控制结构。即"好莱坞法则"："别找我们，我们找你。"。

<p class="verse">
即高层组件调用低层组件，低层组件不能调用高层组件。<br/>
但并非低层组件一定不能调用高层组件，最重要的是避免让<br/>
高层组件和低层组件之间有明显的环状依赖。<br/>
</p>


</li>
<li>一个模板方法整合了一系列操作，从而减少了需要客户程序调用的接口数。
</li>
<li>客户代码只依赖于模板方法基类，不依赖于具体类，减少整个系统的 <b>依赖</b> 。
</li>
</ul>


</div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 实现</h3>
<div class="outline-text-3" id="text-5-5">

<ul>
<li>hook operations
  提供缺省<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>的行为，子类在必要时拓展。例如：



<pre class="src src-c++"><span style="color: #daa520;">void</span> <span style="color: #ff6347;">AbstractClass</span>::<span style="color: #00008b; font-weight: bold;">TemplateMethod</span>()
{
  Operation1();
  Operation2();
  Hook1();
  <span style="color: #1e90ff; font-weight: bold;">if</span> (HookFileExisted())
    {
      Operation3();
    }
}

<span style="color: #daa520;">bool</span> <span style="color: #ff6347;">AbstractClass</span>::<span style="color: #00008b; font-weight: bold;">HookFileExisted</span>()
{
  <span style="color: #1e90ff; font-weight: bold;">return</span> <span style="color: #ff6347;">true</span>;
}  
</pre>


<p class="verse">
<b>重要</b> ：模板方法应该指明哪些操作是钩子(可被重定义)，哪些操作是抽象操作(必须被重定义)。<br/>
可以做一个命名约定<br/>
需被重定义的操作加上前缀"Do"<br/>
钩子方法加上前缀"Hook"<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-5-6">

<ul>
<li><a href="#sec-8-2">Factory Method</a>常被模板方法调用。
</li>
<li><a href="#sec-2">Strategy</a>使用委托来改变整个算法，模板方法使用继承来改变算法的一部分。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><a name="Decorator" id="Decorator"></a><span class="section-number-2">6</span> 装饰者模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">行为型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-6">


</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 概述</h3>
<div class="outline-text-3" id="text-6-1">

<p>动态地给一个对象添加一些额外的职责。提供了比继承更大的灵活<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup>。
</p>
</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 结构</h3>
<div class="outline-text-3" id="text-6-2">



<p>
<img src="../resources/OO/Decorator.png"  alt="../resources/OO/Decorator.png" />
</p>
<ul>
<li>使用继承的目的是为了达到类型匹配，使用户在使用Decorator对象时，与使用Component一样。
</li>
</ul>


</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> 优点</h3>
<div class="outline-text-3" id="text-6-3">

<ul>
<li>比静态继承更灵活，在运行时添加职责。
</li>
<li>继承在添加一些共通职责时，容易产生类爆炸。Decorator添加的职责大多数情况下能重用。
</li>
<li>使结构层次较高的类更简洁。不依赖于现有已扩展的Decorator类，定义新类型的Decorator很容易。
</li>
</ul>


</div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 缺点</h3>
<div class="outline-text-3" id="text-6-4">

<ul>
<li>使用装饰时不应该依赖于对象标识。被装饰了的组件与这个组件本身就对象标识而言，是有区别的。
</li>
<li>产生很多小对象。对于不了解系统的人，难以学习，排错也比较困难。
</li>
</ul>


</div>

</div>

<div id="outline-container-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 实现</h3>
<div class="outline-text-3" id="text-6-5">

<ol>
<li>接口一致性。所有的Component和Decorator必须有一个公共的父类。
</li>
<li>抽象的Decorator基类是可选的。仅需添加一个职责时，无需Decorator基类。
</li>
<li>保持Component类的简单性。公共父类仅定义接口，尽量避免加入子类并不需要的职责。
</li>
</ol>


</div>

</div>

<div id="outline-container-6-6" class="outline-3">
<h3 id="sec-6-6"><span class="section-number-3">6.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-6-6">


</div>

<div id="outline-container-6-6-1" class="outline-4">
<h4 id="sec-6-6-1"><span class="section-number-4">6.6.1</span> 与<a href="#sec-2">Strategy</a>的比较：</h4>
<div class="outline-text-4" id="text-6-6-1">

<ul>
<li>Decorator可看做一个对象的 <b>外壳</b> 。
</li>
<li>Strategy则是改变对象的内核。

<p class="verse">
当Component基类很 <b>庞大</b> 时，使用Decorator代价太高，Strategy模式更好一些。<br/>
比如，绘制边框的职责，既可以使用Decorator模式包一层外壳，<br/>
也可以使用Border对象专门负责，再组合进Context。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-6-6-2" class="outline-4">
<h4 id="sec-6-6-2"><span class="section-number-4">6.6.2</span> <a href="#sec-16">Composite</a>模式</h4>
<div class="outline-text-4" id="text-6-6-2">


<p class="verse">
可以将装饰视为一个退化的、仅有一个组件的组合。<br/>
另外，它的目的在于添加职责，而Composite目的在于对象聚合。<br/>
</p>


</div>
</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><a name="Singleton" id="Singleton"></a><span class="section-number-2">7</span> 单件模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">创建型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-7">


</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 概述</h3>
<div class="outline-text-3" id="text-7-1">

<p>保证类仅有一个实例，并提供该实例的全局访问点。
</p></div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 适用性</h3>
<div class="outline-text-3" id="text-7-2">

<ul>
<li>当类只能有一个实例
</li>
<li>当这个唯一实例需要通过子类化扩展
</li>
</ul>

</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> 结构</h3>
<div class="outline-text-3" id="text-7-3">



<p>
<img src="../resources/OO/Singleton.png"  alt="../resources/OO/Singleton.png" />
</p>
</div>

</div>

<div id="outline-container-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> 优点</h3>
<div class="outline-text-3" id="text-7-4">

<ul>
<li><b>受控访问</b> 
</li>
<li>起到命名空间的作用

<p class="verse">
对全局变量的一种改进，全局变量会污染名空间(容易重名)。<br/>
支持静态类的语言，使用静态类解决该问题更简单。<br/>
</p>


</li>
</ul>



<ul>
<li>可以被 <b>继承</b> 扩展。
</li>
<li>可扩展单例为 <b>多个实例</b>

<p>  
  允许Singleton类可以管理多个实例（池类技术）。
</p></li>
</ul>


</div>

</div>

<div id="outline-container-7-5" class="outline-3">
<h3 id="sec-7-5"><span class="section-number-3">7.5</span> 实现</h3>
<div class="outline-text-3" id="text-7-5">




<pre class="src src-cpp"><span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Singleton</span>
{
<span style="color: #1e90ff; font-weight: bold;">public</span>:
    <span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">Singleton</span>* <span style="color: #00008b; font-weight: bold;">GetInstance</span>();
<span style="color: #1e90ff; font-weight: bold;">protected</span>:
    <span style="color: #00008b; font-weight: bold;">Singleton</span>() : _instance(<span style="color: #ff6347;">NULL</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#38544;&#34255;&#30340;&#26500;&#36896;&#20989;&#25968;</span>
<span style="color: #1e90ff; font-weight: bold;">private</span>:
    <span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">Singleton</span>* <span style="color: #008b8b;">_instance</span>;
};

<span style="color: #daa520;">Singleton</span>* <span style="color: #ff6347;">Singleton</span>::<span style="color: #00008b; font-weight: bold;">GetInstance</span> ()
{
    <span style="color: #1e90ff; font-weight: bold;">if</span> (_instance == <span style="color: #ff6347;">NULL</span>) _instance = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Singleton</span>;
    <span style="color: #1e90ff; font-weight: bold;">return</span> _instance;
}
</pre>


</div>

<div id="outline-container-7-5-1" class="outline-4">
<h4 id="sec-7-5-1"><span class="section-number-4">7.5.1</span> 同步问题</h4>
<div class="outline-text-4" id="text-7-5-1">


<p class="verse">
为了保证在多线程环境下只创建一个实例，需要对GetInstance方法做同步处理。<br/>
<br/>
简单的方法：直接将GetInstance方法声明为synchronized。<br/>
<br/>
这样的做法有个问题：<br/>
我们需要同步的只是GetInstance内部负责创建实例的区块，<br/>
对整个函数进行同步，如果函数体内内容较多且外部调用很频繁，<br/>
开销会很大。<br/>
<br/>
应该只同步创建实例的区块(java示例)：<br/>
</p>




<pre class="src src-java"><span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Singleton</span>
{
    <span style="color: #1e90ff; font-weight: bold;">private</span> <span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">Singleton</span> <span style="color: #008b8b;">uniqueInstance</span>;
    <span style="color: #1e90ff; font-weight: bold;">private</span> Singleton() {}
    <span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">Singleton</span> <span style="color: #00008b; font-weight: bold;">GetInstance</span>() {
        <span style="color: #1e90ff; font-weight: bold;">if</span> (uniqueInstance == <span style="color: #ff6347;">null</span>) { <span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21028;&#26029;&#26159;&#21542;&#35201;&#36827;&#20837;&#36127;&#36131;&#21019;&#24314;&#23454;&#20363;&#30340;&#21516;&#27493;&#27169;&#22359;</span>
            <span style="color: #1e90ff; font-weight: bold;">synchronized</span> (Singleton.<span style="color: #1e90ff; font-weight: bold;">class</span>) {<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20165;&#19968;&#20010;&#32447;&#31243;&#25191;&#34892;&#27492;&#21306;&#22359;&#65292;&#30830;&#20445;&#21482;&#21019;&#24314;&#19968;&#20010;&#23454;&#20363;&#12290;</span>
                <span style="color: #1e90ff; font-weight: bold;">if</span> (uniqueInstance == <span style="color: #ff6347;">null</span>) { 
                    uniqueInstance = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Singleton</span>();<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#23545;&#20110;&#21516;&#27493;&#25968;&#25454;&#65292;&#24403;&#20320;&#30340;&#20889;&#20837;&#20381;&#36182;&#20110;&#35835;&#21462;&#30340;&#20869;&#23481;&#30340;&#26102;&#20505;&#65292;&#35201;&#23567;&#24515;&#12290;</span>
                }
            }
        }
        <span style="color: #1e90ff; font-weight: bold;">return</span> uniqueInstance;
    }
}
</pre>

</div>

</div>

<div id="outline-container-7-5-2" class="outline-4">
<h4 id="sec-7-5-2"><span class="section-number-4">7.5.2</span> 继承问题</h4>
<div class="outline-text-4" id="text-7-5-2">

<p>问题：子类的单件实例化在何处实现？
</p>
<ul>
<li>在父类的GetInstance中决定使用哪一个单件子类。

<p class="verse">
可以传入参数，使用条件语句在运行时期选择适合的子类。<br/>
局限在于硬性限定了可能的Singleton子类的集合。<br/>
优点：支持多态，运行时指定子类。<br/>
</p>


</li>
<li>将GetInstance类从父类中剥出，并将它放入子类。

<p class="verse">
客户代码通过类名调用GetInstance自行决定使用哪个子类。<br/>
编译时决定使用哪个子类，非运行时，不够灵活。<br/>
</p>


</li>
<li>使用设定文件(或注册表等)记录单件类。

<p>
  GetInstance()读取相关配置项，通过映射表找到相对应的单件类。
</p></li>
</ul>


</div>
</div>

</div>

<div id="outline-container-7-6" class="outline-3">
<h3 id="sec-7-6"><span class="section-number-3">7.6</span> 与静态类比较</h3>
<div class="outline-text-3" id="text-7-6">


</div>

<div id="outline-container-7-6-1" class="outline-4">
<h4 id="sec-7-6-1"><span class="section-number-4">7.6.1</span> 概念上的理解</h4>
<div class="outline-text-4" id="text-7-6-1">

<p>静态类是单件模式的一种特殊实现方式。
</p><ul>
<li>静态类更多的用于与特定实例无关的 <b>全局</b> 属性和 <b>全局</b> 方法的分类(起到命名空间的作用)。
</li>
<li>而单件的概念是确实需要一个实例，而且实例只能有一个。比如：注册表对象，线程池对象。
</li>
</ul>


</div>

</div>

<div id="outline-container-7-6-2" class="outline-4">
<h4 id="sec-7-6-2"><span class="section-number-4">7.6.2</span> 创建的时间</h4>
<div class="outline-text-4" id="text-7-6-2">

<ul>
<li>静态类在编译时创建
</li>
<li>单件模式的类在运行时创建(创建的时机在一定程度上可选)
</li>
</ul>


</div>

</div>

<div id="outline-container-7-6-3" class="outline-4">
<h4 id="sec-7-6-3"><span class="section-number-4">7.6.3</span> 扩展性</h4>
<div class="outline-text-4" id="text-7-6-3">

<ul>
<li>静态类不能被继承，也无法继承其他类。(如果该类需要实现一些接口，则不能使用静态类)
</li>
<li>单件类可以被继承扩展
</li>
<li>如需要从一个实例变为多个实例，静态类做不到。单件类可以扩展满足要求 <b>更灵活</b>
</li>
</ul>


</div>

</div>

<div id="outline-container-7-6-4" class="outline-4">
<h4 id="sec-7-6-4"><span class="section-number-4">7.6.4</span> 总结</h4>
<div class="outline-text-4" id="text-7-6-4">

<ul>
<li>静态类更多地用于对全局方法、全局变量的分类组织。
</li>
<li>单件模式表示有且仅有一个对象。单件类可以被继承，易于扩展。
</li>
</ul>



<p class="verse">
当对于是否使用单件模式没把握的时候，使用单件类更好一些。<br/>
原因：静态类改成实例类，会改变接口，从而影响所有的客户代码。<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-7-7" class="outline-3">
<h3 id="sec-7-7"><span class="section-number-3">7.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-7-7">

<p>经常使用Singleton模式的其他模式：
</p><ul>
<li><a href="#sec-8-3">Abstract Factory</a>
</li>
<li><a href="#sec-15">Builder</a>
</li>
<li><a href="#Prototype">Prototype</a>
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><a name="Factory" id="Factory"></a><span class="section-number-2">8</span> 工厂模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">创建型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-8">


</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1"><a name="SimpleFactory" id="SimpleFactory"></a><span class="section-number-3">8.1</span> 简单工厂方法</h3>
<div class="outline-text-3" id="text-8-1">


</div>

<div id="outline-container-8-1-1" class="outline-4">
<h4 id="sec-8-1-1"><span class="section-number-4">8.1.1</span> 结构</h4>
<div class="outline-text-4" id="text-8-1-1">



<p>
<img src="../resources/OO/SimpleFactory.png"  alt="../resources/OO/SimpleFactory.png" />
</p>
</div>
</div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2"><a name="Factory-Method" id="Factory-Method"></a><span class="section-number-3">8.2</span> 工厂方法</h3>
<div class="outline-text-3" id="text-8-2">


</div>

<div id="outline-container-8-2-1" class="outline-4">
<h4 id="sec-8-2-1"><span class="section-number-4">8.2.1</span> 概述</h4>
<div class="outline-text-4" id="text-8-2-1">

<p>定义一个用于创建对象的接口，让子类决定实例化哪个产品。
</p>
</div>

</div>

<div id="outline-container-8-2-2" class="outline-4">
<h4 id="sec-8-2-2"><span class="section-number-4">8.2.2</span> 结构</h4>
<div class="outline-text-4" id="text-8-2-2">



<p>
<img src="../resources/OO/FactoryMethod.png"  alt="../resources/OO/FactoryMethod.png" />
</p>
</div>

</div>

<div id="outline-container-8-2-3" class="outline-4">
<h4 id="sec-8-2-3"><span class="section-number-4">8.2.3</span> 实现</h4>
<div class="outline-text-4" id="text-8-2-3">

<ul>
<li>避免子类化

<p class="verse">
工厂方法一个潜在的问题是它们可能仅为了创建适当的Product对象<br/>
而迫使你创建Creator子类，C++中可以提供使用模板避免子类化。<br/>
</p>




<pre class="src src-cpp"><span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Creator</span>
{
<span style="color: #1e90ff; font-weight: bold;">public</span>:
    <span style="color: #1e90ff; font-weight: bold;">virtual</span> <span style="color: #daa520;">Product</span>* <span style="color: #00008b; font-weight: bold;">Create</span>() = 0;
};

<span style="color: #1e90ff; font-weight: bold;">template</span> &lt;<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">T</span>&gt;
<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">StandardCreator</span> : <span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">Creator</span>
{
<span style="color: #1e90ff; font-weight: bold;">public</span>:
    <span style="color: #1e90ff; font-weight: bold;">virtual</span> <span style="color: #daa520;">Product</span>* <span style="color: #00008b; font-weight: bold;">Create</span>();
};

<span style="color: #1e90ff; font-weight: bold;">template</span> &lt;<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">T</span>&gt;
<span style="color: #daa520;">Product</span>* <span style="color: #ff6347;">StandardCreator</span>&lt;<span style="color: #daa520;">T</span>&gt;::<span style="color: #00008b; font-weight: bold;">Create</span>()
{
    <span style="color: #1e90ff; font-weight: bold;">return</span> <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">T</span>;
}
</pre>

</li>
</ul>


</div>

</div>

<div id="outline-container-8-2-4" class="outline-4">
<h4 id="sec-8-2-4"><span class="section-number-4">8.2.4</span> 相关模式</h4>
<div class="outline-text-4" id="text-8-2-4">

<ul>
<li><a href="#sec-8-3">Abstract Factory</a>经常使用工厂方法来实现。
</li>
<li>工厂方法通常在<a href="#Template-Methods">Template Methods</a>中被调用。

<p>
  模板方法指定一系列的具体步骤，而创建对象的一步委托给工厂方法。
</p>
</li>
<li><a href="#Prototypes">Prototypes</a>不需要创建Creator的子类。

<p>
  但会要求一个针对Product类的Initialize操作。Creator使用Initialize来初始化对象。
</p>
</li>
<li>与简单工厂方法的比较

<p class="verse">
简单工厂在SimpleFactory的create方法中，使用类似Switch语句来根据参数制造产品。<br/>
缺点在于，switch不容易扩展，并且SimpleFactory需要知道所有的产品类，耦合紧密。<br/>
</p>


</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-8-3" class="outline-3">
<h3 id="sec-8-3"><a name="Abstract-Factory" id="Abstract-Factory"></a><span class="section-number-3">8.3</span> 抽象工厂</h3>
<div class="outline-text-3" id="text-8-3">


</div>

<div id="outline-container-8-3-1" class="outline-4">
<h4 id="sec-8-3-1"><span class="section-number-4">8.3.1</span> 概述</h4>
<div class="outline-text-4" id="text-8-3-1">

<p>提供创建一系列产品族的接口，而无需指定各产品的具体类。
</p>
</div>

</div>

<div id="outline-container-8-3-2" class="outline-4">
<h4 id="sec-8-3-2"><span class="section-number-4">8.3.2</span> 角色</h4>
<div class="outline-text-4" id="text-8-3-2">

<ul>
<li>ConcreteFactory

<p>  
  负责创建各产品对象，每一个具体工厂类都代表一种产品之间的组合。
</p></li>
</ul>


</div>

</div>

<div id="outline-container-8-3-3" class="outline-4">
<h4 id="sec-8-3-3"><span class="section-number-4">8.3.3</span> 结构</h4>
<div class="outline-text-4" id="text-8-3-3">



<p>
<img src="../resources/OO/AbstractFactory.png"  alt="../resources/OO/AbstractFactory.png" />
</p>
</div>

</div>

<div id="outline-container-8-3-4" class="outline-4">
<h4 id="sec-8-3-4"><span class="section-number-4">8.3.4</span> 优点</h4>
<div class="outline-text-4" id="text-8-3-4">

<ul>
<li><b>使得易于交换产品系列</b>

<p>
  通过替换具体的工厂类，来改变产品系列。
</p>
</li>
<li><b>有利于产品的一致性</b>

<p>  
  当一系列产品被设计成一起工作时，抽象工厂可以保证一个应用一次只能使用同一系列的对象。
</p></li>
</ul>


</div>

</div>

<div id="outline-container-8-3-5" class="outline-4">
<h4 id="sec-8-3-5"><span class="section-number-4">8.3.5</span> 缺点</h4>
<div class="outline-text-4" id="text-8-3-5">

<ul>
<li><b>难以支持新种类的产品</b>

<p class="verse">
AbstractFactory接口定义了可以被创建的产品集合。支持新的产品种类，<br/>
就需要扩展接口，还涉及到所有子类的改变。<a href="#extendable-concrete-factory">解决办法</a><br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-6" class="outline-4">
<h4 id="sec-8-3-6"><span class="section-number-4">8.3.6</span> 实现</h4>
<div class="outline-text-4" id="text-8-3-6">

<ul>
<li>将具体工厂作为单件

<p>
  一般每个产品系列只需一个ConcreteFactory的实例。
</p>
</li>
<li>创建产品。

<p class="verse">
AbstractFactory只声明创建产品的接口。<br/>
如果有多个可能的产品系列，具体工厂也可以使用<a href="#Prototype">Prototype</a>模式来实现。<br/>
具体工厂使用产品系列中每一个产品的原型实例来初始化，<br/>
且它通过复制它的原型来创建新的产品。<br/>
<br/>
基于原型的好处：不是每个新的产品系列都需要一个新的具体工厂类。<br/>
</p>


</li>
</ul>


<p>
<a name="extendable-concrete-factory" id="extendable-concrete-factory"></a>
</p><ul>
<li>定义可扩展的工厂

<p class="verse">
加入新产品需要扩展接口，影响子类。<br/>
一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。<br/>
AbstractFactory只提供一个Create操作，用参数指定要创建的产品。<br/>
由于产品种类各不相同，此方法只适用于动态类型语言。<br/>
<br/>
当所有对象都有相同的基类，且产品对象可以安全的强转成正确的<br/>
类型时。才能在C++这样的静态类型语言中使用。<br/>
<br/>
此方法有个本质的问题，因为返回的都是Object基类，客户无法区分<br/>
或对一个产品类别进行安全的假定。需要dynamic_cast去转换，这种<br/>
自上向下类型的转换并不总是安全的。<br/>
<br/>
总结：这是一个典型的高度灵活和更高安全性的权衡问题。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-8-3-7" class="outline-4">
<h4 id="sec-8-3-7"><span class="section-number-4">8.3.7</span> 相关模式</h4>
<div class="outline-text-4" id="text-8-3-7">

<ul>
<li><a href="#sec-8-3">Abstract Factory</a>通常用<a href="#sec-8-2">工厂方法</a>实现，也可用<a href="#Prototype">Prototype</a>实现。
</li>
<li>一个具体的工厂通常是一个<a href="#sec-7">单件</a>。
</li>
</ul>


</div>
</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><a name="Command" id="Command"></a><span class="section-number-2">9</span> 命令模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">行为型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-9">


</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 概述</h3>
<div class="outline-text-3" id="text-9-1">


<p class="verse">
将请求封装成对象，实现统一的Execute()接口，从而可以使用不同的请求<br/>
实例对其他对象进行参数化。<br/>
<br/>
典型的例子：<br/>
Button控件，对控件设计者来说，只知道Button按下应该会发生<br/>
些什么，但具体会发生什么一无所知。只能由使用者来决定。<br/>
</p>


</div>

</div>

<div id="outline-container-9-2" class="outline-3">
<h3 id="sec-9-2"><span class="section-number-3">9.2</span> 适用性</h3>
<div class="outline-text-3" id="text-9-2">

<ul>
<li><b>回调机制</b> 的一个面向对象的替代品

</li>
<li>支持对请求排队

</li>
<li>支持撤销操作

<p class="verse">
Excute()在实施操作前记录状态，Undo()利用该记录状态取消之前执行的操作。<br/>
将执行完的命令对象加入一个历史列表，可通过 <b>向前/向后遍历</b> 实现<br/>
一系列的 <b>Undo/Redo</b> 。<br/>
</p>


</li>
<li>命令对象支持 <b>持久化</b>

<p class="verse">
方法：添加Store()和Load()接口<br/>
在执行一些列命令前，调用Store()对命令对象进行序列化和持久化操作。<br/>
一旦系统崩溃，可以使用Load()复原命令对象，并重新执行。<br/>
</p>


</li>
<li>支持事务处理
</li>
</ul>


</div>

</div>

<div id="outline-container-9-3" class="outline-3">
<h3 id="sec-9-3"><span class="section-number-3">9.3</span> 结构</h3>
<div class="outline-text-3" id="text-9-3">



<p>
<img src="../resources/OO/Command.png"  alt="../resources/OO/Command.png" />
</p>
</div>

</div>

<div id="outline-container-9-4" class="outline-3">
<h3 id="sec-9-4"><span class="section-number-3">9.4</span> 角色</h3>
<div class="outline-text-3" id="text-9-4">

<ul>
<li>Client

<p class="verse">
负责创建具体命令对象并指定它的接收者。<br/>
存储命令对象到某个媒介。<br/>
</p>



</li>
<li>Invoker 从存储媒介中获取命令对象，并执行。
</li>
</ul>


</div>

</div>

<div id="outline-container-9-5" class="outline-3">
<h3 id="sec-9-5"><span class="section-number-3">9.5</span> 优点</h3>
<div class="outline-text-3" id="text-9-5">

<ol>
<li>增加新的Command很容易。
</li>
<li>将调用命令的对象与知道如何实现该命令相关操作的对象解耦。
</li>
<li>Command对象和其他对象一样支持扩展。
</li>
<li>支持MacroCommand。复合命令是Composite模式的一个实例。
</li>
</ol>


</div>

</div>

<div id="outline-container-9-6" class="outline-3">
<h3 id="sec-9-6"><span class="section-number-3">9.6</span> 实现</h3>
<div class="outline-text-3" id="text-9-6">

<ul>
<li>一个命令对象职责可大可小。
<ul>
<li>最小职责仅确定一个接收者和执行该请求的动作
</li>
<li>职责也可以大到负责处理所有的功能，不需要接收者，直接包含具体动作。(当没有合适的接收者时使用)
</li>
</ul>

</li>
<li>实现undo和redo

<p>
  ConcreteCommand类需要存储额外的状态信息，包括：
</p>
<ul>
<li>接收者对象
</li>
<li>接收者接口执行操作的参数
</li>
<li>接收者的状态值

</li>
</ul>

</li>
<li>使用C++模板

<p class="verse">
好处：避免每一个动作和接收者都创建一个Command子类。<br/>
问题：1) 不支持撤销操作 2) 无法向接收者的执行接口传入参数<br/>
</p>


</li>
</ul>

</div>

</div>

<div id="outline-container-9-7" class="outline-3">
<h3 id="sec-9-7"><span class="section-number-3">9.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-9-7">

<ul>
<li><a href="#sec-16">Composite</a>可被用来实现宏命令。
</li>
<li><a href="#Memento">Memento</a>模式可用来保持一个状态，命令对象用该状态来取消之前执行效果。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><a name="Adapter" id="Adapter"></a><span class="section-number-2">10</span> 适配器模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="_">类</span>&nbsp;<span class="__">对象</span>&nbsp;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-10">


</div>

<div id="outline-container-10-1" class="outline-3">
<h3 id="sec-10-1"><span class="section-number-3">10.1</span> 概述</h3>
<div class="outline-text-3" id="text-10-1">


<p class="verse">
将一个或多个类的接口转换成用户希望的接口。别名Wrapper。<br/>
现有类的接口与用户希望的接口通常是固定的，无法改变。<br/>
</p>


</div>

</div>

<div id="outline-container-10-2" class="outline-3">
<h3 id="sec-10-2"><span class="section-number-3">10.2</span> 结构</h3>
<div class="outline-text-3" id="text-10-2">


</div>

<div id="outline-container-10-2-1" class="outline-4">
<h4 id="sec-10-2-1"><span class="section-number-4">10.2.1</span> 类适配器</h4>
<div class="outline-text-4" id="text-10-2-1">



<p>
<img src="../resources/OO/ClassAdapter.png"  alt="../resources/OO/ClassAdapter.png" />
</p>
</div>

</div>

<div id="outline-container-10-2-2" class="outline-4">
<h4 id="sec-10-2-2"><span class="section-number-4">10.2.2</span> 对象适配器</h4>
<div class="outline-text-4" id="text-10-2-2">

<p>将Adapter与Adaptee之间的继承关系变为了组合。
</p>

<p>
<img src="../resources/OO/InstanceAdapter.png"  alt="../resources/OO/InstanceAdapter.png" />
</p>
</div>
</div>

</div>

<div id="outline-container-10-3" class="outline-3">
<h3 id="sec-10-3"><span class="section-number-3">10.3</span> 角色</h3>
<div class="outline-text-3" id="text-10-3">

<ul>
<li>Target
  定义了满足用户需要的接口
</li>
</ul>


</div>

</div>

<div id="outline-container-10-4" class="outline-3">
<h3 id="sec-10-4"><span class="section-number-3">10.4</span> 实现细节</h3>
<div class="outline-text-3" id="text-10-4">


</div>

<div id="outline-container-10-4-1" class="outline-4">
<h4 id="sec-10-4-1"><span class="section-number-4">10.4.1</span> 类适配器还是对象适配器？</h4>
<div class="outline-text-4" id="text-10-4-1">

<ul>
<li>重定义Adaptee的行为

<p class="verse">
类适配器可以方便地重定义Adaptee的部分行为。<br/>
对象适配器可能需要通过<a href="#sec-6">Decorator</a>模式先拓展Adaptee。<br/>
</p>



</li>
<li>适配多个Adaptee？

<p class="verse">
类适配器只能适配一个Adaptee。<br/>
对象适配器支持多个。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-10-4-2" class="outline-4">
<h4 id="sec-10-4-2"><span class="section-number-4">10.4.2</span> 双向适配器增加透明性</h4>
<div class="outline-text-4" id="text-10-4-2">


<p class="verse">
适配器因为改变了接口，Adapter对象与Adaptee对象不兼容(提示：<a href="#sec-6">Decorator</a>兼容)。<br/>
原本使用Adaptee对象的用户就无法使用Adapter对象。<br/>
可使用双向适配器，在实现Target的同时，保留原本Adaptee的接口。<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-10-5" class="outline-3">
<h3 id="sec-10-5"><span class="section-number-3">10.5</span> 相关模式</h3>
<div class="outline-text-3" id="text-10-5">

<ul>
<li><a href="#sec-14">Bridge</a>模式的结构与其有些相似，但意图不同。<a href="#sec-14">Bridge</a>的目的是将接口部分与实现部分分离。
</li>
<li><a href="#sec-6">Decorator</a>模式为类增加职责，不改变 <b>原先</b> 的接口。透明性比<a href="#sec-10">Adapter</a>好，并支持递归组合。
</li>
<li><a href="#sec-11">Proxy</a>模式在不改变其接口的条件下，为另一个对象定义了一个代理。
</li>
<li><a href="#sec-12">Facade</a>模式将一个或多个不同对象的复杂接口进行简化。
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><a name="Proxy" id="Proxy"></a><span class="section-number-2">11</span> 代理模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="__">对象</span>&nbsp;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-11">


</div>

<div id="outline-container-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 概述</h3>
<div class="outline-text-3" id="text-11-1">

<p>控制和管理访问
</p></div>

</div>

<div id="outline-container-11-2" class="outline-3">
<h3 id="sec-11-2"><span class="section-number-3">11.2</span> 适用性</h3>
<div class="outline-text-3" id="text-11-2">

<ol>
<li><b>远程代理</b> 代理类隐藏网络层的实现，本地调用代理类就如同调用本地对象一样。
</li>
<li><b>虚代理</b> 创建开销很大的对象时使用。代理类隐藏创建的细节。
</li>
<li><b>保护代理</b> 用于权限控制。
</li>
<li><b>智能指针</b>
</li>
</ol>

</div>

</div>

<div id="outline-container-11-3" class="outline-3">
<h3 id="sec-11-3"><span class="section-number-3">11.3</span> 结构</h3>
<div class="outline-text-3" id="text-11-3">



<p>
<img src="../resources/OO/Proxy.png"  alt="../resources/OO/Proxy.png" />
</p>
</div>

</div>

<div id="outline-container-11-4" class="outline-3">
<h3 id="sec-11-4"><span class="section-number-3">11.4</span> 角色</h3>
<div class="outline-text-3" id="text-11-4">

<ul>
<li>Proxy

<p>
  控制对实体的存取，并可能负责创建和删除实体。
</p>
</li>
<li>Subject

<p>  
  定义RealSubject与Proxy的共用接口。
</p></li>
</ul>

</div>

</div>

<div id="outline-container-11-5" class="outline-3">
<h3 id="sec-11-5"><span class="section-number-3">11.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-11-5">


</div>

<div id="outline-container-11-5-1" class="outline-4">
<h4 id="sec-11-5-1"><span class="section-number-4">11.5.1</span> C++通过重载-&gt;,*运算符实现</h4>
<div class="outline-text-4" id="text-11-5-1">




<pre class="src src-c++"><span style="color: #daa520;">Image</span>* <span style="color: #ff6347;">ImageProxy</span>::<span style="color: #1e90ff; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">-&gt;</span> ()
{
    <span style="color: #1e90ff; font-weight: bold;">return</span> LoadImage();
}
<span style="color: #daa520;">Image</span>&amp; <span style="color: #ff6347;">ImageProxy</span>::<span style="color: #1e90ff; font-weight: bold;">operator</span><span style="color: #00008b; font-weight: bold;">*</span> ()
{
    <span style="color: #1e90ff; font-weight: bold;">return</span> *LoadImage();
}

<span style="color: #daa520;">int</span> <span style="color: #00008b; font-weight: bold;">main</span>()
{
    <span style="color: #daa520;">ImageProxy</span> <span style="color: #008b8b;">imageptr</span>;
    imageptr-&gt;Draw();<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#27492;&#22788;&#23454;&#38469;&#35843;&#29992;&#30340;&#26159;Image&#30340;&#26041;&#27861;</span>
    (*image).Draw();
    <span style="color: #1e90ff; font-weight: bold;">return</span> 0;
}

</pre>

</div>

</div>

<div id="outline-container-11-5-2" class="outline-4">
<h4 id="sec-11-5-2"><span class="section-number-4">11.5.2</span> 远程代理</h4>
<div class="outline-text-4" id="text-11-5-2">


<p class="verse">
远程代理不一定都是通过网络调用的，不同地址空间的对象访问也是远程代理。<br/>
远程代理一般需要将对象、调用信息序列化，通过Socket等协议，通知远程的<br/>
服务，然后有远程提供服务的程序，调用实体对象。<br/>
<br/>
Java中有成套的解决方案，叫做RMI。<br/>
</p>


</div>

</div>

<div id="outline-container-11-5-3" class="outline-4">
<h4 id="sec-11-5-3"><span class="section-number-4">11.5.3</span> 智能指针</h4>
<div class="outline-text-4" id="text-11-5-3">

<ul>
<li>对指向实际对象的引用计数，引用计数为0时，自动释放。
</li>
<li>第一次引用时，装入内存。
</li>
<li>访问实际对象前，检查被锁定。
</li>
</ul>


<p>
标准库的例子：
</p>


<pre class="src src-c++"><span style="color: #0000cd; text-decoration: underline;">#include</span> <span style="color: #9400d3;">&lt;memory&gt;</span>
<span style="color: #1e90ff; font-weight: bold;">using</span> <span style="color: #1e90ff; font-weight: bold;">namespace</span> <span style="color: #ff6347;">std</span>;
<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">A</span> {};
<span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">f</span>()
{
    <span style="color: #daa520;">auto_ptr</span>&lt;<span style="color: #daa520;">A</span>&gt; <span style="color: #008b8b;">ptr</span>(<span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">A</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#26632;&#21306;&#23545;&#35937;&#65292;&#20986;&#26632;&#26102;&#37322;&#25918;&#25351;&#38024;&#65292;&#36991;&#20813;&#22810;&#20010;&#20989;&#25968;&#20986;&#21475;&#37117;&#20889;&#37322;&#25918;&#35821;&#21477;</span>
    <span style="color: #1e90ff; font-weight: bold;">try</span>
    {
        <span style="color: #8b8989;">//</span><span style="color: #8b8989;">delete a;</span>
        <span style="color: #1e90ff; font-weight: bold;">return</span>;
    }
    <span style="color: #1e90ff; font-weight: bold;">catch</span> (...)
    {
        <span style="color: #8b8989;">//</span><span style="color: #8b8989;">delete a;</span>
    }
    <span style="color: #8b8989;">//</span><span style="color: #8b8989;">delete a;</span>
}
</pre>


</div>

</div>

<div id="outline-container-11-5-4" class="outline-4">
<h4 id="sec-11-5-4"><span class="section-number-4">11.5.4</span> 虚代理</h4>
<div class="outline-text-4" id="text-11-5-4">


<p class="verse">
对于一些开销很大的对象，可能在实际真正用到的时候，才创建对象。<br/>
例如：ImageProxy构造中什么都不做，而在Draw的接口中，才真正创建Image对象。<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-11-6" class="outline-3">
<h3 id="sec-11-6"><span class="section-number-3">11.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-11-6">

<ul>
<li><a href="#sec-10">Adapter</a>模式：

<p>
  主要用于转换接口；而代理模式一般情况下不改变接口，意图不一样。
</p>
</li>
<li><a href="#sec-6">Decorator</a>模式：两者结构类似，但意图不同。

<p class="verse">
装饰者模式支持多层装饰；而代理通常只会添加一层访问控制。<br/>
代理模式通常与实际对象接口保持一致。装饰者通常需要增加接口以达到扩展功能的目的。<br/>
</p>


</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><a name="Facade" id="Facade"></a><span class="section-number-2">12</span> 外观模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="__">对象</span>&nbsp;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-12">


</div>

<div id="outline-container-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> 概述</h3>
<div class="outline-text-3" id="text-12-1">

<p>为子系统中的一组接口进行简化，提供一组高级接口，使得子系统更加容易使用。
</p></div>

</div>

<div id="outline-container-12-2" class="outline-3">
<h3 id="sec-12-2"><span class="section-number-3">12.2</span> 适用性</h3>
<div class="outline-text-3" id="text-12-2">

<ul>
<li>为复杂子系统提供一个简单接口，对大部分用户来说足够用，必要时用户一样可以绕过该接口。
</li>
<li>使客户程序从子系统的各层次实现的细节中解脱出来。
</li>
<li>多层次结构，可以使用Facade模式定义每一层的抽象操作。可以让各层次之间通过facade进行通信，简化了各层次之间的依赖关系。
</li>
</ul>

</div>

</div>

<div id="outline-container-12-3" class="outline-3">
<h3 id="sec-12-3"><span class="section-number-3">12.3</span> 结构</h3>
<div class="outline-text-3" id="text-12-3">



<p>
<img src="../resources/OO/Facade.png"  alt="../resources/OO/Facade.png" />
</p></div>

</div>

<div id="outline-container-12-4" class="outline-3">
<h3 id="sec-12-4"><span class="section-number-3">12.4</span> 优点</h3>
<div class="outline-text-3" id="text-12-4">

<ul>
<li>实现了用户与子系统之间的 <b>松耦合</b> 关系
</li>
<li>对用户屏蔽子系统结构，更易用
</li>
</ul>

</div>

</div>

<div id="outline-container-12-5" class="outline-3">
<h3 id="sec-12-5"><span class="section-number-3">12.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-12-5">

<ul>
<li>使用抽象类实现Facade可以进一步降低客户与子系统的耦合度。
</li>
<li>C++使用Namespace可以私有化子系统中的类。
</li>
</ul>

</div>

</div>

<div id="outline-container-12-6" class="outline-3">
<h3 id="sec-12-6"><span class="section-number-3">12.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-12-6">

<ul>
<li><a href="#sec-8-3">Abstract Factory</a>模式可与Facade模式一起使用以提供一个单独的创建产品簇的接口。
</li>
<li><a href="#Mediator">Mediator</a>模式与Facade模式的相似之处：都抽象了一些已有的类的功能。但<a href="#Mediator">Mediator</a>的目的是对同级之间的任意通讯进行抽象。
</li>
<li>通常来说仅需要一个Facade对象，所以Facade类定义成<a href="#sec-7">Singleton</a>类。
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13"><a name="Iterator" id="Iterator"></a><span class="section-number-2">13</span> 迭代器模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="__">对象</span>&nbsp;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-13">


</div>

<div id="outline-container-13-1" class="outline-3">
<h3 id="sec-13-1"><span class="section-number-3">13.1</span> 概述</h3>
<div class="outline-text-3" id="text-13-1">

<p>提供遍历集合对象中各元素的方法，并且不将集合具体的数据结构暴露给用户。
</p></div>

</div>

<div id="outline-container-13-2" class="outline-3">
<h3 id="sec-13-2"><span class="section-number-3">13.2</span> 适用性</h3>
<div class="outline-text-3" id="text-13-2">

<ul>
<li>遍历访问集合对象的内容，无需暴露它的内部结构。
</li>
<li>支持对同一集合对象的多种遍历方式。
</li>
<li>为遍历不同数据结构的集合对象提供统一的接口(即支持多态迭代）。
</li>
</ul>

</div>

</div>

<div id="outline-container-13-3" class="outline-3">
<h3 id="sec-13-3"><span class="section-number-3">13.3</span> 结构</h3>
<div class="outline-text-3" id="text-13-3">



<p>
<img src="../resources/OO/Iterator.png"  alt="../resources/OO/Iterator.png" />
</p>
</div>

</div>

<div id="outline-container-13-4" class="outline-3">
<h3 id="sec-13-4"><span class="section-number-3">13.4</span> 角色</h3>
<div class="outline-text-3" id="text-13-4">

<ul>
<li>Iterator

<p>
  定义访问和遍历元素的接口
</p>
</li>
<li>ConcreteIterator

<ul>
<li>实现Iterator定义的接口
</li>
<li>在遍历集合时，跟踪当前位置

</li>
</ul>

</li>
<li>Aggregate

<p>  
  定义创建迭代器对象的接口
</p>
</li>
<li>ConcreteAggregate

<p>  
  实现Aggregate定义的接口
</p></li>
</ul>

</div>

</div>

<div id="outline-container-13-5" class="outline-3">
<h3 id="sec-13-5"><span class="section-number-3">13.5</span> 优点</h3>
<div class="outline-text-3" id="text-13-5">

<ul>
<li>支持以不同的方式遍历一个集合，使改变遍历算法变的容易。
</li>
<li>迭代器将遍历的职责从集合类中剥离出来。维护起来更容易。
</li>
<li>可以同时对一个集合进行多个遍历，只需多个迭代器实例对象。
</li>
</ul>

</div>

</div>

<div id="outline-container-13-6" class="outline-3">
<h3 id="sec-13-6"><span class="section-number-3">13.6</span> 实现细节</h3>
<div class="outline-text-3" id="text-13-6">


</div>

<div id="outline-container-13-6-1" class="outline-4">
<h4 id="sec-13-6-1"><span class="section-number-4">13.6.1</span> 由谁来控制迭代过程？</h4>
<div class="outline-text-4" id="text-13-6-1">


<p class="verse">
由客户来控制的称为外部迭代器(或称为主动迭代器)。<br/>
由迭代器自身来控制的，称为内部迭代器(或称为被动迭代器)。<br/>
</p>


<ul>
<li>外部迭代器

<p>  
  使用外部迭代器时，客户必须主动推进迭代的步伐。
</p>
</li>
<li>内部迭代器

<p class="verse">
使用内部迭代器时，客户只需指定一个操作，迭代器保证对集合<br/>
中的每一个元素执行该操作。<sup><a class="footref" name="fnr-.3" href="#fn-.3">3</a></sup><br/>
如何指定操作？支持匿名函数和闭包的语言很容易实现。<br/>
C++中通常有两种方法可以选择<br/>
</p>


<ul>
<li>函数指针
    劣势在于如果需要更新某种状态，则需要使用全局变量。
</li>
<li>子类生成
    需要定义额外的类来达到目的。<sup><a class="footref" name="fnr-.4" href="#fn-.4">4</a></sup>

</li>
</ul>

</li>
<li>权衡

<p class="verse">
内部迭代器定义好了迭代逻辑，使用起来更方便；<br/>
外部迭代器由于将迭代逻辑交由用户来控制，使用起来更灵活。<br/>
</p>


</li>
</ul>


</div>

</div>

<div id="outline-container-13-6-2" class="outline-4">
<h4 id="sec-13-6-2"><span class="section-number-4">13.6.2</span> 谁定义遍历算法？</h4>
<div class="outline-text-4" id="text-13-6-2">

<ul>
<li>由集合自身定义

<p class="verse">
由集合自身定义遍历算法。迭代器仅用来指示当前的位置。这种迭代器称为 <b>游标</b> 。<br/>
<br/>
客户调用Next()时，需要将游标作为参数传入，Next操作内部仅改变游标的位置状态。<br/>
可改接口为SetCursor(index)和int GetCursor()更容易理解。<br/>
</p>


</li>
<li>由迭代器定义

<p class="verse">
遍历算法还可以由迭代器定义，优势在于，使得在相同的集合上使用不同的迭代算法、<br/>
或是在不同的集合上使用相同的迭代算法更简单。<br/>
<br/>
注意：如果遍历算法会用到集合的私有变量，放在迭代器中，则破坏了集合对象的封装性。<br/>
</p>


</li>
</ul>

</div>

</div>

<div id="outline-container-13-6-3" class="outline-4">
<h4 id="sec-13-6-3"><span class="section-number-4">13.6.3</span> 线程安全的迭代器</h4>
<div class="outline-text-4" id="text-13-6-3">


<p class="verse">
现实情况下，可能有多个不同线程创建的迭代器引用同一个集合对象。<br/>
<br/>
解决同步问题的一般做法是：<br/>
各迭代器对象需要向集合对象进行注册(可用<a href="#sec-4">Observer</a>模式)，<br/>
当改变发生时，集合对象更新每一个迭代器的状态。<br/>
</p>


</div>

</div>

<div id="outline-container-13-6-4" class="outline-4">
<h4 id="sec-13-6-4"><span class="section-number-4">13.6.4</span> 关于多态迭代器</h4>
<div class="outline-text-4" id="text-13-6-4">

<ul>
<li>结构图中所展示的是多态迭代器的实现

<p class="verse">
也可以不需要迭代器抽象基类，这样在 <b>工厂方法CreateIterator</b> 中<br/>
也就不需要动态new出迭代器具体类对象。<br/>
</p>



</li>
<li>多态迭代器是有代价的

<p class="verse">
因为 <b>动态</b> 的分配迭代器对象的本身是有代价的。<br/>
一般情况使用分配在栈区上的具体迭代器即可。<br/>
</p>


</li>
<li>多态意味着需要用new，也就需要用户负责删除它们，这样容易引发错误。

<p class="verse">
可以使用<a href="#sec-11">Proxy</a>模式，在栈区创建一个代理迭代器对象，在代理迭代器析构中<br/>
释放具体迭代器对象。不能用工厂是因为工厂只负责对象的创建。<br/>
</p>




<pre class="src src-c++"><span style="color: #ff6347;">IteratorProxy</span>::<span style="color: #00008b; font-weight: bold;">IteratorProxy</span>(<span style="color: #daa520;">Type</span> <span style="color: #008b8b;">type</span>)
{
    <span style="color: #1e90ff; font-weight: bold;">if</span> (type == Type.Reverse) <span style="color: #daa520;">Iterator</span>* <span style="color: #008b8b;">m_iter</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">ReverseIterator</span>();
    ...
}

<span style="color: #ff6347;">IteratorProxy</span>::~<span style="color: #00008b; font-weight: bold;">IteratorProxy</span>()
{
    <span style="color: #1e90ff; font-weight: bold;">delete</span> m_iter;
}

<span style="color: #daa520;">int</span> <span style="color: #00008b; font-weight: bold;">main</span>()
{
    <span style="color: #daa520;">IteratorProxy</span> <span style="color: #008b8b;">iter</span>(Type.Reverse);
    iter.next();
    ...
    <span style="color: #1e90ff; font-weight: bold;">return</span> 0;
}

</pre>

</li>
</ul>



<ul>
<li>仅在必须要使用多态时才使用。
</li>
</ul>


</div>

</div>

<div id="outline-container-13-6-5" class="outline-4">
<h4 id="sec-13-6-5"><span class="section-number-4">13.6.5</span> 迭代器与集合的紧密耦合</h4>
<div class="outline-text-4" id="text-13-6-5">

<p>迭代器一般作为集合的一个扩展，两者之间是紧密耦合的。
</p>
<ul>
<li id="sec-13-6-5-1">利用C++友元实现<br/>

<p class="verse">
C++中迭代器可作为它的集合类的一个友元，<br/>
这样集合类中就不必定义一些只有迭代器才用的到的方法。<br/>
当然这破坏了集合类的封装性，但这点仅仅是针对迭代器而言的。<br/>
<br/>
问题：<br/>
当定义新的ConcreteIterator(为了增加新的遍历方式)时，需要为集合类加上另一个友元。<br/>
<br/>
解决办法：<br/>
为避免该问题，集合类可定义迭代器父类为友元，<br/>
迭代器子类通过包含一些protected操作，来访问集合类非公共可见成员。<br/>
</p>


</li>
</ul>
</div>

</div>

<div id="outline-container-13-6-6" class="outline-4">
<h4 id="sec-13-6-6"><span class="section-number-4">13.6.6</span> 与<a href="#sec-16">Composite</a>模式的协作</h4>
<div class="outline-text-4" id="text-13-6-6">

</div>

</div>

<div id="outline-container-13-6-7" class="outline-4">
<h4 id="sec-13-6-7"><span class="section-number-4">13.6.7</span> 空迭代器</h4>
<div class="outline-text-4" id="text-13-6-7">


<p class="verse">
用于处理边界条件。<br/>
一个NullIterator的IsDone()总是返回true，或者HasNext()总是返回false。<br/>
<br/>
提示：<br/>
空迭代器更多的用于处理树形结构的集合。<br/>
叶结点通常需要一个NullIterator。<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-13-7" class="outline-3">
<h3 id="sec-13-7"><span class="section-number-3">13.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-13-7">

<ul>
<li>迭代器可在<a href="#sec-16">Composite</a>模式这样的递归结构上使用。
</li>
<li>多态迭代器可以通过<a href="#sec-8-2">Factory Method</a>模式来实例化迭代器子类。
</li>
<li>迭代器可使用一个<a href="#memento">memento</a>来捕获一个迭代状态，即迭代器内部存储<a href="#memento">memento</a>。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-14" class="outline-2">
<h2 id="sec-14"><a name="Bridge" id="Bridge"></a><span class="section-number-2">14</span> 桥接模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="__">对象</span>&nbsp;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-14">


</div>

<div id="outline-container-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> 概述</h3>
<div class="outline-text-3" id="text-14-1">

<p>分离抽象部分与实现部分，使得抽象部分也能被改变。
</p></div>

</div>

<div id="outline-container-14-2" class="outline-3">
<h3 id="sec-14-2"><span class="section-number-3">14.2</span> 适用性</h3>
<div class="outline-text-3" id="text-14-2">

<ul>
<li>多用于需要跨多个平台的GUI部分。
</li>
</ul>

</div>

</div>

<div id="outline-container-14-3" class="outline-3">
<h3 id="sec-14-3"><span class="section-number-3">14.3</span> 结构</h3>
<div class="outline-text-3" id="text-14-3">



<p>
<img src="../resources/OO/Bridge.png"  alt="../resources/OO/Bridge.png" />
</p>
</div>

</div>

<div id="outline-container-14-4" class="outline-3">
<h3 id="sec-14-4"><span class="section-number-3">14.4</span> 优缺点</h3>
<div class="outline-text-3" id="text-14-4">


</div>

<div id="outline-container-14-4-1" class="outline-4">
<h4 id="sec-14-4-1"><span class="section-number-4">14.4.1</span> 优点</h4>
<div class="outline-text-4" id="text-14-4-1">

<ul>
<li>将实现解耦，不再与界面(接口)绑定死。
</li>
<li>接口也可独立扩展。
</li>
<li>对接口扩展也不会影响到现有客户。
</li>
</ul>

</div>

</div>

<div id="outline-container-14-4-2" class="outline-4">
<h4 id="sec-14-4-2"><span class="section-number-4">14.4.2</span> 缺点</h4>
<div class="outline-text-4" id="text-14-4-2">

<ul>
<li>增加架构复杂度
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-14-5" class="outline-3">
<h3 id="sec-14-5"><span class="section-number-3">14.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-14-5">


</div>

<div id="outline-container-14-5-1" class="outline-4">
<h4 id="sec-14-5-1"><span class="section-number-4">14.5.1</span> Implementor具体对象的创建</h4>
<div class="outline-text-4" id="text-14-5-1">

<ul>
<li>可由Abstraction的构造方法的参数，在构造中确定创建哪个对象。
</li>
<li>可提供缺省的创建，根据需要改变具体对象。
</li>
<li>代理给其他对象，由其他对象来决定。

<p class="verse">
比如，由一些factory对象来决定，可以使Abstraction<br/>
和Implementor对象彻底解耦。<br/>
</p>


</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-14-6" class="outline-3">
<h3 id="sec-14-6"><span class="section-number-3">14.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-14-6">


<p class="verse">
<a href="#sec-10">Adapter</a> 通常在系统设计完成后才会被使用， Bridge则在系统设计开始<br/>
时就被使用，它使得抽象与实现可以独立的进行改变。<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-15" class="outline-2">
<h2 id="sec-15"><a name="Builder" id="Builder"></a><span class="section-number-2">15</span> 生成器模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">创建型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-15">


</div>

<div id="outline-container-15-1" class="outline-3">
<h3 id="sec-15-1"><span class="section-number-3">15.1</span> 概述</h3>
<div class="outline-text-3" id="text-15-1">

<p>将一个复杂对象的创建过程封装起来，提供接口创建复杂对象的各部件。
</p></div>

</div>

<div id="outline-container-15-2" class="outline-3">
<h3 id="sec-15-2"><span class="section-number-3">15.2</span> 结构</h3>
<div class="outline-text-3" id="text-15-2">



<p>
<img src="../resources/OO/Builder.png"  alt="../resources/OO/Builder.png" />
</p>
</div>

</div>

<div id="outline-container-15-3" class="outline-3">
<h3 id="sec-15-3"><span class="section-number-3">15.3</span> 角色</h3>
<div class="outline-text-3" id="text-15-3">

<ul>
<li>Builder

<p>
  为创建一个Product对象的各个部件指定抽象接口。
</p>
</li>
<li>ConcreteBuilder
<ul>
<li>实现Builder的接口以构造和装配该产品的各个部件
</li>
<li>定义产品的内部表示，及其各部件的装配过程
</li>
<li>提供一个检索产品的接口GetResult

</li>
</ul>

</li>
<li>Director

<p>  
  构造一个使用Builder接口的对象
</p></li>
</ul>


</div>

</div>

<div id="outline-container-15-4" class="outline-3">
<h3 id="sec-15-4"><span class="section-number-3">15.4</span> 流程图</h3>
<div class="outline-text-3" id="text-15-4">



<p>
<img src="../resources/OO/BuilderSeq.png"  alt="../resources/OO/BuilderSeq.png" />
</p>
</div>

</div>

<div id="outline-container-15-5" class="outline-3">
<h3 id="sec-15-5"><span class="section-number-3">15.5</span> 效果</h3>
<div class="outline-text-3" id="text-15-5">

<ul>
<li>只需定义一个新的生成器就可以改变产品内部表示
</li>
<li>创建与表示分开，客户无需知道产品内部的部件类
</li>
</ul>

</div>

</div>

<div id="outline-container-15-6" class="outline-3">
<h3 id="sec-15-6"><span class="section-number-3">15.6</span> 实现</h3>
<div class="outline-text-3" id="text-15-6">

<ul>
<li>产品不是抽象类？

<p>
  通常具体生成器生成的产品之间相差很大，不太可能有公有接口。
</p>
</li>
<li>通常缺省BuildPart方法什么也不做，但非纯虚方法
</li>
</ul>


</div>

</div>

<div id="outline-container-15-7" class="outline-3">
<h3 id="sec-15-7"><span class="section-number-3">15.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-15-7">

<ul>
<li><a href="#sec-8-3">Abstract Factory</a>着重于多个系列产品对象，生成器专注于创建复杂对象，最后一步才返回产品。
</li>
<li><a href="#sec-16">Composite</a>通常是用Builder生成的。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-16" class="outline-2">
<h2 id="sec-16"><a name="Composite" id="Composite"></a><span class="section-number-2">16</span> 组合模式 &nbsp;&nbsp;&nbsp;<span class="tag"><span class="___">结构型</span>&nbsp;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-16">


</div>

<div id="outline-container-16-1" class="outline-3">
<h3 id="sec-16-1"><span class="section-number-3">16.1</span> 概述</h3>
<div class="outline-text-3" id="text-16-1">


<p class="verse">
将对象组合成树形结构，表现出“整体/部分”的层次。<br/>
用户对于单个对象的使用和组合对象的使用具有一致性。<br/>
</p>


</div>

</div>

<div id="outline-container-16-2" class="outline-3">
<h3 id="sec-16-2"><span class="section-number-3">16.2</span> 结构</h3>
<div class="outline-text-3" id="text-16-2">



<p>
<img src="../resources/OO/Composite.png"  alt="../resources/OO/Composite.png" />
</p>
</div>

</div>

<div id="outline-container-16-3" class="outline-3">
<h3 id="sec-16-3"><span class="section-number-3">16.3</span> 角色</h3>
<div class="outline-text-3" id="text-16-3">

<ul>
<li>Component
<ul>
<li>声明组合和叶对象的一致操作Operation。
</li>
<li>在适当情况下，实现所有类的默认行为。
</li>
<li>声明用于访问和管理Component子部件的接口。
</li>
</ul>

</li>
<li>Composite
<ul>
<li>实现有子部件的Operation行为。
</li>
<li>存储子部件。
</li>
<li>实现访问和管理子部件的接口。
</li>
</ul>

</li>
</ul>

</div>

</div>

<div id="outline-container-16-4" class="outline-3">
<h3 id="sec-16-4"><span class="section-number-3">16.4</span> 优点</h3>
<div class="outline-text-3" id="text-16-4">

<ul>
<li>简化客户代码，客户可以一致的使用组合对象和叶对象。

<p class="verse">
用户不关心是何种对象，也就不需要写一些选择语句。  <br/>
</p>


</li>
<li>容易增加新类型的组件。
</li>
</ul>


</div>

</div>

<div id="outline-container-16-5" class="outline-3">
<h3 id="sec-16-5"><span class="section-number-3">16.5</span> 实现</h3>
<div class="outline-text-3" id="text-16-5">

<ul>
<li>子部件可保存父部件的引用。

<p class="verse">
父部件引用也支持<a href="#sec-17">Chain of Responsibility</a>。<br/>
父部件引用一般定义在Component类中。<br/>
</p>


</li>
<li>共享组件，可减少对存储的需求。

</li>
<li>透明性与安全性的权衡

<p class="verse">
如需更多的透明性，将操作子部件的Add操作和Remove操作在Component类中定义。<br/>
如需更高的安全性，将这些操作在Composite类中定义。安全性会需要用到类型转换。<br/>
</p>


</li>
<li>存储子结点的引用集合

<p class="verse">
对于叶结点而言，会有一定的空间浪费，需考虑。<br/>
</p>


</li>
<li>子部件顺序问题

<p class="verse">
有时候子结点的顺序可能是有意义的。比如语法分析树。<br/>
这时候需要仔细设计对子结点的访问和管理接口，可使用Iterator模式。<br/>
</p>


</li>
<li>Composite存储子结点的数据结构是可选的
</li>
</ul>


</div>

</div>

<div id="outline-container-16-6" class="outline-3">
<h3 id="sec-16-6"><span class="section-number-3">16.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-16-6">

<ul>
<li>部件到父部件的连接使用<a href="#sec-17">Chain of Responsibility</a>
</li>
<li><a href="#sec-6">Decorator</a>与Composite模式很像，事实上他们经常可以一起使用。
</li>
<li><a href="#Flyweight">Flyweight</a>可以帮助实现共享组件。
</li>
<li><a href="#sec-13">Iterator</a>可用来遍历Composite子部件。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-17" class="outline-2">
<h2 id="sec-17"><a name="Chain-of-Responsibility" id="Chain-of-Responsibility"></a><span class="section-number-2">17</span> 责任链模式</h2>
<div class="outline-text-2" id="text-17">


</div>

<div id="outline-container-17-1" class="outline-3">
<h3 id="sec-17-1"><span class="section-number-3">17.1</span> 概述</h3>
<div class="outline-text-3" id="text-17-1">


<p class="verse">
使多个对象都有机会处理请求，将这些对象连成一条链，沿着该链传递该请求，<br/>
直到有对象处理该请求为止。<br/>
</p>


</div>

</div>

<div id="outline-container-17-2" class="outline-3">
<h3 id="sec-17-2"><span class="section-number-3">17.2</span> 结构</h3>
<div class="outline-text-3" id="text-17-2">



<p>
<img src="../resources/OO/ChainOfResponsibility.png"  alt="../resources/OO/ChainOfResponsibility.png" />
</p>

</div>
</div>

</div>

<div id="outline-container-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> 一些OO提示</h2>
<div class="outline-text-2" id="text-18">


</div>

<div id="outline-container-18-1" class="outline-3">
<h3 id="sec-18-1"><span class="section-number-3">18.1</span> 活用空对象来避免null值检查</h3>
<div class="outline-text-3" id="text-18-1">




<pre class="src src-cpp"><span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Object</span>
{
<span style="color: #1e90ff; font-weight: bold;">public</span>:
    vitual <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">DoSomething</span>() = 0;
};

<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">NullObject</span> : <span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">Object</span>
{
<span style="color: #1e90ff; font-weight: bold;">public</span>:
    <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">DoSomething</span>();
};

<span style="color: #daa520;">void</span> <span style="color: #ff6347;">NullObject</span>::<span style="color: #00008b; font-weight: bold;">DoSomething</span>()
{
    <span style="color: #8b8989;">//</span><span style="color: #8b8989;">do nothing</span>
}
</pre>


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> hook操作缺省经常是一个空操作。空操作的意义：某些子类可能需要一些"特别"的操作，而大部分子类不需要。
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> 继承是在编译时静态扩展父类的职责，装饰者模式是动态的添加职责。
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.3" href="#fnr-.3">3</a></sup> 实现MapReduce中"Map"的一种方式。
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.4" href="#fnr-.4">4</a></sup> 具体代码示例参照《Gof设计模式》5.4 10
</p>


</div>
</div>
</div>

</div>
</div>
</div>

</body>
</html>
