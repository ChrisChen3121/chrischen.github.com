<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C# .Net</title>
<!-- 2016-05-01 Sun 12:03 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="ChrisChen" />
<meta  name="keywords" content="CSharp, .Net" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">C# .Net</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 类</a></li>
<li><a href="#sec-2">2. 集合</a>
<ul>
<li><a href="#sec-2-1">2.1. 集合接口一览</a></li>
<li><a href="#sec-2-2">2.2. List</a></li>
<li><a href="#sec-2-3">2.3. 性能</a></li>
</ul>
</li>
<li><a href="#sec-3">3. 异常</a></li>
<li><a href="#sec-4">4. 反射</a>
<ul>
<li><a href="#sec-4-1">4.1. 自定义特性</a></li>
<li><a href="#sec-4-2">4.2. 反射</a></li>
</ul>
</li>
<li><a href="#sec-5">5. 序列化及持久化</a>
<ul>
<li><a href="#sec-5-1">5.1. 概述</a></li>
<li><a href="#sec-5-2">5.2. Serializable特性</a></li>
<li><a href="#sec-5-3">5.3. IFormatter接口</a></li>
<li><a href="#sec-5-4">5.4. 序列化为Binary示例</a></li>
<li><a href="#sec-5-5">5.5. 拓展</a></li>
</ul>
</li>
<li><a href="#sec-6">6. 多线程</a>
<ul>
<li><a href="#sec-6-1">6.1. 创建线程</a></li>
<li><a href="#sec-6-2">6.2. 同步问题</a></li>
<li><a href="#sec-6-3">6.3. Timer类</a></li>
<li><a href="#sec-6-4">6.4. 总结</a></li>
<li><a href="#sec-6-5">6.5. 推荐阅读</a></li>
</ul>
</li>
<li><a href="#sec-7">7. 诊断</a>
<ul>
<li><a href="#sec-7-1">7.1. 跟踪(Trace)</a></li>
<li><a href="#sec-7-2">7.2. 事件日志</a></li>
<li><a href="#sec-7-3">7.3. 性能</a></li>
<li><a href="#sec-7-4">7.4. 代码约定</a></li>
</ul>
</li>
<li><a href="#sec-8">8. 程序集</a>
<ul>
<li><a href="#sec-8-1">8.1. 共享程序集</a></li>
<li><a href="#sec-8-2">8.2. Useful Utility</a></li>
</ul>
</li>
<li><a href="#sec-9">9. 部署</a>
<ul>
<li><a href="#sec-9-1">9.1. 自定义安装包</a></li>
</ul>
</li>
<li><a href="#sec-10">10. WebService</a></li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类</h2>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 集合</h2>
<div class="outline-text-2" id="text-2">
<p class="verse">
一般集合类在System.Collections(ArrayList)<br  />
泛型集合类在System.Collections.Generic<br  />
特定类型的集合类在System.Collections.Specialized<br  />
线程安全的集合类在System.Collections.Concurrent<br  />
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 集合接口一览</h3>
<div class="outline-text-3" id="text-2-1">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">接口</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">IEnumerable&lt;T&gt;</td>
<td class="left">实现了该接口可用foreach遍历，定义了方法GetEnumerator()，返回一个实现了IEnumerator接口的枚举。</td>
</tr>

<tr>
<td class="left">ICollection&lt;T&gt;</td>
<td class="left">定义了Count属性、复制到数组的CopyTo()、Add()、Remove()、Clear()</td>
</tr>

<tr>
<td class="left">IList&lt;T&gt;</td>
<td class="left">继承自ICollection。增加了一个索引器(List[index])，可以在指定位置插入删除项Insert()和RemoveAt()</td>
</tr>

<tr>
<td class="left">IDictionary&lt;TKey, TValue&gt;</td>
<td class="left">键值对泛型集合。一键一值。</td>
</tr>

<tr>
<td class="left">ILookup&lt;TKey, TValue&gt;</td>
<td class="left">类似于IDictionary。一键多值。</td>
</tr>

<tr>
<td class="left">IComparable&lt;T&gt;</td>
<td class="left">定义方法CompareTo()</td>
</tr>

<tr>
<td class="left">IComparer&lt;T&gt;</td>
<td class="left">由比较器实现，定义Compare()方法用于排序。</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> List</h3>
<div class="outline-text-3" id="text-2-2">
</div><ol class="org-ol"><li><a id="sec-2-2-1" name="sec-2-2-1"></a>创建<br  /><div class="outline-text-4" id="text-2-2-1">
<div class="org-src-container">

<pre class="src src-csharp">var intList = new List&lt;int&gt;(); //默认创建容量为4个元素，如果Add时超出最大容量，则将最大容量*2
var intList = new List&lt;int&gt;(10);//指定先创建10个元素的容量，Add时超出，处理和上面一样
intList.Capacity = 20;//还可以使用Capacity设定
intList.TrimExcess();//不希望再往List中添加元素时使用。去除不需要的容量
</pre>
</div>
<p>
容量改变了整个集合就会被分配一个新的内存块。
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> 性能</h3>
<div class="outline-text-3" id="text-2-3">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Collection</th>
<th scope="col" class="left">Add</th>
<th scope="col" class="left">Insert</th>
<th scope="col" class="left">Remove</th>
<th scope="col" class="left">Item</th>
<th scope="col" class="left">Sort</th>
<th scope="col" class="left">Find</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">List</td>
<td class="left">O(1)/O(n)</td>
<td class="left">O(n)</td>
<td class="left">O(n)</td>
<td class="left">O(1)</td>
<td class="left">B:O(nlong) W:O(n^2)</td>
<td class="left">O(n)</td>
</tr>

<tr>
<td class="left">Stack</td>
<td class="left">O(1)/O(n)</td>
<td class="left">na</td>
<td class="left">Pop(),O(1)</td>
<td class="left">na</td>
<td class="left">na</td>
<td class="left">na</td>
</tr>

<tr>
<td class="left">Queue</td>
<td class="left">O(1)/O(n)</td>
<td class="left">na</td>
<td class="left">Dequeue(),O(1)</td>
<td class="left">na</td>
<td class="left">na</td>
<td class="left">na</td>
</tr>

<tr>
<td class="left">HashSet</td>
<td class="left">O(1)/O(n)</td>
<td class="left">同Add()</td>
<td class="left">O(1)</td>
<td class="left">na</td>
<td class="left">na</td>
<td class="left">na</td>
</tr>

<tr>
<td class="left">LinkedList</td>
<td class="left">O(1)</td>
<td class="left">O(1)</td>
<td class="left">O(1)</td>
<td class="left">na</td>
<td class="left">na</td>
<td class="left">O(n)</td>
</tr>

<tr>
<td class="left">Dictionary</td>
<td class="left">O(1)/O(n)</td>
<td class="left">na</td>
<td class="left">O(1)</td>
<td class="left">O(1)</td>
<td class="left">na</td>
<td class="left">na</td>
</tr>

<tr>
<td class="left">SortedDictionary</td>
<td class="left">O(nlogn)</td>
<td class="left">na</td>
<td class="left">O(n)</td>
<td class="left">O(logn)</td>
<td class="left">na</td>
<td class="left">na</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 异常</h2>
<div class="outline-text-2" id="text-3">
<ul class="org-ul">
<li>try&#x2026;finally&#x2026;语句块(非异常常规用法)
</li>
</ul>
<p class="verse">
省略catch，当try中语句有多个出口时，可以确保再出去前执行finally中的代码。<br  />
这看上去不错。<br  />
但是当try中真有异常发生时，程序会抛出异常，并且finally语句块不会正常执行！<br  />
</p>
<ul class="org-ul">
<li>可执行程序应捕获尽可能多的异常，类库最好不要捕获异常
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 反射</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 自定义特性</h3>
<div class="outline-text-3" id="text-4-1">
</div><ol class="org-ol"><li><a id="sec-4-1-1" name="sec-4-1-1"></a>概述<br  /><div class="outline-text-4" id="text-4-1-1">
<div class="org-src-container">

<pre class="src src-csharp">[FieldNameAttribute("Name")]
//[FieldName("Name")]与上一条效果一样。说明"Attribute"是可省略的。
public string Name
{
    get ; set ;
}
</pre>
</div>
<p class="verse">
编译器发现这个 <b>属性</b> 应用了FieldName特性后，首先会将Attribute加上，<br  />
即变成FieldNameAttribute特性。然后再其所使用的所有命名空间中搜索特性<br  />
处理类(本例为FieldNameAttribute类)。定义了特性的这个类直接或者间接的<br  />
继承了System.Attribute类，编译器还会认为该类包含控制特性用法的信息。<br  />
<br  />
如果编译器找不到对应的特性类，或者使用特性的方式与特性类中的信息不匹配，<br  />
编译器会报错。<br  />
</p>
</div>
</li>
<li><a id="sec-4-1-2" name="sec-4-1-2"></a>定义特性类<br  /><div class="outline-text-4" id="text-4-1-2">
<div class="org-src-container">

<pre class="src src-csharp">[AttributeUsage(AttributeTargets.Property | AttributeTargets.Field,
                AllowMultiple=false,
                Inherited=false)]
public class FieldNameAttribute : Attribute
{
    private string name;
    public FieldNameAttribute(string name)
        {
            this.name = name;
        }
}
</pre>
</div>
<p class="verse">
首先，特性类本身用一个内建的特性AttributeUsage标记。<br  />
<br  />
第一个参数AttributeTargets为必选项，指定应用到哪些类型的元素上(示例表示该特性能用在属性或成员变量上)。<br  />
Assembly和Module类型有些特殊，说明该特性可以应用到整个程序集或模块的各类型元素中。<br  />
使用时需用关键字assembly或module作为前缀：[assembly:SomeAssemblyAttribute(Parameters)]<br  />
另一个应用到全局元素的类型是AttributeTargets.All。<br  />
<br  />
第二个参数表示是否可以多次用在同一个程序元素上。(可选参数)<br  />
<br  />
第三个参数表示特性应用在类或接口上时，是否可由子类继承。(可选参数)<br  />
</p>
</div>
</li>
<li><a id="sec-4-1-3" name="sec-4-1-3"></a>指定特性所接受的参数<br  /><div class="outline-text-4" id="text-4-1-3">
<p class="verse">
当编译遇到如下语句时：<br  />
[FieldName("Name")]<br  />
将查找特性类中是否有参数为字符串类型的构造函数。<br  />
</p>
<ul class="org-ul">
<li>指定可选参数
</li>
</ul>
<p class="verse">
在特性类中添加属性，以支持特性可选参数。<br  />
[FieldName("Name", Comment="This is a primary key")<br  />
Comment必须在特性类FieldNameAttribute中是一个string类型的属性。<br  />
</p>
</div>
</li></ol>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 反射</h3>
<div class="outline-text-3" id="text-4-2">
</div><ol class="org-ol"><li><a id="sec-4-2-1" name="sec-4-2-1"></a>System.Type类<br  /><div class="outline-text-4" id="text-4-2-1">
<p class="verse">
通过该类，可以访问关于任何数据类型的信息。<br  />
<br  />
使用Type类为了存储类型的引用。<br  />
Type t = typeof(double);<br  />
<br  />
也可以这样使用：<br  />
double d = 0;<br  />
Type t = d.GetType();<br  />
GetType()是.Net基类System.Object的方法。<br  />
<br  />
还可以使用Type类的静态方法手工指定类型：<br  />
Type t = Type.GetType("System.Double");<br  />
<br  />
还可以获取定义该类型的程序集的引用：<br  />
Type t = typeof(CustomizeClass);<br  />
Assembly containingAssembly = new Assembly(t);<br  />
</p>
</div>
<ul class="org-ul"><li><a id="sec-4-2-1-1" name="sec-4-2-1-1"></a>Type类常用属性<br  /><div class="outline-text-5" id="text-4-2-1-1">
<p>
Name、FullName、Namespace、BaseType、UnderlyingSystemType、IsClass(IsAbstract、IsEnum等。
</p>
</div>
</li>
<li><a id="sec-4-2-1-2" name="sec-4-2-1-2"></a>Type类方法<br  /><div class="outline-text-5" id="text-4-2-1-2">
<p>
GetMethod、GetMethods
</p>
</div>
</li></ul>
</li>
<li><a id="sec-4-2-2" name="sec-4-2-2"></a>System.Reflection.Assembly类<br  /><div class="outline-text-4" id="text-4-2-2">
<p class="verse">
System.Reflection.Assembly 可以用于访问给定程序集的相关信息。<br  />
<br  />
首先使用Load或者LoadForm加载程序集。<br  />
- Assembly.Load()的参数传入程序集名称，运行库会在本地目录和全局程序集缓存中查找该程序集。<br  />
- Assembly.LoadForm()的参数需传入程序集的完整路径。<br  />
<br  />
列出一些常用的方法：<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">Assembly assemblyTest = Assembly.Load("SomeAssembly");
string name = assemblyTest.FullName;

//以下获取的是Assembly类型的Attribute
Attribute[] assemblyAttributes = Attribute.GetCustomAttributes(assemblyTest);

//以下获取的是Class类型的Attribute
Type[] types = assemblyTest.GetTypes();
foreach (var type in types)
{
    Attribute[] classAttributes = Attribute.GetCustomAttributes(type);

    //以下获取的是Method类型的Attribute
    MemberInfo[] methods = type.GetMethods();
    foreach (var method in methods)
    {
        Attribute methodAttribute = Attribute.GetCustomAttributes(method);
    }
}
</pre>
</div>
</div>
</li>
<li><a id="sec-4-2-3" name="sec-4-2-3"></a>示例参照<i>ReflectionDemo</i><br  /></li>
<li><a id="sec-4-2-4" name="sec-4-2-4"></a>常用类列表<br  /></li></ol>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 序列化及持久化</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 概述</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>序列化：将对象转换成字节流的过程称为序列化。反之，则称反序列化。
</li>
<li>持久化：将对象存储在一些持久性的媒介(例：内存为非持久性媒介，硬盘是持久性媒介)上称为持久化。
</li>
</ul>
<p class="verse">
命名空间System.Runtime.Serialization和System.Runtime.Serialization.Formatters提供了序列化对象的基础架构。<br  />
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Serializable特性</h3>
<div class="outline-text-3" id="text-5-2">
<p class="verse">
要使某对象能够进行序列化，需要对类标注[Serializable]特性。<br  />
还可以对类成员分别标注[NonSerialized]特性，标出不需要序列化的成员。例：<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">[Serializable]
class Person
{
    public string Name;//属性也可被序列化
    private int Age { get; set; }//可被序列化
    [NonSerialized]public string Phone;//该字段不会被序列化，注：NonSerialized特性只能标准字段。
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> IFormatter接口</h3>
<div class="outline-text-3" id="text-5-3">
<p class="verse">
只要实现了IFormatter接口的类都提供了序列化过程的具体实现，也可以<br  />
自定义一个类实现该接口支持序列化特殊格式的字符流。该接口定义如下：<br  />
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">方法</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">void Serialize(Stream stream, object source)</td>
<td class="left">把source序列化为stream</td>
</tr>

<tr>
<td class="left">object Deserialize(Stream stream)</td>
<td class="left">反序列化stream，返回object</td>
</tr>
</tbody>
</table>

<p>
注：如果stream是个FileStream类型，将其写入文件，这也就是将对象object持久化了。
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 序列化为Binary示例</h3>
<div class="outline-text-3" id="text-5-4">
<p class="verse">
Binary是常用的序列化形式之一，简单介绍下它的使用，其他形式的使用方式类似。<br  />
命名空间：System.Runtime.Serialization.Formatters.Binary<br  />
类：BinaryFormatter<br  />
作用：能把对象序列化为二进制流，同样支持反序列化。<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">//序列化
IFomatter serializer = new BinaryFormatter();
serializer.Serialize(myStream, myObject);

//反序列化
IFomatter serializer = new BinaryFormatter();
MyObjectType myObject = serializer.Deserialize(MyStream) as MyObjectType;
</pre>
</div>
<p>
完整示例：<a href="http://files.cnblogs.com/ChrisChen3121/Serialization.rar">Serialization.rar</a>
</p>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 拓展</h3>
<div class="outline-text-3" id="text-5-5">
</div><ol class="org-ol"><li><a id="sec-5-5-1" name="sec-5-5-1"></a>ISerializable接口<br  /><div class="outline-text-4" id="text-5-5-1">
<p class="verse">
另外，如果类需要控制自身的序列化过程，则需要实现ISerializable接口，<br  />
在GetObjectData修改SerializationInfo的信息。详细参考<a href="http://msdn.microsoft.com/en-us/library/wf4375ks(v=vs.90).aspx">MSDN</a>。<br  />
</p>
</div>
</li>
<li><a id="sec-5-5-2" name="sec-5-5-2"></a>一些.Net序列化类<br  /><div class="outline-text-4" id="text-5-5-2">
<p>
下表列出了.Net提供的其他一些序列化类：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">类名</th>
<th scope="col" class="left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">SoapFormatter</td>
<td class="left">序列化为Soap格式的XML数据</td>
</tr>

<tr>
<td class="left">ObjectStateFormatter</td>
<td class="left">在ASP.Net中序列化viewstate</td>
</tr>

<tr>
<td class="left">NetDataContractSerializer</td>
<td class="left">用于序列化WCF数据合同</td>
</tr>
</tbody>
</table>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 多线程</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 创建线程</h3>
<div class="outline-text-3" id="text-6-1">
</div><ol class="org-ol"><li><a id="sec-6-1-1" name="sec-6-1-1"></a>异步委托方式<br  /><div class="outline-text-4" id="text-6-1-1">
<p class="verse">
使用异步委托创建的线程，都是由.Net线程池维护的。<br  />
线程池中的线程总是后台线程。<br  />
为了方便起见，接下来使用的共通委托方法如下<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>：<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">static int TakesAWhile(int data, int ms)
{
    Console.WriteLine("TakesAWhile started");
    Thread.Sleep(ms);
    Console.WriteLine("TakesAWhile completed");
    return ++data;
}
</pre>
</div>
</div>
<ul class="org-ul"><li><a id="sec-6-1-1-1" name="sec-6-1-1-1"></a>IAsyncResult.IsCompleted<br  /><div class="outline-text-5" id="text-6-1-1-1">
<p class="verse">
根据IAsyncResult.IsCompleted判断异步委托是否执行完成。<br  />
EndInvoke获取返回值。<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">TakesAWhileDelegate dl = TakesAWhile;
IAsyncResult ar = dl.BeginInvoke(1, 3000, null, null);
while (!ar.IsCompleted)
{
    Console.Write(".");
    Thread.Sleep(50);
}
int result = dl.EndInvoke(ar);
Console.WriteLine("result: {0}", result);
</pre>
</div>
</div>
</li>
<li><a id="sec-6-1-1-2" name="sec-6-1-1-2"></a>IAsyncResult.AsyncWaitHandle<br  /><div class="outline-text-5" id="text-6-1-1-2">
<p>
使用WaitHandle，可指定异步调用的超时时间进行后续处理。
</p>
<div class="org-src-container">

<pre class="src src-csharp">TakesAWhileDelegate dl = TakesAWhile;
IAsyncResult ar = dl.BeginInvoke(1, 3000, null, null);
if (!ar.AsyncWaitHandle.WaitOne(200, false))
{
    Console.WriteLine("Thread not invoked.");
}
if (ar.AsyncWaitHandle.WaitOne(3000, false))
{
    int result = dl.EndInvoke(ar);
    Console.WriteLine("result: {0}", result);
}
</pre>
</div>
</div>
</li>
<li><a id="sec-6-1-1-3" name="sec-6-1-1-3"></a>AsyncCallBack<br  /><div class="outline-text-5" id="text-6-1-1-3">
<p>
通过传入回调函数，进行后续处理
</p>
</div>
<ul class="org-ul"><li><a id="sec-6-1-1-3-1" name="sec-6-1-1-3-1"></a>分支一：单独定义回调方法<br  /><div class="outline-text-6" id="text-6-1-1-3-1">
<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
{
    TakesAWhileDelegate dl = TakesAWhile;
    dl.BeginInvoke(1, 3000, TakesAWhileCompleted, dl);
    //必须程序主线程一直存在才会执行回调方法，所以使用了如下for循环(说明了异步委托所创建的线程是一个后台线程)
    for (int i = 0; i &lt; 100; i++ )
    {
        Console.Write(".");
        Thread.Sleep(50);
    }
}

//定义回调方法
static void TakesAWhileCompleted(IAsyncResult ar)
{
    if (ar == null)
    {
        throw new ArgumentNullException("ar");
    }
    TakesAWhileDelegate dl = ar.AsyncState as TakesAWhileDelegate;
    Trace.Assert(dl != null, "Invalid object type");
    int result = dl.EndInvoke(ar);
    Console.WriteLine("result: {0}", result);
}
</pre>
</div>
</div>
</li>
<li><a id="sec-6-1-1-3-2" name="sec-6-1-1-3-2"></a>分支二：使用lambada表达式<br  /><div class="outline-text-6" id="text-6-1-1-3-2">
<div class="org-src-container">

<pre class="src src-csharp">TakesAWhileDelegate dl = TakesAWhile;
dl.BeginInvoke(1, 3000,
               //这是个回调函数，使用lambada表达式的话，代码不够清晰。
               ar =&gt;
    {
        int result = dl.EndInvoke(ar);//lambda表达式可使用该作用域外部的变量dl
        Console.WriteLine("result: {0}", result);
    },
               null);
//必须程序主线程一直存在才会执行回调方法
for (int i = 0; i &lt; 100; i++)
{
    Console.Write(".");
    Thread.Sleep(50);
}
</pre>
</div>
</div>
</li></ul>
</li></ul>
</li>

<li><a id="sec-6-1-2" name="sec-6-1-2"></a>Thread类<br  /><ul class="org-ul"><li><a id="sec-6-1-2-1" name="sec-6-1-2-1"></a>无参数线程方法<br  /><div class="outline-text-5" id="text-6-1-2-1">
<div class="org-src-container">

<pre class="src src-csharp">var t1 = new Thread(() =&gt; Console.WriteLine("running in a thread, id {0}", Thread.CurrentThread.ManagedThreadId));
t1.Start();
Console.WriteLine("This is a main thread, id {0}", Thread.CurrentThread.ManagedThreadId);
</pre>
</div>
</div>
</li>
<li><a id="sec-6-1-2-2" name="sec-6-1-2-2"></a>有参数线程方法<br  /><div class="outline-text-5" id="text-6-1-2-2">
<div class="org-src-container">

<pre class="src src-csharp">public struct Data
{
    public string Message;
}

static int TakesAWhile(int data, int ms)
{
    var d = new Data { Message = "Info" };
    var t2 = new Thread((object obj) =&gt;
        {
            Data data = (Data)obj;
            Console.WriteLine("running in a thread, id {0}, Data {1}", Thread.CurrentThread.ManagedThreadId, data.Message);
        });
    t2.Start(d);
    Console.WriteLine("This is a main thread, id {0}", Thread.CurrentThread.ManagedThreadId);
}
</pre>
</div>
</div>
</li>

<li><a id="sec-6-1-2-3" name="sec-6-1-2-3"></a>后台线程<br  /><div class="outline-text-5" id="text-6-1-2-3">
<p>
Thread类默认创建的是前台线程，设定IsBackground属性可转为后台线程
</p>
<div class="org-src-container">

<pre class="src src-csharp">var t1 = new Thread(
    () =&gt;
    {
        Console.WriteLine("branch thread Start, id {0}", Thread.CurrentThread.ManagedThreadId);
        Thread.Sleep(3000);
        Console.WriteLine("branch thread End");
    })
{ Name = "NewBKThread", IsBackground = true };
t1.Start();
Thread.Sleep(50);//为了使后台线程的情况下，能打出branch thread Start, id
Console.WriteLine("This is a main thread, id {0}", Thread.CurrentThread.ManagedThreadId);
</pre>
</div>
<ul class="org-ul">
<li>IsBackground = true 结果：
</li>
</ul>
<p class="verse">
branch thread Start, id 3<br  />
This is a main thread, id 1<br  />
</p>
<ul class="org-ul">
<li>IsBackground = false 结果：
</li>
</ul>
<p class="verse">
branch thread Start, id 3<br  />
This is a main thread, id 1<br  />
branch thread End<br  />
</p>
</div>
</li>

<li><a id="sec-6-1-2-4" name="sec-6-1-2-4"></a>关于线程优先级<br  /><div class="outline-text-5" id="text-6-1-2-4">
<p class="verse">
可以通过Thread.Priority属性调整线程的 <b>基本</b> 优先级。实际线程调度器会动态调整优先级<br  />
频繁使用CPU的线程的优先级会动态调低，等待资源(等待磁盘IO完成等)的线程会动态调高优先级。<br  />
以便在下次等待结束时获得CPU资源。<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup><br  />
</p>
</div>
</li>

<li><a id="sec-6-1-2-5" name="sec-6-1-2-5"></a>线程状态<br  /><div class="outline-text-5" id="text-6-1-2-5">
<p class="verse">
通过属性Thread.ThreadState获取当前线程状态<br  />
<br  />
运行Thread.Start()后，状态为Unstarted。<br  />
系统线程调度器选择了运行该线程后，状态为Running。<br  />
调用Thread.Sleep()，状态为WaitSleepJoin。<br  />
<br  />
停止另一个线程，调用Thread.Abort()。接到中止命令的线程中会抛出ThreadAbortException。<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup><br  />
涉及的状态有AbortRequested、Aborted。<br  />
继续停止的线程，调用Thread.ResetAbort()。线程将会在抛出ThreadAbortException后的语句后继续进行。<br  />
<br  />
等待线程的结束，调用ThreadInstance.Join()。<br  />
该调用会停止 <b>当前</b> 线程，当前线程状态设为WaitSleepJoin。<br  />
等待加入的线程处理完成，再继续当前线程的处理。<br  />
</p>
</div>
</li></ul>
</li>

<li><a id="sec-6-1-3" name="sec-6-1-3"></a>线程池<br  /><div class="outline-text-4" id="text-6-1-3">
<p>
超出最大线程数时，QueueUserWorkItem会等待获取线程资源时再调用。
</p>
<div class="org-src-container">

<pre class="src src-csharp">static void Main(string[] args)
{
    ThreadPool.SetMinThreads(3, 3);//创建线程池时启动的最小线程数
    ThreadPool.SetMaxThreads(10, 10);//最大线程数
    for (int i = 0; i &lt; 5; i++ )
    {
        ThreadPool.QueueUserWorkItem(JobForAThread);
    }
    Thread.Sleep(3000);//由于是后台线程，需要使主线程等一会，否则程序直接退出
}

static void JobForAThread(object state)
{
    for (int i = 0; i &lt; 3; i++)
    {
        Console.WriteLine("loop {0}, running inside pooled thread {1}", i, Thread.CurrentThread.ManagedThreadId);
    }
}
</pre>
</div>
<p>
使用线程池的限制：
</p>
<ul class="org-ul">
<li>其中的所有线程只能是后台线程。
</li>
<li>无法设置线程的优先级或名称。
</li>
<li><b>关键点</b> 适用于耗时较短的任务。长期运行的线程，应使用Thread类创建。
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 同步问题</h3>
<div class="outline-text-3" id="text-6-2">
</div><ol class="org-ol"><li><a id="sec-6-2-1" name="sec-6-2-1"></a>lock关键字<br  /><div class="outline-text-4" id="text-6-2-1">
<p class="verse">
只能锁定引用类型，锁定值类型等于锁定了一个副本，没有意义，编译器也不允许你这么做。<br  />
使用锁定需要时间，并不总是必须。可以创建类的两个版本，一个同步版本，一个异步版本。<br  />
</p>
</div>
<ul class="org-ul"><li><a id="sec-6-2-1-1" name="sec-6-2-1-1"></a>将实例成员设为线程安全的<br  /><div class="outline-text-5" id="text-6-2-1-1">
<div class="org-src-container">

<pre class="src src-csharp">lock(this)
{
    //一次只有一个线程能访问相同实例的该语句块
}
</pre>
</div>
<p>
因为该实例对象也可用于外部访问，这样做会导致外部访问时也得等待该同步语句块执行完成。正确的做法：
</p>
<div class="org-src-container">

<pre class="src src-csharp">private object syncRoot = new object();
public void DoSomething()
{
    lock (object)
    {
        //Do something
    }
}

private static object syncRoot = new object();//可用于锁定类静态成员
</pre>
</div>
</div>
</li>
<li><a id="sec-6-2-1-2" name="sec-6-2-1-2"></a>lock关键字由编译器解析为Monitor类<br  /><div class="outline-text-5" id="text-6-2-1-2">
<div class="org-src-container">

<pre class="src src-csharp">lock (obj) {  };
</pre>
</div>
<p>
等价于：
</p>
<div class="org-src-container">

<pre class="src src-csharp">Monitor.Enter(obj);
try
{
}
finally
{
    Monitor.Exit(obj);
}
</pre>
</div>
<p>
与lock关键字的区别：
</p>
<ul class="org-ul">
<li>可添加一个等待解锁的超时时间，使用TryEnter传递超时值。
</li>
</ul>
<div class="org-src-container">

<pre class="src src-csharp">bool lockTaken = Monitor.TryEnter(obj, 500);
if (lockTaken)
{
    try
    {

    }
    finally
    {
        Monitor.Exit(obj);
    }
}
else
{
    //didn't get the lock, do something else
}
</pre>
</div>
</div>
</li>

<li><a id="sec-6-2-1-3" name="sec-6-2-1-3"></a>更快速的Interlocked类<br  /><div class="outline-text-5" id="text-6-2-1-3">
<p>
仅用于简单的针对变量赋值的同步问题
</p>
<div class="org-src-container">

<pre class="src src-csharp">lock(this)
{
    if (someState == null)
    {
        someState = newState;
    }
}
</pre>
</div>
<p>
等价于(可用于单件模式的GetInstance)：
</p>
<div class="org-src-container">

<pre class="src src-csharp">Interlocked.CompareExchange&lt;SomeState&gt;(ref someState, newState, null);//第一个参数和第三个参数比较，如果相等，替换为第二个参数的值
</pre>
</div>
<div class="org-src-container">

<pre class="src src-csharp">public int State
{
    get
    {
        lock (this)
        {
            return ++state;
        }
    }
}
</pre>
</div>
<p>
等价于：
</p>
<div class="org-src-container">

<pre class="src src-csharp">public int State
{
    get
    {
        return Interlocked.Increment(ref state);
    }
}
</pre>
</div>
</div>
</li></ul>
</li>
<li><a id="sec-6-2-2" name="sec-6-2-2"></a>WaitHandle<br  /><div class="outline-text-4" id="text-6-2-2">
<p class="verse">
WaitHandle是一个抽象基类。用于等待某个信号量。<br  />
Mutex、EventWaitHandle、Semaphore类都从WaitHandle派生。<br  />
</p>
</div>
</li>
<li><a id="sec-6-2-3" name="sec-6-2-3"></a>Mutex类<br  /><div class="outline-text-4" id="text-6-2-3">
<p class="verse">
提供进程之间的同步访问。创建一个进程之间能共享的以字符串命名的互斥锁。<br  />
构造函数的一种形式如下：<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">bool created;
Mutex mutex = new Mutex(false, "IFFileMutex", out created);
</pre>
</div>
<p class="verse">
其中，第一个参数定义了该互斥体的所有权是否应属于调用线程。<br  />
第二个参数是互斥体名字，操作系统能识别该字符串，以此实现各进程之间的同步。<br  />
第三个参数，如果系统中已存在该命名的互斥体返回false，否则返回true。<br  />
</p>
<div class="org-src-container">

<pre class="src src-csharp">Mutex mutex = Mutex.OpenExisting("IFFileMutex");//打开系统中已存在的互斥体
if(mutex.WaitOne(500))//500为等待超时时间
{
    try
    {
        //synchronized region
    }
    finally
    {
        mutex.ReleaseMutex();
    }
}
</pre>
</div>
</div>
</li>
<li><a id="sec-6-2-4" name="sec-6-2-4"></a>Semaphore类<br  /><div class="outline-text-4" id="text-6-2-4">
<p>
信号量可以同时由多个线程使用，是计数的互斥体。一般用于受数量限制的访问资源(如DB连接资源)。
</p>
</div>
</li>
<li><a id="sec-6-2-5" name="sec-6-2-5"></a>Event类<br  /><div class="outline-text-4" id="text-6-2-5">
<p class="verse">
系统级的资源同步方式，比之Mutex，多了个Reset方法，<br  />
重置nonsignaled的状态(等同于互斥体的锁定状态)，释放所有等待的线程。<br  />
<br  />
Set方法：将事件设为signaled状态，使其他等待的线程得以继续，类似锁的Release方法。<br  />
Waitone方法：等待事件被设为signaled状态。<br  />
Reset方法：将事件设为nonsignaled状态，并且阻塞所有等待的线程。<br  />
</p>
</div>
<ul class="org-ul"><li><a id="sec-6-2-5-1" name="sec-6-2-5-1"></a>AutoResetEvent<br  /><div class="outline-text-5" id="text-6-2-5-1">
<p class="verse">
Reset方法会在某一线程Waitone成功后，自动重置为nonsignaled。<br  />
达到的效果：一次只能一个线程继续处理。<br  />
</p>
</div>
</li>
<li><a id="sec-6-2-5-2" name="sec-6-2-5-2"></a>ManualResetEvent<br  /><div class="outline-text-5" id="text-6-2-5-2">
<p class="verse">
需手动调用Reset方法重置为nonsignaled。<br  />
达到的效果：多个线程都能继续进行处理。<br  />
</p>
</div>
</li></ul>
</li>
<li><a id="sec-6-2-6" name="sec-6-2-6"></a>ReaderWriterLockSlim类(.Net 3.5引入)<br  /><div class="outline-text-4" id="text-6-2-6">
<p class="verse">
如果没有Writer锁定资源，就允许多个Reader访问资源，但只能有一个<br  />
Writer锁定该资源(所有访问中的Reader都必须先释放锁)。<br  />
比之.Net 1.0版本 ReaderWriterLock类，重新设计为防止死锁，提供更好的性能。<br  />
</p>
<ul class="org-ul">
<li>EnterReadLock
进入锁定，另一个方法TryEnterReadLock允许指定一个超时时间。ExitReadLock释放锁定
</li>
<li>EnterUpgradableReadLock
用于读取锁定需要改为写入锁定的情况。
</li>
<li>EnterWriteLock
获得多资源的写入锁定。仅一个线程能获取锁定，在这之前还必须释放所有的读取锁定。
</li>
</ul>
</div>
</li></ol>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Timer类</h3>
<div class="outline-text-3" id="text-6-3">
<p>
.Net提供了几个Timer类，比较如下：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">命名空间</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">System.Threading</td>
<td class="left">提供了Timer的核心功能，在构造函数中传入回调的委托。</td>
</tr>

<tr>
<td class="left">System.Timer</td>
<td class="left">继承Component，可在设计界面拖入，提供了基于事件的机制(非委托)。</td>
</tr>

<tr>
<td class="left">System.Windows.Forms</td>
<td class="left">为单线程环境设计的(创建和回调在同一个线程中执行)，执行回调方法时UI会假死，不宜执行耗时较长的代码。该Timer时间精度55ms。</td>
</tr>

<tr>
<td class="left">System.Web.UI</td>
<td class="left">是一个AJAX扩展，可以用于Web页面</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 总结</h3>
<div class="outline-text-3" id="text-6-4">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">类</th>
<th scope="col" class="left">目的</th>
<th scope="col" class="left">参考开销<sup><a id="fnr.4" name="fnr.4" class="footref" href="#fn.4">4</a></sup></th>
<th scope="col" class="left">是否跨进程？</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">lock(Monitor)</td>
<td class="left">保证单个进程内只有一个线程能够获取同步资源</td>
<td class="left">20ns</td>
<td class="left">No</td>
</tr>

<tr>
<td class="left">Mutex</td>
<td class="left">保证只有一个线程能够获取同步资源</td>
<td class="left">1000ns</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">Semaphore</td>
<td class="left">可指定可获取同步资源的线程数</td>
<td class="left">1000ns</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">ReaderWriterLock</td>
<td class="left">允许多个Reader访问同步资源</td>
<td class="left">100ns</td>
<td class="left">No</td>
</tr>

<tr>
<td class="left">AutoResetEvent</td>
<td class="left">当信号被设为signaled状态时，允许单个线程进入同步资源块</td>
<td class="left">1000ns</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">ManualResetEvent</td>
<td class="left">当信号被设为signaled状态时，允许所有等待线程进入同步资源块</td>
<td class="left">1000ns</td>
<td class="left">Yes</td>
</tr>

<tr>
<td class="left">ReaderWriterLockSlim</td>
<td class="left">可锁定多个Reader访问资源以及单个Writer修改资源</td>
<td class="left">40ns</td>
<td class="left">No</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>注：一些Slim类(如ManualResetEventSlim)，比之旧版本，通常拥有更好的性能。参考 <a href="http://msdn.microsoft.com/en-us/library/5hbefs30(v=vs.100).aspx">MSDN</a>。
</li>
</ul>

<p>
几条规则：
</p>
<ol class="org-ol">
<li>尽量使同步要求最低，尝试避免共享状态。
</li>
<li>类的静态成员应是线程安全的。
</li>
<li>实例成员不需要是线程安全的。为了最佳性能，最好在类的外部处理同步问题。
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 推荐阅读</h3>
<div class="outline-text-3" id="text-6-5">
<p>
<a href="http://www.albahari.com/threading/">Threading in C#</a>
</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 诊断</h2>
<div class="outline-text-2" id="text-7">
<p>
对应命名空间System.Diagnostics
</p>
</div>
<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 跟踪(Trace)</h3>
<div class="outline-text-3" id="text-7-1">
<p class="verse">
用于应用程序运行时获得消息。记录各种形式的Log等<br  />
</p>
<p>
Trace体系结构：
</p>

<div class="figure">
<p><img src="../resources/csharp/Trace Architect.png" alt="Trace Architect.png" />
</p>
</div>
<ul class="org-ul">
<li>使用TraceSource发送跟踪消息
</li>
<li>Swith定义了要记录的信息级别
</li>
<li>TraceListener定义了写入跟踪消息的位置
</li>
<li>Listener可以关联一个Filter，过滤跟踪消息
</li>
<li>监听器和过滤器都可定制拓展
</li>
</ul>

<p>
可在Visual Studio项目属性的Build Tab中对是否在调试或发布版本中启用Trace标志进行设置。
</p>
</div>
<ol class="org-ol"><li><a id="sec-7-1-1" name="sec-7-1-1"></a>TraceSource<br  /><div class="outline-text-4" id="text-7-1-1">
<p>
与Trace类相比，TraceSource类较难使用，提供的选项更多。
</p>
<div class="org-src-container">

<pre class="src src-csharp">TraceSource source1 = new TraceSource("Tracing");
source1.TraceInformation("Info Message");//写入Trace消息
source1.TraceEvent(TraceEventType.Error, 3, "Error Message");//写入指定级别的Trace信息，可使用Switch只查看指定级别的消息。
source1.TraceData(TraceEventType.Information, 2, new int[] { 1, 2, 3 });//TraceData可以传入任意对象
source1.Flush();//为确保TraceData传入的数据由监听器写入，且不存储在内存中，需要执行Flush()
source1.Close();//不再需要该跟踪源时执行，Close()执行同时也会执行Flush()
</pre>
</div>
</div>
</li>
<li><a id="sec-7-1-2" name="sec-7-1-2"></a>Swith<br  /><div class="outline-text-4" id="text-7-1-2">
<p>
三个子类可供选择：
</p>
<ul class="org-ul">
<li>BooleanSwitch 可以打开和关闭跟踪
</li>
<li>TraceSwitch 提供了TraceLevel的选择，过滤Trace消息(TraceLevel包含Off、Error、Warning、Info、Verbose)
</li>
<li>SourceSwitch 提供了TraceLevel的选择，过滤Trace消息
</li>
</ul>

<p>
编程中硬编码方式：
</p>
<div class="org-src-container">

<pre class="src src-csharp">source1.Switch = new SourceSwitch("MySwitch", "Warning");//显示Warning以上级Trace消息
</pre>
</div>

<p>
配置文件方式：
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #F0DFAF; font-weight: bold;">xml</span> <span style="color: #DFAF8F;">version</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">1.0</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">encoding</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">utf-8</span><span style="color: #CC9393;">"</span> ?&gt;
&lt;<span style="color: #93E0E3;">configuration</span>&gt;
  &lt;<span style="color: #93E0E3;">system.diagnostics</span>&gt;
    &lt;<span style="color: #93E0E3;">sources</span>&gt;
      &lt;<span style="color: #93E0E3;">source</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">Tracing</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">switchName</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">MySourceSwitch</span><span style="color: #CC9393;">"</span>
              <span style="color: #DFAF8F;">switchType</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnostics.SourceSwitch</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;/<span style="color: #93E0E3;">sources</span>&gt;
    &lt;<span style="color: #93E0E3;">switches</span>&gt;
      &lt;<span style="color: #93E0E3;">add</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">MySourceSwitch</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">value</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">Verbose</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;/<span style="color: #93E0E3;">switches</span>&gt;
  &lt;/<span style="color: #93E0E3;">system.diagnostics</span>&gt;
&lt;/<span style="color: #93E0E3;">configuration</span>&gt;
</pre>
</div>
<p>
source name必须与程序中定义的TraceSource名匹配。
</p>
</div>
</li>

<li><a id="sec-7-1-3" name="sec-7-1-3"></a>TraceListener<br  /><div class="outline-text-4" id="text-7-1-3">
<p class="verse">
默认在调试时，当前的追踪消息之写入Visual Studio的Output窗口。<br  />
Trace监听器可重定向到不同的输出位置。需要在配置文件中配置。<br  />
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;?<span style="color: #F0DFAF; font-weight: bold;">xml</span> <span style="color: #DFAF8F;">version</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">1.0</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">encoding</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">utf-8</span><span style="color: #CC9393;">"</span> ?&gt;
&lt;<span style="color: #93E0E3;">configuration</span>&gt;
  &lt;<span style="color: #93E0E3;">system.diagnostics</span>&gt;
    &lt;<span style="color: #93E0E3;">sources</span>&gt;
      &lt;<span style="color: #93E0E3;">source</span> <span style="color: #DFAF8F;">name</span> = <span style="color: #CC9393;">"</span><span style="color: #CC9393;">Tracing</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">switchName</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">MySourceSwitch</span><span style="color: #CC9393;">"</span>
              <span style="color: #DFAF8F;">switchType</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnositcs.SourceSwitch</span><span style="color: #CC9393;">"</span>&gt;
        &lt;<span style="color: #93E0E3;">listeners</span>&gt;
          <span style="color: #5F7F5F;">&lt;!--</span><span style="color: #7F9F7F;">&#30417;&#21548;&#28040;&#24687;&#20197;xml&#26684;&#24335;&#20889;&#20837;</span><span style="color: #5F7F5F;">--&gt;</span>
          &lt;<span style="color: #93E0E3;">add</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">xmlListener</span><span style="color: #CC9393;">"</span>
               <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnostics.XmlWriterTraceListener</span><span style="color: #CC9393;">"</span>
               <span style="color: #DFAF8F;">traceOutputOptions</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">None</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">initializeData</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">c:/logs/trace.xml</span><span style="color: #CC9393;">"</span>/&gt;
          &lt;<span style="color: #93E0E3;">add</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">delimitedListener</span><span style="color: #CC9393;">"</span> /&gt;
        &lt;/<span style="color: #93E0E3;">listeners</span>&gt;
      &lt;/<span style="color: #93E0E3;">source</span>&gt;
    &lt;/<span style="color: #93E0E3;">sources</span>&gt;
    &lt;<span style="color: #93E0E3;">sharedListeners</span>&gt;
      <span style="color: #5F7F5F;">&lt;!--</span><span style="color: #7F9F7F;">&#30417;&#21548;&#28040;&#24687;&#20197;&#25351;&#23450;&#20998;&#38548;&#31526;&#20998;&#38548;&#28040;&#24687;&#21508;&#37096;&#20998;</span><span style="color: #5F7F5F;">--&gt;</span>
      &lt;<span style="color: #93E0E3;">add</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">delimitedListener</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">delimiter</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">:</span><span style="color: #CC9393;">"</span>
           <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnostics.DelimitedListTraceListener</span><span style="color: #CC9393;">"</span>
           <span style="color: #DFAF8F;">traceOutputOptions</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">DataTime, ProcessId</span><span style="color: #CC9393;">"</span>
           <span style="color: #DFAF8F;">initializeData</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">c:/logs/trace.txt</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;/<span style="color: #93E0E3;">sharedListeners</span>&gt;
    &lt;<span style="color: #93E0E3;">switches</span>&gt;
      &lt;<span style="color: #93E0E3;">add</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">MySourceSwitch</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">value</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">Verbose</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;/<span style="color: #93E0E3;">switches</span>&gt;
  &lt;/<span style="color: #93E0E3;">system.diagnostics</span>&gt;
&lt;/<span style="color: #93E0E3;">configuration</span>&gt;
</pre>
</div>
<ul class="org-ul">
<li>traceOutputOptions由TraceOptions这个枚举定义，可将这些额外的信息写入Trace日志。
</li>
<li>sharedListeners元素可以定义共通的监听方式
</li>
</ul>

<p>
以上定义的DelimitedListTraceListener的输出结果如下：
</p>
<pre class="example">
"Tracing":Information:0:"Info message"::4188:""::"2012-11-24T12:15:52.3756748Z"::
"Tracing":Error:3:"Error message"::4188:""::"2012-11-24T12:15:52.77546721Z"::
</pre>

<p>
可用监听器列表：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">监听器名</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">DefaultTraceListener</td>
<td class="left">默认输出至关联的调试器中，如Visual Studio Output窗口</td>
</tr>

<tr>
<td class="left">EventLogTraceListener</td>
<td class="left">写入EventLog</td>
</tr>

<tr>
<td class="left">TextWriterTraceListener</td>
<td class="left">写入文件</td>
</tr>

<tr>
<td class="left">ConsoleTraceListener</td>
<td class="left">写入控制台，继承TextWriterTraceListener</td>
</tr>

<tr>
<td class="left">DelimitedListTraceListener</td>
<td class="left">写入带指定分隔符的文件，继承TextWriterTraceListener</td>
</tr>

<tr>
<td class="left">XmlWriterTraceListener</td>
<td class="left">写入XML格式文件中，继承TextWriterTraceListener。(默认包括TraceOptions中定义的信息)</td>
</tr>

<tr>
<td class="left">IisTraceListener</td>
<td class="left">.Net 3.0以上，写入IIS中</td>
</tr>

<tr>
<td class="left">WebPatgeTraceListener</td>
<td class="left">依赖于ASP.NET所特有的另一个跟踪选项，在动态创建的输出文件trace.axd中写入Trace信息</td>
</tr>
</tbody>
</table>
</div>
</li>

<li><a id="sec-7-1-4" name="sec-7-1-4"></a>TraceFilter<br  /><div class="outline-text-4" id="text-7-1-4">
<p>
每个监听器都有一个过滤器。监听器使用过滤器确定是否应写入信息。
</p>
<ul class="org-ul">
<li>SourceFilter 根据指定源过滤写入的Trace消息
</li>
<li>EventTypeFilter 根据跟踪级别过滤写入的Trace消息
</li>
</ul>
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #93E0E3;">sharedListeners</span>&gt;
  &lt;<span style="color: #93E0E3;">add</span> <span style="color: #DFAF8F;">name</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">xmlListener</span><span style="color: #CC9393;">"</span>
       <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnostics.XmlWriterTraceListener</span><span style="color: #CC9393;">"</span>
       <span style="color: #DFAF8F;">traceOutputOptions</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">None</span><span style="color: #CC9393;">"</span> <span style="color: #DFAF8F;">initalizeData</span>="c:/logs/trace.xml&gt;
    &lt;<span style="color: #93E0E3;">filter</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnostics.SourceFilter</span><span style="color: #CC9393;">"</span>
            <span style="color: #DFAF8F;">initializeData</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">Tracing</span><span style="color: #CC9393;">"</span>/&gt;
    &lt;<span style="color: #93E0E3;">filter</span> <span style="color: #DFAF8F;">type</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">System.Diagnostics.EventTypeFilter</span><span style="color: #CC9393;">"</span>
            <span style="color: #DFAF8F;">initializeData</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">Warning</span><span style="color: #CC9393;">"</span>/&gt;
  &lt;/<span style="color: #93E0E3;">add</span>&gt;
&lt;/<span style="color: #93E0E3;">sharedListeners</span>&gt;
</pre>
</div>
</div>
</li>

<li><a id="sec-7-1-5" name="sec-7-1-5"></a>Trace.Assert<br  /><div class="outline-text-4" id="text-7-1-5">
<p class="verse">
可以显示信息和错误，中止或继续运行应用程序。一般用于开发期。<br  />
还可以用Debug.Assert，项目默认只有Debug时才加入编译。<br  />
是否禁用断言信息可以通过程序配置项配置：<br  />
</p>
<div class="org-src-container">

<pre class="src src-xml">&lt;<span style="color: #93E0E3;">configuration</span>&gt;
  &lt;<span style="color: #93E0E3;">system.diagnostics</span>&gt;
    &lt;<span style="color: #93E0E3;">assert</span> <span style="color: #DFAF8F;">assertuienabled</span>=<span style="color: #CC9393;">"</span><span style="color: #CC9393;">false</span><span style="color: #CC9393;">"</span>/&gt;
  &lt;/<span style="color: #93E0E3;">system.diagnostics</span>&gt;
&lt;/<span style="color: #93E0E3;">configuration</span>&gt;
</pre>
</div>
</div>
</li></ol>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 事件日志</h3>
<div class="outline-text-3" id="text-7-2">
</div><ol class="org-ol"><li><a id="sec-7-2-1" name="sec-7-2-1"></a>日志分类<br  /><div class="outline-text-4" id="text-7-2-1">
<ul class="org-ul">
<li>系统： 用于系统驱动程序与硬件驱动程序。
</li>
<li>应用程序：用于各应用程序及服务程序。
</li>
<li>安全：是应用程序的只读日志。
</li>
<li>自定义类别：程序还可以自定义日志类别，可以在“应用程序和服务日志”文件夹中看到自定义的类别。(通常都是这么做的)
</li>
</ul>
</div>
</li></ol>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> 性能</h3>
<div class="outline-text-3" id="text-7-3">
</div><ol class="org-ol"><li><a id="sec-7-3-1" name="sec-7-3-1"></a>监控类<br  /><div class="outline-text-4" id="text-7-3-1">
<p>
System.Diagnostics提供了如下监控类
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">类名</th>
<th scope="col" class="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">PerformanceCounter</td>
<td class="left">用于写入计数和监控计数，可使用此类创建新的性能类别</td>
</tr>

<tr>
<td class="left">PerformanceCounterCategory</td>
<td class="left">可查看所有已有的类别以及创建新类别。可从一个类别中获取所有计数器</td>
</tr>

<tr>
<td class="left">PerformanceCounterInstaller</td>
<td class="left">用于安装性能计数器</td>
</tr>
</tbody>
</table>
</div>
</li></ol>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> 代码约定</h3>
<div class="outline-text-3" id="text-7-4">
<p class="verse">
使用System.Diagnostics.Contracts(.Net 4.0引入)，可定义方法中的前提条件、<br  />
后置条件和常量。可以选择性编译进调试级程序或者发布级程序。(VS2010以上<br  />
项目属性→CodeContracts Tab，需另装插件<a href="http://visualstudiogallery.msdn.microsoft.com/1ec7db13-3363-46c9-851f-1ce455f66970">Code Contracts for .NET</a>)。<br  />
</p>
<p>
用法提示：
</p>
<ul class="org-ul">
<li>前置条件和后置条件都必须放在方法开头。
</li>
<li>验证失败会触发ContractFailed事件，可自定义事件处理程序。
</li>
</ul>
</div>
<ol class="org-ol"><li><a id="sec-7-4-1" name="sec-7-4-1"></a>前置条件<br  /><div class="outline-text-4" id="text-7-4-1">
<p>
有两个方法可以定义前置条件
</p>
<ol class="org-ol">
<li>Requires()
</li>
<li>Requires&lt;TException&gt;()
</li>
</ol>
<p>
看例子，与断言(Assert)的用法非常相似。
</p>
<div class="org-src-container">

<pre class="src src-csharp">static bool IsStrValid(int min, int max, string str)
{
    Contract.Requires(min&lt;=max);//可定义第二个参数，指定验证失败时显示的字符串。
    Contract.Requires&lt;ArgumentNullException&gt;(str != null, "Preconditions, o is null");//验证项 str != null 为false时，抛出异常。
    int value = int.TryParse(str);
    if (value &gt;= min || value &lt;= max)
        return true;
    return false;
}
</pre>
</div>
<p>
注意点：
</p>
<ul class="org-ul">
<li>将ContractFailed事件设为handled，则不抛出异常。
</li>
<li>如果配置了Assert on Contract Failure，则在约定处调用Trace.Assert()方法替代抛出异常。
</li>
<li>遗留代码添加一行代码即可。EndContractBlock指定其之前的代码为条件检查代码。
</li>
</ul>
<div class="org-src-container">

<pre class="src src-csharp">if (o == null) throw new ArgumentNullException("o");
Contract.EndContractBlock();
</pre>
</div>
<ul class="org-ul">
<li>Contract类提供了Exists()和ForAll()方法用作参数的检查。ForAll针对集合。可用于前置条件、后置条件和常量。
</li>
</ul>
<div class="org-src-container">

<pre class="src src-csharp">void ArrayTest(int[] data)
{
    Contract.Requires(Contract.ForAll(data, i=&gt;i&lt;12));
}
</pre>
</div>
</div>
</li>
<li><a id="sec-7-4-2" name="sec-7-4-2"></a>后置条件<br  /><div class="outline-text-4" id="text-7-4-2">
<p>
定义后置条件的两个方法：
</p>
<ol class="org-ol">
<li>Ensures()
</li>
<li>EnsuresOnThrow&lt;TException&gt;()
</li>
</ol>
<p>
用法大致上与前置条件差不多，请看示例，不再累述。
</p>
<div class="org-src-container">

<pre class="src src-csharp">static int sharedState = 5;
static void Postcondtion()
{
    Contract.Ensures(sharedState &lt; 6);
    sharedState--;
}
static int ReturnValue()
{
    Contract.Ensures(Contract.Result&lt;int&gt;() &lt; 6);
    return 3;
}
</pre>
</div>
</div>
</li>
<li><a id="sec-7-4-3" name="sec-7-4-3"></a>常量条件<br  /><div class="outline-text-4" id="text-7-4-3">
<p class="verse">
定义了在整个方法生命期中都必须满足的条件。<br  />
Contract.Invariant(x&gt;5)说明整个方法生命期中x都必须大于5。<br  />
</p>
</div>
</li>

<li><a id="sec-7-4-4" name="sec-7-4-4"></a>接口协定<br  /><div class="outline-text-4" id="text-7-4-4">
<p>
可使用ContractClass、ContractClassFor、Pure特性来为接口定义约束条件类。
</p>
<div class="org-src-container">

<pre class="src src-csharp">[ContractClass(typeof(PersonContract))]
public interface IPerson
{
    string Name{ get; set; }
}

[ContractClassFor(typeof(IPerson))]
public class PersonContract : IPerson
{
    string IPerson.Name
    {
        [Pure] get { return Contract.Result&lt;string&gt;(); }
        set { Contract.Requires(value != null); }
    }
}

public class Person : IPerson
{
    string Name{ get; set; }
}

static void Main()
{
    var p = new Person { Name = null };//contract error
}
</pre>
</div>
</div>
</li></ol>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 程序集</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 共享程序集</h3>
<div class="outline-text-3" id="text-8-1">
<p class="verse">
①GAC全局共享<br  />
②配置文件codeBase元素配置，共享程序集路径如没有，搜索probing元素。<br  />
</p>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Useful Utility</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>ILDASM 将汇编转成IL代码
</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/k5b5tt23(v=vs.90).aspx">Sn.exe</a> 公用程序集强名工具
</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ex0ss12c(v=vs.90).aspx">Gacutil.exe</a> 公用程序集安装工具
</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/6t9t5wcf(v=vs.90).aspx">Ngen.exe</a> 安装期间IL转成汇编机器码，提高托管应用程序性能的工具，取代程序集的JIT编译。
</li>
</ul>
<p class="verse">
预编译的程序集和需要运行JIT编译的程序集，其性能在编译IL代码后差别不大。<br  />
使用Ngen.exe唯一改进是，应用程序启动比较快，因为不需要启动JIT编译器。<br  />
需保证应用程序所有程序集均已作成本机映像<br  />
</p>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 部署</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 自定义安装包</h3>
<div class="outline-text-3" id="text-9-1">
<ol class="org-ol">
<li><a href="http://blog.csdn.net/wonsoft/article/details/5956320">打包微软各种库的方法</a>
</li>
<li><a href="http://blog.csdn.net/cxyyxc/article/details/1725703">自动安装web网站及执行SQL的方法IIS6</a>
</li>
</ol>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> WebService</h2>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
例子参照《C# 高级编程(第7版)》
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
给线程指定较高的基本优先级时，需注意。这有可能会降低其他线程的运行概率。
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
可以捕捉该异常完成线程的资源清理任务。
</p></div>

<div class="footdef"><sup><a id="fn.4" name="fn.4" class="footnum" href="#fnr.4">4</a></sup> <p class="footpara">
该时间测自CPU Intel Core i7 860的环境，参考<a href="http://www.albahari.com/threading/">Threading in C#</a>
</p></div>


</div>
</div></div>
</body>
</html>
