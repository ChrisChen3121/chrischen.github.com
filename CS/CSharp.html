<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>C# .Net</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="C# .Net"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2014-05-04T14:00+0800"/>
<meta name="author" content="ChrisChen"/>
<meta name="description" content=""/>
<meta name="keywords" content="CSharp, .Net"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="../css/stylesheet.css" type="text/css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>
<div id="org-div-home-and-up" style="text-align:right;font-size:100%;white-space:nowrap;">
 <a accesskey="h" href="../index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div>


<div id="content">
<h1 class="title">C# .Net</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 类</a></li>
<li><a href="#sec-2">2 集合</a>
<ul>
<li><a href="#sec-2-1">2.1 集合接口一览</a></li>
<li><a href="#sec-2-2">2.2 List</a></li>
</ul>
</li>
<li><a href="#sec-3">3 异常</a></li>
<li><a href="#sec-4">4 反射</a>
<ul>
<li><a href="#sec-4-1">4.1 自定义特性</a></li>
<li><a href="#sec-4-2">4.2 反射</a></li>
</ul>
</li>
<li><a href="#sec-5">5 序列化及持久化</a>
<ul>
<li><a href="#sec-5-1">5.1 概述</a></li>
<li><a href="#sec-5-2">5.2 Serializable特性</a></li>
<li><a href="#sec-5-3">5.3 IFormatter接口</a></li>
<li><a href="#sec-5-4">5.4 序列化为Binary示例</a></li>
<li><a href="#sec-5-5">5.5 拓展</a></li>
</ul>
</li>
<li><a href="#sec-6">6 多线程</a>
<ul>
<li><a href="#sec-6-1">6.1 创建线程</a></li>
<li><a href="#sec-6-2">6.2 同步问题</a></li>
<li><a href="#sec-6-3">6.3 Timer类</a></li>
<li><a href="#sec-6-4">6.4 总结</a></li>
<li><a href="#sec-6-5">6.5 推荐阅读</a></li>
</ul>
</li>
<li><a href="#sec-7">7 诊断</a>
<ul>
<li><a href="#sec-7-1">7.1 跟踪(Trace)</a></li>
<li><a href="#sec-7-2">7.2 事件日志</a></li>
<li><a href="#sec-7-3">7.3 性能</a></li>
<li><a href="#sec-7-4">7.4 代码约定</a></li>
</ul>
</li>
<li><a href="#sec-8">8 程序集</a>
<ul>
<li><a href="#sec-8-1">8.1 共享程序集</a></li>
<li><a href="#sec-8-2">8.2 Useful Utility</a></li>
</ul>
</li>
<li><a href="#sec-9">9 部署</a>
<ul>
<li><a href="#sec-9-1">9.1 自定义安装包</a></li>
</ul>
</li>
<li><a href="#sec-10">10 WebService</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 类</h2>
<div class="outline-text-2" id="text-1">

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 集合</h2>
<div class="outline-text-2" id="text-2">


<p class="verse">
一般集合类在System.Collections(ArrayList)<br/>
泛型集合类在System.Collections.Generic<br/>
特定类型的集合类在System.Collections.Specialized<br/>
线程安全的集合类在System.Collections.Concurrent<br/>
</p>



</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> 集合接口一览</h3>
<div class="outline-text-3" id="text-2-1">

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">接口</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">IEnumerable&lt;T&gt;</td><td class="left">实现了该接口可用foreach遍历，定义了方法GetEnumerator()，返回一个实现了IEnumerator接口的枚举。</td></tr>
<tr><td class="left">ICollection&lt;T&gt;</td><td class="left">定义了Count属性、复制到数组的CopyTo()、Add()、Remove()、Clear()</td></tr>
<tr><td class="left">IList&lt;T&gt;</td><td class="left">继承自ICollection。增加了一个索引器(List[index])，可以在指定位置插入删除项Insert()和RemoveAt()</td></tr>
<tr><td class="left">IDictionary&lt;TKey, TValue&gt;</td><td class="left">键值对泛型集合。一键一值。</td></tr>
<tr><td class="left">ILookup&lt;TKey, TValue&gt;</td><td class="left">类似于IDictionary。一键多值。</td></tr>
<tr><td class="left">IComparable&lt;T&gt;</td><td class="left">定义方法CompareTo()</td></tr>
<tr><td class="left">IComparer&lt;T&gt;</td><td class="left">由比较器实现，定义Compare()方法用于排序。</td></tr>
</tbody>
</table>

</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> List</h3>
<div class="outline-text-3" id="text-2-2">


</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> 创建</h4>
<div class="outline-text-4" id="text-2-2-1">




<pre class="src src-csharp"><span style="color: #daa520;">var</span> <span style="color: #008b8b;">intList</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">List</span>&lt;<span style="color: #daa520;">int</span>&gt;(); <span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#40664;&#35748;&#21019;&#24314;&#23481;&#37327;&#20026;4&#20010;&#20803;&#32032;&#65292;&#22914;&#26524;Add&#26102;&#36229;&#20986;&#26368;&#22823;&#23481;&#37327;&#65292;&#21017;&#23558;&#26368;&#22823;&#23481;&#37327;*2</span>
<span style="color: #daa520;">var</span> <span style="color: #008b8b;">intList</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">List</span>&lt;<span style="color: #daa520;">int</span>&gt;(10);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#25351;&#23450;&#20808;&#21019;&#24314;10&#20010;&#20803;&#32032;&#30340;&#23481;&#37327;&#65292;Add&#26102;&#36229;&#20986;&#65292;&#22788;&#29702;&#21644;&#19978;&#38754;&#19968;&#26679;</span>
<span style="color: #008b8b;">intList</span>.<span style="color: #008b8b;">Capacity</span> = 20;<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#36824;&#21487;&#20197;&#20351;&#29992;Capacity&#35774;&#23450;</span>
<span style="color: #008b8b;">intList</span>.<span style="color: #00008b; font-weight: bold;">TrimExcess</span>();<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#19981;&#24076;&#26395;&#20877;&#24448;List&#20013;&#28155;&#21152;&#20803;&#32032;&#26102;&#20351;&#29992;&#12290;&#21435;&#38500;&#19981;&#38656;&#35201;&#30340;&#23481;&#37327;</span>
</pre>

<p>
容量改变了整个集合就会被分配一个新的内存块。
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 异常</h2>
<div class="outline-text-2" id="text-3">

<ul>
<li>try&hellip;finally&hellip;语句块(非异常常规用法)
</li>
</ul>


<p class="verse">
省略catch，当try中语句有多个出口时，可以确保再出去前执行finally中的代码。<br/>
这看上去不错。<br/>
但是当try中真有异常发生时，程序会抛出异常，并且finally语句块不会正常执行！<br/>
</p>


<ul>
<li>可执行程序应捕获尽可能多的异常，类库最好不要捕获异常
</li>
</ul>

</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 反射</h2>
<div class="outline-text-2" id="text-4">


</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> 自定义特性</h3>
<div class="outline-text-3" id="text-4-1">


</div>

<div id="outline-container-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> 概述</h4>
<div class="outline-text-4" id="text-4-1-1">




<pre class="src src-csharp">[FieldNameAttribute(<span style="color: #9400d3;">"Name"</span>)]
<span style="color: #8b8989;">//</span><span style="color: #8b8989;">[FieldName("Name")]&#19982;&#19978;&#19968;&#26465;&#25928;&#26524;&#19968;&#26679;&#12290;&#35828;&#26126;"Attribute"&#26159;&#21487;&#30465;&#30053;&#30340;&#12290;</span>
<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">string</span> Name
{
    <span style="color: #1e90ff; font-weight: bold;">get</span> ; <span style="color: #1e90ff; font-weight: bold;">set</span> ;
}
</pre>


<p class="verse">
编译器发现这个 <b>属性</b> 应用了FieldName特性后，首先会将Attribute加上，<br/>
即变成FieldNameAttribute特性。然后再其所使用的所有命名空间中搜索特性<br/>
处理类(本例为FieldNameAttribute类)。定义了特性的这个类直接或者间接的<br/>
继承了System.Attribute类，编译器还会认为该类包含控制特性用法的信息。<br/>
<br/>
如果编译器找不到对应的特性类，或者使用特性的方式与特性类中的信息不匹配，<br/>
编译器会报错。<br/>
</p>


</div>

</div>

<div id="outline-container-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> 定义特性类</h4>
<div class="outline-text-4" id="text-4-1-2">




<pre class="src src-csharp">[AttributeUsage(<span style="color: #daa520;">AttributeTargets</span>.<span style="color: #008b8b;">Property</span> | <span style="color: #daa520;">AttributeTargets</span>.<span style="color: #008b8b;">Field</span>,
                AllowMultiple=<span style="color: #ff6347;">false</span>,
                Inherited=<span style="color: #ff6347;">false</span>)]
<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">FieldNameAttribute</span> : <span style="color: #daa520;">Attribute</span>
{
    <span style="color: #1e90ff; font-weight: bold;">private</span> <span style="color: #daa520;">string</span> <span style="color: #008b8b;">name</span>;
    <span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #00008b; font-weight: bold;">FieldNameAttribute</span>(<span style="color: #daa520;">string</span> <span style="color: #008b8b;">name</span>)
        {
            <span style="color: #1e90ff; font-weight: bold;">this</span>.<span style="color: #008b8b;">name</span> = name;
        }
}
</pre>


<p class="verse">
首先，特性类本身用一个内建的特性AttributeUsage标记。<br/>
<br/>
第一个参数AttributeTargets为必选项，指定应用到哪些类型的元素上(示例表示该特性能用在属性或成员变量上)。<br/>
Assembly和Module类型有些特殊，说明该特性可以应用到整个程序集或模块的各类型元素中。<br/>
使用时需用关键字assembly或module作为前缀：[assembly:SomeAssemblyAttribute(Parameters)]<br/>
另一个应用到全局元素的类型是AttributeTargets.All。<br/>
<br/>
第二个参数表示是否可以多次用在同一个程序元素上。(可选参数)<br/>
<br/>
第三个参数表示特性应用在类或接口上时，是否可由子类继承。(可选参数)<br/>
</p>


</div>

</div>

<div id="outline-container-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> 指定特性所接受的参数</h4>
<div class="outline-text-4" id="text-4-1-3">


<p class="verse">
当编译遇到如下语句时：<br/>
[FieldName("Name")]<br/>
将查找特性类中是否有参数为字符串类型的构造函数。<br/>
</p>


<ul>
<li>指定可选参数
</li>
</ul>


<p class="verse">
在特性类中添加属性，以支持特性可选参数。<br/>
[FieldName("Name", Comment="This is a primary key")<br/>
Comment必须在特性类FieldNameAttribute中是一个string类型的属性。<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 反射</h3>
<div class="outline-text-3" id="text-4-2">


</div>

<div id="outline-container-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> System.Type类</h4>
<div class="outline-text-4" id="text-4-2-1">


<p class="verse">
通过该类，可以访问关于任何数据类型的信息。<br/>
<br/>
使用Type类为了存储类型的引用。<br/>
Type t = typeof(double);<br/>
<br/>
也可以这样使用：<br/>
double d = 0;<br/>
Type t = d.GetType();<br/>
GetType()是.Net基类System.Object的方法。<br/>
<br/>
还可以使用Type类的静态方法手工指定类型：<br/>
Type t = Type.GetType("System.Double");<br/>
<br/>
还可以获取定义该类型的程序集的引用：<br/>
Type t = typeof(CustomizeClass);<br/>
Assembly containingAssembly = new Assembly(t);<br/>
</p>


<ul>
<li id="sec-4-2-1-1">Type类常用属性<br/>
Name、FullName、Namespace、BaseType、UnderlyingSystemType、IsClass(IsAbstract、IsEnum等。
</li>
</ul>
<ul>
<li id="sec-4-2-1-2">Type类方法<br/>
GetMethod、GetMethods
</li>
</ul>
</div>

</div>

<div id="outline-container-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> System.Reflection.Assembly类</h4>
<div class="outline-text-4" id="text-4-2-2">


<p class="verse">
System.Reflection.Assembly 可以用于访问给定程序集的相关信息。<br/>
<br/>
首先使用Load或者LoadForm加载程序集。<br/>
- Assembly.Load()的参数传入程序集名称，运行库会在本地目录和全局程序集缓存中查找该程序集。<br/>
- Assembly.LoadForm()的参数需传入程序集的完整路径。<br/>
<br/>
列出一些常用的方法：<br/>
</p>




<pre class="src src-csharp"><span style="color: #daa520;">Assembly</span> <span style="color: #008b8b;">assemblyTest</span> = <span style="color: #daa520;">Assembly</span>.<span style="color: #00008b; font-weight: bold;">Load</span>(<span style="color: #9400d3;">"SomeAssembly"</span>);
<span style="color: #daa520;">string</span> <span style="color: #008b8b;">name</span> = <span style="color: #008b8b;">assemblyTest</span>.<span style="color: #008b8b;">FullName</span>;

<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20197;&#19979;&#33719;&#21462;&#30340;&#26159;Assembly&#31867;&#22411;&#30340;Attribute</span>
<span style="color: #daa520;">Attribute</span>[] <span style="color: #008b8b;">assemblyAttributes</span> = <span style="color: #daa520;">Attribute</span>.<span style="color: #00008b; font-weight: bold;">GetCustomAttributes</span>(assemblyTest);

<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20197;&#19979;&#33719;&#21462;&#30340;&#26159;Class&#31867;&#22411;&#30340;Attribute</span>
<span style="color: #daa520;">Type</span>[] <span style="color: #008b8b;">types</span> = <span style="color: #008b8b;">assemblyTest</span>.<span style="color: #00008b; font-weight: bold;">GetTypes</span>();
<span style="color: #1e90ff; font-weight: bold;">foreach</span> (<span style="color: #daa520;">var</span> <span style="color: #008b8b;">type</span> <span style="color: #1e90ff; font-weight: bold;">in</span> types)
{
    <span style="color: #daa520;">Attribute</span>[] <span style="color: #008b8b;">classAttributes</span> = <span style="color: #daa520;">Attribute</span>.<span style="color: #00008b; font-weight: bold;">GetCustomAttributes</span>(type);

    <span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20197;&#19979;&#33719;&#21462;&#30340;&#26159;Method&#31867;&#22411;&#30340;Attribute</span>
    <span style="color: #daa520;">MemberInfo</span>[] <span style="color: #008b8b;">methods</span> = <span style="color: #008b8b;">type</span>.<span style="color: #00008b; font-weight: bold;">GetMethods</span>();
    <span style="color: #00008b; font-weight: bold;">foreach</span> (<span style="color: #daa520;">var</span> <span style="color: #008b8b;">method</span> <span style="color: #1e90ff; font-weight: bold;">in</span> methods)
    {
        <span style="color: #daa520;">Attribute</span> <span style="color: #008b8b;">methodAttribute</span> = <span style="color: #daa520;">Attribute</span>.<span style="color: #00008b; font-weight: bold;">GetCustomAttributes</span>(method);
    }
}
</pre>

</div>

</div>

<div id="outline-container-4-2-3" class="outline-4">
<h4 id="sec-4-2-3"><span class="section-number-4">4.2.3</span> 示例参照<a href="#ReflectionDemo">ReflectionDemo</a></h4>
<div class="outline-text-4" id="text-4-2-3">

</div>

</div>

<div id="outline-container-4-2-4" class="outline-4">
<h4 id="sec-4-2-4"><span class="section-number-4">4.2.4</span> 常用类列表</h4>
<div class="outline-text-4" id="text-4-2-4">


</div>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> 序列化及持久化</h2>
<div class="outline-text-2" id="text-5">


</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> 概述</h3>
<div class="outline-text-3" id="text-5-1">

<ul>
<li>序列化：将对象转换成字节流的过程称为序列化。反之，则称反序列化。
</li>
<li>持久化：将对象存储在一些持久性的媒介(例：内存为非持久性媒介，硬盘是持久性媒介)上称为持久化。
</li>
</ul>


<p class="verse">
命名空间System.Runtime.Serialization和System.Runtime.Serialization.Formatters提供了序列化对象的基础架构。<br/>
</p>


</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Serializable特性</h3>
<div class="outline-text-3" id="text-5-2">


<p class="verse">
要使某对象能够进行序列化，需要对类标注[Serializable]特性。<br/>
还可以对类成员分别标注[NonSerialized]特性，标出不需要序列化的成员。例：<br/>
</p>




<pre class="src src-csharp">[Serializable]
<span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Person</span>
{
    <span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">string</span> <span style="color: #008b8b;">Name</span>;<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#23646;&#24615;&#20063;&#21487;&#34987;&#24207;&#21015;&#21270;</span>
    <span style="color: #1e90ff; font-weight: bold;">private</span> <span style="color: #daa520;">int</span> <span style="color: #008b8b;">Age</span> { <span style="color: #1e90ff; font-weight: bold;">get</span>; <span style="color: #1e90ff; font-weight: bold;">set</span>; }<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21487;&#34987;&#24207;&#21015;&#21270;</span>
    [<span style="color: #daa520;">NonSerialized</span>]<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">string</span> Phone;<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#35813;&#23383;&#27573;&#19981;&#20250;&#34987;&#24207;&#21015;&#21270;&#65292;&#27880;&#65306;NonSerialized&#29305;&#24615;&#21482;&#33021;&#26631;&#20934;&#23383;&#27573;&#12290;</span>
}
</pre>

</div>

</div>

<div id="outline-container-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> IFormatter接口</h3>
<div class="outline-text-3" id="text-5-3">


<p class="verse">
只要实现了IFormatter接口的类都提供了序列化过程的具体实现，也可以<br/>
自定义一个类实现该接口支持序列化特殊格式的字符流。该接口定义如下：<br/>
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">方法</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">void Serialize(Stream stream, object source)</td><td class="left">把source序列化为stream</td></tr>
<tr><td class="left">object Deserialize(Stream stream)</td><td class="left">反序列化stream，返回object</td></tr>
</tbody>
</table>


<p>
注：如果stream是个FileStream类型，将其写入文件，这也就是将对象object持久化了。
</p></div>

</div>

<div id="outline-container-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> 序列化为Binary示例</h3>
<div class="outline-text-3" id="text-5-4">


<p class="verse">
Binary是常用的序列化形式之一，简单介绍下它的使用，其他形式的使用方式类似。<br/>
命名空间：System.Runtime.Serialization.Formatters.Binary<br/>
类：BinaryFormatter<br/>
作用：能把对象序列化为二进制流，同样支持反序列化。<br/>
</p>




<pre class="src src-csharp"><span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#24207;&#21015;&#21270;</span>
<span style="color: #daa520;">IFomatter</span> <span style="color: #008b8b;">serializer</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">BinaryFormatter</span>();
<span style="color: #008b8b;">serializer</span>.<span style="color: #00008b; font-weight: bold;">Serialize</span>(myStream, myObject);

<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21453;&#24207;&#21015;&#21270;</span>
<span style="color: #daa520;">IFomatter</span> <span style="color: #008b8b;">serializer</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">BinaryFormatter</span>();
<span style="color: #daa520;">MyObjectType</span> <span style="color: #008b8b;">myObject</span> = <span style="color: #008b8b;">serializer</span>.<span style="color: #00008b; font-weight: bold;">Deserialize</span>(MyStream) <span style="color: #1e90ff; font-weight: bold;">as</span> <span style="color: #daa520;">MyObjectType</span>;
</pre>

<p>
完整示例：<a href="http://files.cnblogs.com/ChrisChen3121/Serialization.rar">Serialization.rar</a>
</p></div>

</div>

<div id="outline-container-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> 拓展</h3>
<div class="outline-text-3" id="text-5-5">


</div>

<div id="outline-container-5-5-1" class="outline-4">
<h4 id="sec-5-5-1"><span class="section-number-4">5.5.1</span> ISerializable接口</h4>
<div class="outline-text-4" id="text-5-5-1">


<p class="verse">
另外，如果类需要控制自身的序列化过程，则需要实现ISerializable接口，<br/>
在GetObjectData修改SerializationInfo的信息。详细参考<a href="http://msdn.microsoft.com/en-us/library/wf4375ks(v=vs.90).aspx">MSDN</a>。<br/>
</p>


</div>

</div>

<div id="outline-container-5-5-2" class="outline-4">
<h4 id="sec-5-5-2"><span class="section-number-4">5.5.2</span> 一些.Net序列化类</h4>
<div class="outline-text-4" id="text-5-5-2">

<p>下表列出了.Net提供的其他一些序列化类：
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">类名</th><th scope="col" class="left">作用</th></tr>
</thead>
<tbody>
<tr><td class="left">SoapFormatter</td><td class="left">序列化为Soap格式的XML数据</td></tr>
<tr><td class="left">ObjectStateFormatter</td><td class="left">在ASP.Net中序列化viewstate</td></tr>
<tr><td class="left">NetDataContractSerializer</td><td class="left">用于序列化WCF数据合同</td></tr>
</tbody>
</table>

</div>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 多线程</h2>
<div class="outline-text-2" id="text-6">


</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> 创建线程</h3>
<div class="outline-text-3" id="text-6-1">


</div>

<div id="outline-container-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> 异步委托方式</h4>
<div class="outline-text-4" id="text-6-1-1">


<p class="verse">
使用异步委托创建的线程，都是由.Net线程池维护的。<br/>
线程池中的线程总是后台线程。<br/>
为了方便起见，接下来使用的共通委托方法如下<sup><a class="footref" name="fnr-.1" href="#fn-.1">1</a></sup>：<br/>
</p>




<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">int</span> <span style="color: #00008b; font-weight: bold;">TakesAWhile</span>(<span style="color: #daa520;">int</span> <span style="color: #008b8b;">data</span>, <span style="color: #daa520;">int</span> <span style="color: #008b8b;">ms</span>)
{
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"TakesAWhile started"</span>);
    <span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(ms);
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"TakesAWhile completed"</span>);
    <span style="color: #1e90ff; font-weight: bold;">return</span> ++data;
}
</pre>

<ul>
<li id="sec-6-1-1-1">IAsyncResult.IsCompleted<br/>

<p class="verse">
根据IAsyncResult.IsCompleted判断异步委托是否执行完成。<br/>
EndInvoke获取返回值。<br/>
</p>




<pre class="src src-csharp"><span style="color: #daa520;">TakesAWhileDelegate</span> <span style="color: #008b8b;">dl</span> = TakesAWhile;
<span style="color: #daa520;">IAsyncResult</span> <span style="color: #008b8b;">ar</span> = <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">BeginInvoke</span>(1, 3000, <span style="color: #ff6347;">null</span>, <span style="color: #ff6347;">null</span>);
<span style="color: #1e90ff; font-weight: bold;">while</span> (!<span style="color: #008b8b;">ar</span>.<span style="color: #008b8b;">IsCompleted</span>)
{
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">Write</span>(<span style="color: #9400d3;">"."</span>);
    <span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(50);
}
<span style="color: #daa520;">int</span> <span style="color: #008b8b;">result</span> = <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">EndInvoke</span>(ar);
<span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"result: {0}"</span>, result);
</pre>

</li>
</ul>
<ul>
<li id="sec-6-1-1-2">IAsyncResult.AsyncWaitHandle<br/>
使用WaitHandle，可指定异步调用的超时时间进行后续处理。



<pre class="src src-csharp"><span style="color: #daa520;">TakesAWhileDelegate</span> <span style="color: #008b8b;">dl</span> = TakesAWhile;
<span style="color: #daa520;">IAsyncResult</span> <span style="color: #008b8b;">ar</span> = <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">BeginInvoke</span>(1, 3000, <span style="color: #ff6347;">null</span>, <span style="color: #ff6347;">null</span>);
<span style="color: #1e90ff; font-weight: bold;">if</span> (!<span style="color: #008b8b;">ar</span>.<span style="color: #daa520;">AsyncWaitHandle</span>.<span style="color: #00008b; font-weight: bold;">WaitOne</span>(200, <span style="color: #ff6347;">false</span>))
{
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"Thread not invoked."</span>);
}
<span style="color: #1e90ff; font-weight: bold;">if</span> (<span style="color: #008b8b;">ar</span>.<span style="color: #daa520;">AsyncWaitHandle</span>.<span style="color: #00008b; font-weight: bold;">WaitOne</span>(3000, <span style="color: #ff6347;">false</span>))
{
    <span style="color: #daa520;">int</span> <span style="color: #008b8b;">result</span> = <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">EndInvoke</span>(ar);
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"result: {0}"</span>, result);
}
</pre>

</li>
</ul>
<ul>
<li id="sec-6-1-1-3">AsyncCallBack<br/>
通过传入回调函数，进行后续处理
<ul>
<li id="sec-6-1-1-3-1">分支一：单独定义回调方法<br/>



<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">Main</span>(<span style="color: #daa520;">string</span>[] <span style="color: #008b8b;">args</span>)
{
    <span style="color: #daa520;">TakesAWhileDelegate</span> <span style="color: #008b8b;">dl</span> = TakesAWhile;
    <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">BeginInvoke</span>(1, 3000, TakesAWhileCompleted, dl);
    <span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#24517;&#39035;&#31243;&#24207;&#20027;&#32447;&#31243;&#19968;&#30452;&#23384;&#22312;&#25165;&#20250;&#25191;&#34892;&#22238;&#35843;&#26041;&#27861;&#65292;&#25152;&#20197;&#20351;&#29992;&#20102;&#22914;&#19979;for&#24490;&#29615;(&#35828;&#26126;&#20102;&#24322;&#27493;&#22996;&#25176;&#25152;&#21019;&#24314;&#30340;&#32447;&#31243;&#26159;&#19968;&#20010;&#21518;&#21488;&#32447;&#31243;)</span>
    <span style="color: #00008b; font-weight: bold;">for</span> (<span style="color: #daa520;">int</span> <span style="color: #008b8b;">i</span> = 0; i &lt; 100; i++ )
    {
        <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">Write</span>(<span style="color: #9400d3;">"."</span>);
        <span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(50);
    }
}

<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#23450;&#20041;&#22238;&#35843;&#26041;&#27861;</span>
<span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">TakesAWhileCompleted</span>(<span style="color: #daa520;">IAsyncResult</span> <span style="color: #008b8b;">ar</span>)
{
    <span style="color: #00008b; font-weight: bold;">if</span> (ar == <span style="color: #ff6347;">null</span>)
    {
        <span style="color: #1e90ff; font-weight: bold;">throw</span> <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">ArgumentNullException</span>(<span style="color: #9400d3;">"ar"</span>);
    }
    <span style="color: #daa520;">TakesAWhileDelegate</span> <span style="color: #008b8b;">dl</span> = <span style="color: #008b8b;">ar</span>.AsyncState <span style="color: #1e90ff; font-weight: bold;">as</span> <span style="color: #daa520;">TakesAWhileDelegate</span>;
    <span style="color: #daa520;">Trace</span>.<span style="color: #00008b; font-weight: bold;">Assert</span>(dl != <span style="color: #ff6347;">null</span>, <span style="color: #9400d3;">"Invalid object type"</span>);
    <span style="color: #daa520;">int</span> <span style="color: #008b8b;">result</span> = <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">EndInvoke</span>(ar);
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"result: {0}"</span>, result);
}
</pre>

</li>
</ul>
<ul>
<li id="sec-6-1-1-3-2">分支二：使用lambada表达式<br/>



<pre class="src src-csharp"><span style="color: #daa520;">TakesAWhileDelegate</span> <span style="color: #008b8b;">dl</span> = TakesAWhile;
<span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">BeginInvoke</span>(1, 3000,
               <span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#36825;&#26159;&#20010;&#22238;&#35843;&#20989;&#25968;&#65292;&#20351;&#29992;lambada&#34920;&#36798;&#24335;&#30340;&#35805;&#65292;&#20195;&#30721;&#19981;&#22815;&#28165;&#26224;&#12290;</span>
               ar =&gt;
    {
        <span style="color: #daa520;">int</span> <span style="color: #008b8b;">result</span> = <span style="color: #008b8b;">dl</span>.<span style="color: #00008b; font-weight: bold;">EndInvoke</span>(ar);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">lambda&#34920;&#36798;&#24335;&#21487;&#20351;&#29992;&#35813;&#20316;&#29992;&#22495;&#22806;&#37096;&#30340;&#21464;&#37327;dl</span>
        <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"result: {0}"</span>, result);
    },
               <span style="color: #ff6347;">null</span>);
<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#24517;&#39035;&#31243;&#24207;&#20027;&#32447;&#31243;&#19968;&#30452;&#23384;&#22312;&#25165;&#20250;&#25191;&#34892;&#22238;&#35843;&#26041;&#27861;</span>
<span style="color: #1e90ff; font-weight: bold;">for</span> (<span style="color: #daa520;">int</span> <span style="color: #008b8b;">i</span> = 0; i &lt; 100; i++)
{
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">Write</span>(<span style="color: #9400d3;">"."</span>);
    <span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(50);
}
</pre>


</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-6-1-2" class="outline-4">
<h4 id="sec-6-1-2"><span class="section-number-4">6.1.2</span> Thread类</h4>
<div class="outline-text-4" id="text-6-1-2">

<ul>
<li id="sec-6-1-2-1">无参数线程方法<br/>



<pre class="src src-csharp"><span style="color: #daa520;">var</span> <span style="color: #008b8b;">t1</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Thread</span>(() =&gt; <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"running in a thread, id {0}"</span>, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>));
<span style="color: #008b8b;">t1</span>.<span style="color: #00008b; font-weight: bold;">Start</span>();
<span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"This is a main thread, id {0}"</span>, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>);
</pre>

</li>
</ul>
<ul>
<li id="sec-6-1-2-2">有参数线程方法<br/>



<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">struct</span> <span style="color: #daa520;">Data</span>
{
    <span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">string</span> <span style="color: #008b8b;">Message</span>;
}

<span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">int</span> <span style="color: #00008b; font-weight: bold;">TakesAWhile</span>(<span style="color: #daa520;">int</span> <span style="color: #008b8b;">data</span>, <span style="color: #daa520;">int</span> <span style="color: #008b8b;">ms</span>)
{
    <span style="color: #daa520;">var</span> <span style="color: #008b8b;">d</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Data</span> { Message = <span style="color: #9400d3;">"Info"</span> };
    <span style="color: #daa520;">var</span> <span style="color: #008b8b;">t2</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Thread</span>((<span style="color: #daa520;">object</span> <span style="color: #008b8b;">obj</span>) =&gt;
        {
            <span style="color: #daa520;">Data</span> <span style="color: #008b8b;">data</span> = (Data)obj;
            <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"running in a thread, id {0}, Data {1}"</span>, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>, <span style="color: #008b8b;">data</span>.<span style="color: #008b8b;">Message</span>);
        });
    <span style="color: #008b8b;">t2</span>.<span style="color: #00008b; font-weight: bold;">Start</span>(d);
    <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"This is a main thread, id {0}"</span>, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>);
}
</pre>


</li>
</ul>
<ul>
<li id="sec-6-1-2-3">后台线程<br/>
Thread类默认创建的是前台线程，设定IsBackground属性可转为后台线程



<pre class="src src-csharp"><span style="color: #daa520;">var</span> <span style="color: #008b8b;">t1</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Thread</span>(
    () =&gt; 
    {
        <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"branch thread Start, id {0}"</span>, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>);
        <span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(3000);
        <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"branch thread End"</span>);
    }) 
{ Name = <span style="color: #9400d3;">"NewBKThread"</span>, IsBackground = <span style="color: #ff6347;">true</span> };
<span style="color: #008b8b;">t1</span>.<span style="color: #00008b; font-weight: bold;">Start</span>();
<span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(50);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20026;&#20102;&#20351;&#21518;&#21488;&#32447;&#31243;&#30340;&#24773;&#20917;&#19979;&#65292;&#33021;&#25171;&#20986;branch thread Start, id</span>
<span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"This is a main thread, id {0}"</span>, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>);
</pre>

<ul>
<li>IsBackground = true 结果：
</li>
</ul>


<p class="verse">
branch thread Start, id 3<br/>
This is a main thread, id 1<br/>
</p>


<ul>
<li>IsBackground = false 结果：
</li>
</ul>


<p class="verse">
branch thread Start, id 3<br/>
This is a main thread, id 1<br/>
branch thread End<br/>
</p>


</li>
</ul>
<ul>
<li id="sec-6-1-2-4">关于线程优先级<br/>

<p class="verse">
可以通过Thread.Priority属性调整线程的 <b>基本</b> 优先级。实际线程调度器会动态调整优先级<br/>
频繁使用CPU的线程的优先级会动态调低，等待资源(等待磁盘IO完成等)的线程会动态调高优先级。<br/>
以便在下次等待结束时获得CPU资源。<sup><a class="footref" name="fnr-.2" href="#fn-.2">2</a></sup><br/>
</p>


</li>
</ul>
<ul>
<li id="sec-6-1-2-5">线程状态<br/>

<p class="verse">
通过属性Thread.ThreadState获取当前线程状态<br/>
<br/>
运行Thread.Start()后，状态为Unstarted。<br/>
系统线程调度器选择了运行该线程后，状态为Running。<br/>
调用Thread.Sleep()，状态为WaitSleepJoin。<br/>
<br/>
停止另一个线程，调用Thread.Abort()。接到中止命令的线程中会抛出ThreadAbortException。<sup><a class="footref" name="fnr-.3" href="#fn-.3">3</a></sup><br/>
涉及的状态有AbortRequested、Aborted。<br/>
继续停止的线程，调用Thread.ResetAbort()。线程将会在抛出ThreadAbortException后的语句后继续进行。<br/>
<br/>
等待线程的结束，调用ThreadInstance.Join()。<br/>
该调用会停止 <b>当前</b> 线程，当前线程状态设为WaitSleepJoin。<br/>
等待加入的线程处理完成，再继续当前线程的处理。<br/>
</p>


</li>
</ul>
</div>

</div>

<div id="outline-container-6-1-3" class="outline-4">
<h4 id="sec-6-1-3"><span class="section-number-4">6.1.3</span> 线程池</h4>
<div class="outline-text-4" id="text-6-1-3">

<p>超出最大线程数时，QueueUserWorkItem会等待获取线程资源时再调用。
</p>


<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">Main</span>(<span style="color: #daa520;">string</span>[] <span style="color: #008b8b;">args</span>)
{
    <span style="color: #daa520;">ThreadPool</span>.<span style="color: #00008b; font-weight: bold;">SetMinThreads</span>(3, 3);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21019;&#24314;&#32447;&#31243;&#27744;&#26102;&#21551;&#21160;&#30340;&#26368;&#23567;&#32447;&#31243;&#25968;</span>
    <span style="color: #daa520;">ThreadPool</span>.<span style="color: #00008b; font-weight: bold;">SetMaxThreads</span>(10, 10);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#26368;&#22823;&#32447;&#31243;&#25968;</span>
    <span style="color: #00008b; font-weight: bold;">for</span> (<span style="color: #daa520;">int</span> <span style="color: #008b8b;">i</span> = 0; i &lt; 5; i++ )
    {
        <span style="color: #daa520;">ThreadPool</span>.<span style="color: #00008b; font-weight: bold;">QueueUserWorkItem</span>(JobForAThread);
    }
    <span style="color: #daa520;">Thread</span>.<span style="color: #00008b; font-weight: bold;">Sleep</span>(3000);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#30001;&#20110;&#26159;&#21518;&#21488;&#32447;&#31243;&#65292;&#38656;&#35201;&#20351;&#20027;&#32447;&#31243;&#31561;&#19968;&#20250;&#65292;&#21542;&#21017;&#31243;&#24207;&#30452;&#25509;&#36864;&#20986;</span>
}

<span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">JobForAThread</span>(<span style="color: #daa520;">object</span> <span style="color: #008b8b;">state</span>)
{
    <span style="color: #00008b; font-weight: bold;">for</span> (<span style="color: #daa520;">int</span> <span style="color: #008b8b;">i</span> = 0; i &lt; 3; i++)
    {
        <span style="color: #daa520;">Console</span>.<span style="color: #00008b; font-weight: bold;">WriteLine</span>(<span style="color: #9400d3;">"loop {0}, running inside pooled thread {1}"</span>, i, <span style="color: #daa520;">Thread</span>.<span style="color: #daa520;">CurrentThread</span>.<span style="color: #008b8b;">ManagedThreadId</span>);
    }
}
</pre>

<p>
使用线程池的限制：
</p><ul>
<li>其中的所有线程只能是后台线程。
</li>
<li>无法设置线程的优先级或名称。
</li>
<li><b>关键点</b> 适用于耗时较短的任务。长期运行的线程，应使用Thread类创建。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 同步问题</h3>
<div class="outline-text-3" id="text-6-2">


</div>

<div id="outline-container-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> lock关键字</h4>
<div class="outline-text-4" id="text-6-2-1">


<p class="verse">
只能锁定引用类型，锁定值类型等于锁定了一个副本，没有意义，编译器也不允许你这么做。<br/>
使用锁定需要时间，并不总是必须。可以创建类的两个版本，一个同步版本，一个异步版本。<br/>
</p>


<ul>
<li id="sec-6-2-1-1">将实例成员设为线程安全的<br/>



<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">lock</span>(<span style="color: #1e90ff; font-weight: bold;">this</span>)
{
    <span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#19968;&#27425;&#21482;&#26377;&#19968;&#20010;&#32447;&#31243;&#33021;&#35775;&#38382;&#30456;&#21516;&#23454;&#20363;&#30340;&#35813;&#35821;&#21477;&#22359;</span>
}
</pre>

<p>
因为该实例对象也可用于外部访问，这样做会导致外部访问时也得等待该同步语句块执行完成。正确的做法：
</p>


<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">private</span> <span style="color: #daa520;">object</span> <span style="color: #008b8b;">syncRoot</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">object</span>();
<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">DoSomething</span>()
{
    <span style="color: #00008b; font-weight: bold;">lock</span> (<span style="color: #daa520;">object</span>)
    {
        <span style="color: #8b8989;">//</span><span style="color: #8b8989;">Do something</span>
    }
}

<span style="color: #1e90ff; font-weight: bold;">private</span> <span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">object</span> <span style="color: #008b8b;">syncRoot</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">object</span>();<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21487;&#29992;&#20110;&#38145;&#23450;&#31867;&#38745;&#24577;&#25104;&#21592;</span>
</pre>

</li>
</ul>
<ul>
<li id="sec-6-2-1-2">lock关键字由编译器解析为Monitor类<br/>



<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">lock</span> (obj) {  };
</pre>

<p>
等价于：
</p>


<pre class="src src-csharp"><span style="color: #daa520;">Monitor</span>.<span style="color: #00008b; font-weight: bold;">Enter</span>(obj);
<span style="color: #1e90ff; font-weight: bold;">try</span>
{
}
<span style="color: #1e90ff; font-weight: bold;">finally</span>
{
    <span style="color: #daa520;">Monitor</span>.<span style="color: #00008b; font-weight: bold;">Exit</span>(obj);
}
</pre>

<p>
与lock关键字的区别：
</p><ul>
<li>可添加一个等待解锁的超时时间，使用TryEnter传递超时值。
</li>
</ul>




<pre class="src src-csharp"><span style="color: #daa520;">bool</span> <span style="color: #008b8b;">lockTaken</span> = <span style="color: #daa520;">Monitor</span>.<span style="color: #00008b; font-weight: bold;">TryEnter</span>(obj, 500);
<span style="color: #1e90ff; font-weight: bold;">if</span> (lockTaken)
{
    <span style="color: #1e90ff; font-weight: bold;">try</span>
    {

    }
    <span style="color: #1e90ff; font-weight: bold;">finally</span>
    {
        <span style="color: #daa520;">Monitor</span>.<span style="color: #00008b; font-weight: bold;">Exit</span>(obj);
    }
}
else
{
    <span style="color: #8b8989;">//</span><span style="color: #8b8989;">didn't get the lock, do something else</span>
}
</pre>


</li>
</ul>
<ul>
<li id="sec-6-2-1-3">更快速的Interlocked类<br/>
仅用于简单的针对变量赋值的同步问题



<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">lock</span>(<span style="color: #1e90ff; font-weight: bold;">this</span>)
{
    <span style="color: #00008b; font-weight: bold;">if</span> (someState == <span style="color: #ff6347;">null</span>)
    {
        someState = newState;
    }
}
</pre>

<p>
等价于(可用于单件模式的GetInstance)：
</p>


<pre class="src src-csharp"><span style="color: #daa520;">Interlocked</span>.<span style="color: #daa520;">CompareExchange</span>&lt;SomeState&gt;(<span style="color: #1e90ff; font-weight: bold;">ref</span> <span style="color: #daa520;">someState</span>, <span style="color: #daa520;">newState</span>, <span style="color: #ff6347;">null</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#31532;&#19968;&#20010;&#21442;&#25968;&#21644;&#31532;&#19977;&#20010;&#21442;&#25968;&#27604;&#36739;&#65292;&#22914;&#26524;&#30456;&#31561;&#65292;&#26367;&#25442;&#20026;&#31532;&#20108;&#20010;&#21442;&#25968;&#30340;&#20540;</span>
</pre>


<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">int</span> <span style="color: #008b8b;">State</span>
{ 
    <span style="color: #1e90ff; font-weight: bold;">get</span> 
    {
        <span style="color: #00008b; font-weight: bold;">lock</span> (<span style="color: #1e90ff; font-weight: bold;">this</span>)
        {
            <span style="color: #1e90ff; font-weight: bold;">return</span> ++state;
        }
    }
}
</pre>

<p>
等价于：
</p>


<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #daa520;">int</span> <span style="color: #008b8b;">State</span>
{
    <span style="color: #1e90ff; font-weight: bold;">get</span>
    {
        <span style="color: #1e90ff; font-weight: bold;">return</span> <span style="color: #daa520;">Interlocked</span>.<span style="color: #00008b; font-weight: bold;">Increment</span>(<span style="color: #1e90ff; font-weight: bold;">ref</span> <span style="color: #daa520;">state</span>);
    }
}
</pre>

</li>
</ul>
</div>

</div>

<div id="outline-container-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> WaitHandle</h4>
<div class="outline-text-4" id="text-6-2-2">


<p class="verse">
WaitHandle是一个抽象基类。用于等待某个信号量。<br/>
Mutex、EventWaitHandle、Semaphore类都从WaitHandle派生。<br/>
</p>


</div>

</div>

<div id="outline-container-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> Mutex类</h4>
<div class="outline-text-4" id="text-6-2-3">


<p class="verse">
提供进程之间的同步访问。创建一个进程之间能共享的以字符串命名的互斥锁。<br/>
构造函数的一种形式如下：<br/>
</p>




<pre class="src src-csharp"><span style="color: #daa520;">bool</span> <span style="color: #008b8b;">created</span>;
<span style="color: #daa520;">Mutex</span> <span style="color: #008b8b;">mutex</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Mutex</span>(<span style="color: #ff6347;">false</span>, <span style="color: #9400d3;">"IFFileMutex"</span>, <span style="color: #1e90ff; font-weight: bold;">out</span> <span style="color: #daa520;">created</span>);
</pre>


<p class="verse">
其中，第一个参数定义了该互斥体的所有权是否应属于调用线程。<br/>
第二个参数是互斥体名字，操作系统能识别该字符串，以此实现各进程之间的同步。<br/>
第三个参数，如果系统中已存在该命名的互斥体返回false，否则返回true。<br/>
</p>




<pre class="src src-csharp"><span style="color: #daa520;">Mutex</span> <span style="color: #008b8b;">mutex</span> = <span style="color: #daa520;">Mutex</span>.<span style="color: #00008b; font-weight: bold;">OpenExisting</span>(<span style="color: #9400d3;">"IFFileMutex"</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#25171;&#24320;&#31995;&#32479;&#20013;&#24050;&#23384;&#22312;&#30340;&#20114;&#26021;&#20307;</span>
<span style="color: #1e90ff; font-weight: bold;">if</span>(<span style="color: #008b8b;">mutex</span>.<span style="color: #00008b; font-weight: bold;">WaitOne</span>(500))<span style="color: #8b8989;">//</span><span style="color: #8b8989;">500&#20026;&#31561;&#24453;&#36229;&#26102;&#26102;&#38388;</span>
{
    <span style="color: #1e90ff; font-weight: bold;">try</span>
    {
        <span style="color: #8b8989;">//</span><span style="color: #8b8989;">synchronized region</span>
    }
    <span style="color: #1e90ff; font-weight: bold;">finally</span>
    {
        <span style="color: #008b8b;">mutex</span>.<span style="color: #00008b; font-weight: bold;">ReleaseMutex</span>();
    }
}
</pre>

</div>

</div>

<div id="outline-container-6-2-4" class="outline-4">
<h4 id="sec-6-2-4"><span class="section-number-4">6.2.4</span> Semaphore类</h4>
<div class="outline-text-4" id="text-6-2-4">

<p>信号量可以同时由多个线程使用，是计数的互斥体。一般用于受数量限制的访问资源(如DB连接资源)。
</p></div>

</div>

<div id="outline-container-6-2-5" class="outline-4">
<h4 id="sec-6-2-5"><span class="section-number-4">6.2.5</span> Event类</h4>
<div class="outline-text-4" id="text-6-2-5">


<p class="verse">
系统级的资源同步方式，比之Mutex，多了个Reset方法，<br/>
重置nonsignaled的状态(等同于互斥体的锁定状态)，释放所有等待的线程。<br/>
<br/>
Set方法：将事件设为signaled状态，使其他等待的线程得以继续，类似锁的Release方法。<br/>
Waitone方法：等待事件被设为signaled状态。<br/>
Reset方法：将事件设为nonsignaled状态，并且阻塞所有等待的线程。<br/>
</p>


<ul>
<li id="sec-6-2-5-1">AutoResetEvent<br/>

<p class="verse">
Reset方法会在某一线程Waitone成功后，自动重置为nonsignaled。<br/>
达到的效果：一次只能一个线程继续处理。<br/>
</p>


</li>
</ul>
<ul>
<li id="sec-6-2-5-2">ManualResetEvent<br/>

<p class="verse">
需手动调用Reset方法重置为nonsignaled。<br/>
达到的效果：多个线程都能继续进行处理。<br/>
</p>


</li>
</ul>
</div>

</div>

<div id="outline-container-6-2-6" class="outline-4">
<h4 id="sec-6-2-6"><span class="section-number-4">6.2.6</span> ReaderWriterLockSlim类(.Net 3.5引入)</h4>
<div class="outline-text-4" id="text-6-2-6">


<p class="verse">
如果没有Writer锁定资源，就允许多个Reader访问资源，但只能有一个<br/>
Writer锁定该资源(所有访问中的Reader都必须先释放锁)。<br/>
比之.Net 1.0版本 ReaderWriterLock类，重新设计为防止死锁，提供更好的性能。<br/>
</p>


<ul>
<li>EnterReadLock
  进入锁定，另一个方法TryEnterReadLock允许指定一个超时时间。ExitReadLock释放锁定
</li>
<li>EnterUpgradableReadLock
  用于读取锁定需要改为写入锁定的情况。
</li>
<li>EnterWriteLock
  获得多资源的写入锁定。仅一个线程能获取锁定，在这之前还必须释放所有的读取锁定。
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Timer类</h3>
<div class="outline-text-3" id="text-6-3">

<p>.Net提供了几个Timer类，比较如下：
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">命名空间</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">System.Threading</td><td class="left">提供了Timer的核心功能，在构造函数中传入回调的委托。</td></tr>
<tr><td class="left">System.Timer</td><td class="left">继承Component，可在设计界面拖入，提供了基于事件的机制(非委托)。</td></tr>
<tr><td class="left">System.Windows.Forms</td><td class="left">为单线程环境设计的(创建和回调在同一个线程中执行)，执行回调方法时UI会假死，不宜执行耗时较长的代码。该Timer时间精度55ms。</td></tr>
<tr><td class="left">System.Web.UI</td><td class="left">是一个AJAX扩展，可以用于Web页面</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> 总结</h3>
<div class="outline-text-3" id="text-6-4">

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">类</th><th scope="col" class="left">目的</th><th scope="col" class="left">参考开销<sup><a class="footref" name="fnr-.4" href="#fn-.4">4</a></sup></th><th scope="col" class="left">是否跨进程？</th></tr>
</thead>
<tbody>
<tr><td class="left">lock(Monitor)</td><td class="left">保证单个进程内只有一个线程能够获取同步资源</td><td class="left">20ns</td><td class="left">No</td></tr>
<tr><td class="left">Mutex</td><td class="left">保证只有一个线程能够获取同步资源</td><td class="left">1000ns</td><td class="left">Yes</td></tr>
<tr><td class="left">Semaphore</td><td class="left">可指定可获取同步资源的线程数</td><td class="left">1000ns</td><td class="left">Yes</td></tr>
<tr><td class="left">ReaderWriterLock</td><td class="left">允许多个Reader访问同步资源</td><td class="left">100ns</td><td class="left">No</td></tr>
<tr><td class="left">AutoResetEvent</td><td class="left">当信号被设为signaled状态时，允许单个线程进入同步资源块</td><td class="left">1000ns</td><td class="left">Yes</td></tr>
<tr><td class="left">ManualResetEvent</td><td class="left">当信号被设为signaled状态时，允许所有等待线程进入同步资源块</td><td class="left">1000ns</td><td class="left">Yes</td></tr>
<tr><td class="left">ReaderWriterLockSlim</td><td class="left">可锁定多个Reader访问资源以及单个Writer修改资源</td><td class="left">40ns</td><td class="left">No</td></tr>
</tbody>
</table>


<ul>
<li>注：一些Slim类(如ManualResetEventSlim)，比之旧版本，通常拥有更好的性能。参考 <a href="http://msdn.microsoft.com/en-us/library/5hbefs30(v=vs.100).aspx">MSDN</a>。
</li>
</ul>


<p>
几条规则：
</p><ol>
<li>尽量使同步要求最低，尝试避免共享状态。
</li>
<li>类的静态成员应是线程安全的。
</li>
<li>实例成员不需要是线程安全的。为了最佳性能，最好在类的外部处理同步问题。
</li>
</ol>

</div>

</div>

<div id="outline-container-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> 推荐阅读</h3>
<div class="outline-text-3" id="text-6-5">

<p><a href="http://www.albahari.com/threading/">Threading in C#</a>
</p></div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 诊断</h2>
<div class="outline-text-2" id="text-7">

<p>对应命名空间System.Diagnostics
</p>
</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> 跟踪(Trace)</h3>
<div class="outline-text-3" id="text-7-1">


<p class="verse">
用于应用程序运行时获得消息。记录各种形式的Log等<br/>
</p>


<p>
Trace体系结构：
   </p>
<div class="figure">
<p><img src="../resources/csharp/Trace Architect.png" align="center" alt="../resources/csharp/Trace Architect.png" /></p>

</div>
<ul>
<li>使用TraceSource发送跟踪消息
</li>
<li>Swith定义了要记录的信息级别
</li>
<li>TraceListener定义了写入跟踪消息的位置
</li>
<li>Listener可以关联一个Filter，过滤跟踪消息
</li>
<li>监听器和过滤器都可定制拓展
</li>
</ul>


<p>
可在Visual Studio项目属性的Build Tab中对是否在调试或发布版本中启用Trace标志进行设置。
</p>
</div>

<div id="outline-container-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> TraceSource</h4>
<div class="outline-text-4" id="text-7-1-1">

<p>与Trace类相比，TraceSource类较难使用，提供的选项更多。
</p>


<pre class="src src-csharp"><span style="color: #daa520;">TraceSource</span> <span style="color: #008b8b;">source1</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">TraceSource</span>(<span style="color: #9400d3;">"Tracing"</span>);
<span style="color: #008b8b;">source1</span>.<span style="color: #00008b; font-weight: bold;">TraceInformation</span>(<span style="color: #9400d3;">"Info Message"</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20889;&#20837;Trace&#28040;&#24687;</span>
<span style="color: #008b8b;">source1</span>.<span style="color: #00008b; font-weight: bold;">TraceEvent</span>(<span style="color: #daa520;">TraceEventType</span>.<span style="color: #008b8b;">Error</span>, 3, <span style="color: #9400d3;">"Error Message"</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20889;&#20837;&#25351;&#23450;&#32423;&#21035;&#30340;Trace&#20449;&#24687;&#65292;&#21487;&#20351;&#29992;Switch&#21482;&#26597;&#30475;&#25351;&#23450;&#32423;&#21035;&#30340;&#28040;&#24687;&#12290;</span>
<span style="color: #008b8b;">source1</span>.<span style="color: #00008b; font-weight: bold;">TraceData</span>(<span style="color: #daa520;">TraceEventType</span>.<span style="color: #008b8b;">Information</span>, 2, <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">int</span>[] { 1, 2, 3 });<span style="color: #8b8989;">//</span><span style="color: #8b8989;">TraceData&#21487;&#20197;&#20256;&#20837;&#20219;&#24847;&#23545;&#35937;</span>
<span style="color: #008b8b;">source1</span>.<span style="color: #00008b; font-weight: bold;">Flush</span>();<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#20026;&#30830;&#20445;TraceData&#20256;&#20837;&#30340;&#25968;&#25454;&#30001;&#30417;&#21548;&#22120;&#20889;&#20837;&#65292;&#19988;&#19981;&#23384;&#20648;&#22312;&#20869;&#23384;&#20013;&#65292;&#38656;&#35201;&#25191;&#34892;Flush()</span>
<span style="color: #008b8b;">source1</span>.<span style="color: #00008b; font-weight: bold;">Close</span>();<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#19981;&#20877;&#38656;&#35201;&#35813;&#36319;&#36394;&#28304;&#26102;&#25191;&#34892;&#65292;Close()&#25191;&#34892;&#21516;&#26102;&#20063;&#20250;&#25191;&#34892;Flush()</span>
</pre>

</div>

</div>

<div id="outline-container-7-1-2" class="outline-4">
<h4 id="sec-7-1-2"><span class="section-number-4">7.1.2</span> Swith</h4>
<div class="outline-text-4" id="text-7-1-2">

<p>三个子类可供选择：
</p><ul>
<li>BooleanSwitch 可以打开和关闭跟踪
</li>
<li>TraceSwitch 提供了TraceLevel的选择，过滤Trace消息(TraceLevel包含Off、Error、Warning、Info、Verbose)
</li>
<li>SourceSwitch 提供了TraceLevel的选择，过滤Trace消息
</li>
</ul>


<p>
编程中硬编码方式：
</p>


<pre class="src src-csharp"><span style="color: #008b8b;">source1</span>.<span style="color: #008b8b;">Switch</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">SourceSwitch</span>(<span style="color: #9400d3;">"MySwitch"</span>, <span style="color: #9400d3;">"Warning"</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#26174;&#31034;Warning&#20197;&#19978;&#32423;Trace&#28040;&#24687;</span>
</pre>


<p>
配置文件方式：
</p>


<pre class="src src-xml">&lt;?<span style="color: #1e90ff; font-weight: bold;">xml</span> <span style="color: #008b8b;">version</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">1.0</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">encoding</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">utf-8</span><span style="color: #9400d3;">"</span> ?&gt;
&lt;<span style="color: #00008b; font-weight: bold;">configuration</span>&gt;
  &lt;<span style="color: #00008b; font-weight: bold;">system.diagnostics</span>&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">sources</span>&gt;
      &lt;<span style="color: #00008b; font-weight: bold;">source</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">Tracing</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">switchName</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">MySourceSwitch</span><span style="color: #9400d3;">"</span>
              <span style="color: #008b8b;">switchType</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnostics.SourceSwitch</span><span style="color: #9400d3;">"</span>/&gt;
    &lt;/<span style="color: #00008b; font-weight: bold;">sources</span>&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">switches</span>&gt;
      &lt;<span style="color: #00008b; font-weight: bold;">add</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">MySourceSwitch</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">value</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">Verbose</span><span style="color: #9400d3;">"</span>/&gt;
    &lt;/<span style="color: #00008b; font-weight: bold;">switches</span>&gt;
  &lt;/<span style="color: #00008b; font-weight: bold;">system.diagnostics</span>&gt;
&lt;/<span style="color: #00008b; font-weight: bold;">configuration</span>&gt;
</pre>

<p>
source name必须与程序中定义的TraceSource名匹配。
</p>
</div>

</div>

<div id="outline-container-7-1-3" class="outline-4">
<h4 id="sec-7-1-3"><span class="section-number-4">7.1.3</span> TraceListener</h4>
<div class="outline-text-4" id="text-7-1-3">


<p class="verse">
默认在调试时，当前的追踪消息之写入Visual Studio的Output窗口。<br/>
Trace监听器可重定向到不同的输出位置。需要在配置文件中配置。<br/>
</p>




<pre class="src src-xml">&lt;?<span style="color: #1e90ff; font-weight: bold;">xml</span> <span style="color: #008b8b;">version</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">1.0</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">encoding</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">utf-8</span><span style="color: #9400d3;">"</span> ?&gt;
&lt;<span style="color: #00008b; font-weight: bold;">configuration</span>&gt;
  &lt;<span style="color: #00008b; font-weight: bold;">system.diagnostics</span>&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">sources</span>&gt;
      &lt;<span style="color: #00008b; font-weight: bold;">source</span> <span style="color: #008b8b;">name</span> = <span style="color: #9400d3;">"</span><span style="color: #9400d3;">Tracing</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">switchName</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">MySourceSwitch</span><span style="color: #9400d3;">"</span>
              <span style="color: #008b8b;">switchType</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnositcs.SourceSwitch</span><span style="color: #9400d3;">"</span>&gt;
        &lt;<span style="color: #00008b; font-weight: bold;">listeners</span>&gt;
          <span style="color: #8b8989;">&lt;!--</span><span style="color: #8b8989;">&#30417;&#21548;&#28040;&#24687;&#20197;xml&#26684;&#24335;&#20889;&#20837;</span><span style="color: #8b8989;">--&gt;</span>
          &lt;<span style="color: #00008b; font-weight: bold;">add</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">xmlListener</span><span style="color: #9400d3;">"</span> 
               <span style="color: #008b8b;">type</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnostics.XmlWriterTraceListener</span><span style="color: #9400d3;">"</span>
               <span style="color: #008b8b;">traceOutputOptions</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">None</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">initializeData</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">c:/logs/trace.xml</span><span style="color: #9400d3;">"</span>/&gt;
          &lt;<span style="color: #00008b; font-weight: bold;">add</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">delimitedListener</span><span style="color: #9400d3;">"</span> /&gt;
        &lt;/<span style="color: #00008b; font-weight: bold;">listeners</span>&gt;
      &lt;/<span style="color: #00008b; font-weight: bold;">source</span>&gt;
    &lt;/<span style="color: #00008b; font-weight: bold;">sources</span>&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">sharedListeners</span>&gt;
      <span style="color: #8b8989;">&lt;!--</span><span style="color: #8b8989;">&#30417;&#21548;&#28040;&#24687;&#20197;&#25351;&#23450;&#20998;&#38548;&#31526;&#20998;&#38548;&#28040;&#24687;&#21508;&#37096;&#20998;</span><span style="color: #8b8989;">--&gt;</span>
      &lt;<span style="color: #00008b; font-weight: bold;">add</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">delimitedListener</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">delimiter</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">:</span><span style="color: #9400d3;">"</span> 
           <span style="color: #008b8b;">type</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnostics.DelimitedListTraceListener</span><span style="color: #9400d3;">"</span>
           <span style="color: #008b8b;">traceOutputOptions</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">DataTime, ProcessId</span><span style="color: #9400d3;">"</span>
           <span style="color: #008b8b;">initializeData</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">c:/logs/trace.txt</span><span style="color: #9400d3;">"</span>/&gt;
    &lt;/<span style="color: #00008b; font-weight: bold;">sharedListeners</span>&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">switches</span>&gt;
      &lt;<span style="color: #00008b; font-weight: bold;">add</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">MySourceSwitch</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">value</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">Verbose</span><span style="color: #9400d3;">"</span>/&gt;
    &lt;/<span style="color: #00008b; font-weight: bold;">switches</span>&gt;
  &lt;/<span style="color: #00008b; font-weight: bold;">system.diagnostics</span>&gt;
&lt;/<span style="color: #00008b; font-weight: bold;">configuration</span>&gt;
</pre>

<ul>
<li>traceOutputOptions由TraceOptions这个枚举定义，可将这些额外的信息写入Trace日志。
</li>
<li>sharedListeners元素可以定义共通的监听方式
</li>
</ul>


<p>
以上定义的DelimitedListTraceListener的输出结果如下：
</p>


<pre class="example">"Tracing":Information:0:"Info message"::4188:""::"2012-11-24T12:15:52.3756748Z"::
"Tracing":Error:3:"Error message"::4188:""::"2012-11-24T12:15:52.77546721Z"::
</pre>


<p>
可用监听器列表：
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">监听器名</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">DefaultTraceListener</td><td class="left">默认输出至关联的调试器中，如Visual Studio Output窗口</td></tr>
<tr><td class="left">EventLogTraceListener</td><td class="left">写入EventLog</td></tr>
<tr><td class="left">TextWriterTraceListener</td><td class="left">写入文件</td></tr>
<tr><td class="left">ConsoleTraceListener</td><td class="left">写入控制台，继承TextWriterTraceListener</td></tr>
<tr><td class="left">DelimitedListTraceListener</td><td class="left">写入带指定分隔符的文件，继承TextWriterTraceListener</td></tr>
<tr><td class="left">XmlWriterTraceListener</td><td class="left">写入XML格式文件中，继承TextWriterTraceListener。(默认包括TraceOptions中定义的信息)</td></tr>
<tr><td class="left">IisTraceListener</td><td class="left">.Net 3.0以上，写入IIS中</td></tr>
<tr><td class="left">WebPatgeTraceListener</td><td class="left">依赖于ASP.NET所特有的另一个跟踪选项，在动态创建的输出文件trace.axd中写入Trace信息</td></tr>
</tbody>
</table>


</div>

</div>

<div id="outline-container-7-1-4" class="outline-4">
<h4 id="sec-7-1-4"><span class="section-number-4">7.1.4</span> TraceFilter</h4>
<div class="outline-text-4" id="text-7-1-4">

<p>每个监听器都有一个过滤器。监听器使用过滤器确定是否应写入信息。
</p><ul>
<li>SourceFilter 根据指定源过滤写入的Trace消息
</li>
<li>EventTypeFilter 根据跟踪级别过滤写入的Trace消息
</li>
</ul>




<pre class="src src-xml">&lt;<span style="color: #00008b; font-weight: bold;">sharedListeners</span>&gt;
  &lt;<span style="color: #00008b; font-weight: bold;">add</span> <span style="color: #008b8b;">name</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">xmlListener</span><span style="color: #9400d3;">"</span>
       <span style="color: #008b8b;">type</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnostics.XmlWriterTraceListener</span><span style="color: #9400d3;">"</span>
       <span style="color: #008b8b;">traceOutputOptions</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">None</span><span style="color: #9400d3;">"</span> <span style="color: #008b8b;">initalizeData</span>="c:/logs/trace.xml&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">filter</span> <span style="color: #008b8b;">type</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnostics.SourceFilter</span><span style="color: #9400d3;">"</span>
            <span style="color: #008b8b;">initializeData</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">Tracing</span><span style="color: #9400d3;">"</span>/&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">filter</span> <span style="color: #008b8b;">type</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">System.Diagnostics.EventTypeFilter</span><span style="color: #9400d3;">"</span>
            <span style="color: #008b8b;">initializeData</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">Warning</span><span style="color: #9400d3;">"</span>/&gt;
  &lt;/<span style="color: #00008b; font-weight: bold;">add</span>&gt;
&lt;/<span style="color: #00008b; font-weight: bold;">sharedListeners</span>&gt;
</pre>


</div>

</div>

<div id="outline-container-7-1-5" class="outline-4">
<h4 id="sec-7-1-5"><span class="section-number-4">7.1.5</span> Trace.Assert</h4>
<div class="outline-text-4" id="text-7-1-5">


<p class="verse">
可以显示信息和错误，中止或继续运行应用程序。一般用于开发期。<br/>
还可以用Debug.Assert，项目默认只有Debug时才加入编译。<br/>
是否禁用断言信息可以通过程序配置项配置：<br/>
</p>




<pre class="src src-xml">&lt;<span style="color: #00008b; font-weight: bold;">configuration</span>&gt;
  &lt;<span style="color: #00008b; font-weight: bold;">system.diagnostics</span>&gt;
    &lt;<span style="color: #00008b; font-weight: bold;">assert</span> <span style="color: #008b8b;">assertuienabled</span>=<span style="color: #9400d3;">"</span><span style="color: #9400d3;">false</span><span style="color: #9400d3;">"</span>/&gt;
  &lt;/<span style="color: #00008b; font-weight: bold;">system.diagnostics</span>&gt;
&lt;/<span style="color: #00008b; font-weight: bold;">configuration</span>&gt;
</pre>

</div>
</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 事件日志</h3>
<div class="outline-text-3" id="text-7-2">


</div>

<div id="outline-container-7-2-1" class="outline-4">
<h4 id="sec-7-2-1"><span class="section-number-4">7.2.1</span> 日志分类</h4>
<div class="outline-text-4" id="text-7-2-1">

<ul>
<li>系统： 用于系统驱动程序与硬件驱动程序。
</li>
<li>应用程序：用于各应用程序及服务程序。
</li>
<li>安全：是应用程序的只读日志。
</li>
<li>自定义类别：程序还可以自定义日志类别，可以在“应用程序和服务日志”文件夹中看到自定义的类别。(通常都是这么做的)
</li>
</ul>

</div>
</div>

</div>

<div id="outline-container-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> 性能</h3>
<div class="outline-text-3" id="text-7-3">


</div>

<div id="outline-container-7-3-1" class="outline-4">
<h4 id="sec-7-3-1"><span class="section-number-4">7.3.1</span> 监控类</h4>
<div class="outline-text-4" id="text-7-3-1">

<p>System.Diagnostics提供了如下监控类
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">类名</th><th scope="col" class="left">说明</th></tr>
</thead>
<tbody>
<tr><td class="left">PerformanceCounter</td><td class="left">用于写入计数和监控计数，可使用此类创建新的性能类别</td></tr>
<tr><td class="left">PerformanceCounterCategory</td><td class="left">可查看所有已有的类别以及创建新类别。可从一个类别中获取所有计数器</td></tr>
<tr><td class="left">PerformanceCounterInstaller</td><td class="left">用于安装性能计数器</td></tr>
</tbody>
</table>


</div>
</div>

</div>

<div id="outline-container-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> 代码约定</h3>
<div class="outline-text-3" id="text-7-4">


<p class="verse">
使用System.Diagnostics.Contracts(.Net 4.0引入)，可定义方法中的前提条件、<br/>
后置条件和常量。可以选择性编译进调试级程序或者发布级程序。(VS2010以上<br/>
项目属性→CodeContracts Tab，需另装插件<a href="http://visualstudiogallery.msdn.microsoft.com/1ec7db13-3363-46c9-851f-1ce455f66970">Code Contracts for .NET</a>)。<br/>
</p>


<p>
用法提示：
</p><ul>
<li>前置条件和后置条件都必须放在方法开头。
</li>
<li>验证失败会触发ContractFailed事件，可自定义事件处理程序。
</li>
</ul>


</div>

<div id="outline-container-7-4-1" class="outline-4">
<h4 id="sec-7-4-1"><span class="section-number-4">7.4.1</span> 前置条件</h4>
<div class="outline-text-4" id="text-7-4-1">

<p>有两个方法可以定义前置条件
</p><ol>
<li>Requires()
</li>
<li>Requires&lt;TException&gt;()
</li>
</ol>

<p>看例子，与断言(Assert)的用法非常相似。
</p>


<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">bool</span> <span style="color: #00008b; font-weight: bold;">IsStrValid</span>(<span style="color: #daa520;">int</span> <span style="color: #008b8b;">min</span>, <span style="color: #daa520;">int</span> <span style="color: #008b8b;">max</span>, <span style="color: #daa520;">string</span> <span style="color: #008b8b;">str</span>)
{
    <span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">Requires</span>(min&lt;=max);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#21487;&#23450;&#20041;&#31532;&#20108;&#20010;&#21442;&#25968;&#65292;&#25351;&#23450;&#39564;&#35777;&#22833;&#36133;&#26102;&#26174;&#31034;&#30340;&#23383;&#31526;&#20018;&#12290;</span>
    <span style="color: #daa520;">Contract</span>.<span style="color: #daa520;">Requires</span>&lt;ArgumentNullException&gt;(str != <span style="color: #ff6347;">null</span>, <span style="color: #9400d3;">"Preconditions, o is null"</span>);<span style="color: #8b8989;">//</span><span style="color: #8b8989;">&#39564;&#35777;&#39033; str != null &#20026;false&#26102;&#65292;&#25243;&#20986;&#24322;&#24120;&#12290;</span>
    <span style="color: #daa520;">int</span> <span style="color: #008b8b;">value</span> = <span style="color: #008b8b;">int</span>.<span style="color: #00008b; font-weight: bold;">TryParse</span>(str);
    <span style="color: #1e90ff; font-weight: bold;">if</span> (value &gt;= min || value &lt;= max)
        <span style="color: #1e90ff; font-weight: bold;">return</span> <span style="color: #ff6347;">true</span>;
    <span style="color: #1e90ff; font-weight: bold;">return</span> <span style="color: #ff6347;">false</span>;
}
</pre>

<p>
注意点：
</p><ul>
<li>将ContractFailed事件设为handled，则不抛出异常。
</li>
<li>如果配置了Assert on Contract Failure，则在约定处调用Trace.Assert()方法替代抛出异常。
</li>
<li>遗留代码添加一行代码即可。EndContractBlock指定其之前的代码为条件检查代码。
</li>
</ul>




<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">if</span> (o == <span style="color: #ff6347;">null</span>) <span style="color: #1e90ff; font-weight: bold;">throw</span> <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">ArgumentNullException</span>(<span style="color: #9400d3;">"o"</span>);
<span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">EndContractBlock</span>();
</pre>

<ul>
<li>Contract类提供了Exists()和ForAll()方法用作参数的检查。ForAll针对集合。可用于前置条件、后置条件和常量。
</li>
</ul>




<pre class="src src-csharp"><span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">ArrayTest</span>(<span style="color: #daa520;">int</span>[] <span style="color: #008b8b;">data</span>)
{
    <span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">Requires</span>(<span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">ForAll</span>(data, i=&gt;i&lt;12));
}
</pre>

</div>

</div>

<div id="outline-container-7-4-2" class="outline-4">
<h4 id="sec-7-4-2"><span class="section-number-4">7.4.2</span> 后置条件</h4>
<div class="outline-text-4" id="text-7-4-2">

<p>定义后置条件的两个方法：
</p><ol>
<li>Ensures()
</li>
<li>EnsuresOnThrow&lt;TException&gt;()
</li>
</ol>

<p>用法大致上与前置条件差不多，请看示例，不再累述。
</p>


<pre class="src src-csharp"><span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">int</span> <span style="color: #008b8b;">sharedState</span> = 5;
<span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">Postcondtion</span>()
{
    <span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">Ensures</span>(sharedState &lt; 6);
    sharedState--;
}
<span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">int</span> <span style="color: #00008b; font-weight: bold;">ReturnValue</span>()
{
    <span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">Ensures</span>(<span style="color: #daa520;">Contract</span>.<span style="color: #daa520;">Result</span>&lt;<span style="color: #daa520;">int</span>&gt;() &lt; 6);
    <span style="color: #1e90ff; font-weight: bold;">return</span> 3;
}
</pre>

</div>

</div>

<div id="outline-container-7-4-3" class="outline-4">
<h4 id="sec-7-4-3"><span class="section-number-4">7.4.3</span> 常量条件</h4>
<div class="outline-text-4" id="text-7-4-3">


<p class="verse">
定义了在整个方法生命期中都必须满足的条件。<br/>
Contract.Invariant(x&gt;5)说明整个方法生命期中x都必须大于5。<br/>
</p>


</div>

</div>

<div id="outline-container-7-4-4" class="outline-4">
<h4 id="sec-7-4-4"><span class="section-number-4">7.4.4</span> 接口协定</h4>
<div class="outline-text-4" id="text-7-4-4">

<p>可使用ContractClass、ContractClassFor、Pure特性来为接口定义约束条件类。
</p>


<pre class="src src-csharp">[ContractClass(<span style="color: #1e90ff; font-weight: bold;">typeof</span>(PersonContract))]
<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">interface</span> <span style="color: #daa520;">IPerson</span>
{
    <span style="color: #daa520;">string</span> <span style="color: #008b8b;">Name</span>{ <span style="color: #1e90ff; font-weight: bold;">get</span>; <span style="color: #1e90ff; font-weight: bold;">set</span>; }
}

[<span style="color: #daa520;">ContractClassFor</span>(<span style="color: #1e90ff; font-weight: bold;">typeof</span>(IPerson))]
<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">PersonContract</span> : <span style="color: #daa520;">IPerson</span>
{
    <span style="color: #daa520;">string</span> <span style="color: #daa520;">IPerson</span>.<span style="color: #008b8b;">Name</span>
    {
        [<span style="color: #daa520;">Pure</span>] <span style="color: #1e90ff; font-weight: bold;">get</span> { <span style="color: #1e90ff; font-weight: bold;">return</span> <span style="color: #daa520;">Contract</span>.<span style="color: #daa520;">Result</span>&lt;<span style="color: #daa520;">string</span>&gt;(); }
        <span style="color: #1e90ff; font-weight: bold;">set</span> { <span style="color: #daa520;">Contract</span>.<span style="color: #00008b; font-weight: bold;">Requires</span>(value != <span style="color: #ff6347;">null</span>); }
    }
}

<span style="color: #1e90ff; font-weight: bold;">public</span> <span style="color: #1e90ff; font-weight: bold;">class</span> <span style="color: #daa520;">Person</span> : <span style="color: #daa520;">IPerson</span>
{
    <span style="color: #daa520;">string</span> <span style="color: #008b8b;">Name</span>{ <span style="color: #1e90ff; font-weight: bold;">get</span>; <span style="color: #1e90ff; font-weight: bold;">set</span>; }
}

<span style="color: #1e90ff; font-weight: bold;">static</span> <span style="color: #daa520;">void</span> <span style="color: #00008b; font-weight: bold;">Main</span>()
{
    <span style="color: #daa520;">var</span> <span style="color: #008b8b;">p</span> = <span style="color: #1e90ff; font-weight: bold;">new</span> <span style="color: #daa520;">Person</span> { Name = <span style="color: #ff6347;">null</span> };<span style="color: #8b8989;">//</span><span style="color: #8b8989;">contract error</span>
}
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> 程序集</h2>
<div class="outline-text-2" id="text-8">


</div>

<div id="outline-container-8-1" class="outline-3">
<h3 id="sec-8-1"><span class="section-number-3">8.1</span> 共享程序集</h3>
<div class="outline-text-3" id="text-8-1">


<p class="verse">
①GAC全局共享<br/>
②配置文件codeBase元素配置，共享程序集路径如没有，搜索probing元素。<br/>
</p>


</div>

</div>

<div id="outline-container-8-2" class="outline-3">
<h3 id="sec-8-2"><span class="section-number-3">8.2</span> Useful Utility</h3>
<div class="outline-text-3" id="text-8-2">

<ul>
<li>ILDASM 将汇编转成IL代码
</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/k5b5tt23(v=vs.90).aspx">Sn.exe</a> 公用程序集强名工具
</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/ex0ss12c(v=vs.90).aspx">Gacutil.exe</a> 公用程序集安装工具
</li>
<li><a href="http://msdn.microsoft.com/zh-cn/library/6t9t5wcf(v=vs.90).aspx">Ngen.exe</a> 安装期间IL转成汇编机器码，提高托管应用程序性能的工具，取代程序集的JIT编译。
</li>
</ul>


<p class="verse">
预编译的程序集和需要运行JIT编译的程序集，其性能在编译IL代码后差别不大。<br/>
使用Ngen.exe唯一改进是，应用程序启动比较快，因为不需要启动JIT编译器。<br/>
需保证应用程序所有程序集均已作成本机映像<br/>
</p>


</div>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 部署</h2>
<div class="outline-text-2" id="text-9">


</div>

<div id="outline-container-9-1" class="outline-3">
<h3 id="sec-9-1"><span class="section-number-3">9.1</span> 自定义安装包</h3>
<div class="outline-text-3" id="text-9-1">

<ol>
<li><a href="http://blog.csdn.net/wonsoft/article/details/5956320">打包微软各种库的方法</a>
</li>
<li><a href="http://blog.csdn.net/cxyyxc/article/details/1725703">自动安装web网站及执行SQL的方法IIS6</a>
</li>
</ol>

</div>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> WebService</h2>
<div class="outline-text-2" id="text-10">


<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn-.1" href="#fnr-.1">1</a></sup> 例子参照《C# 高级编程(第7版)》
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.2" href="#fnr-.2">2</a></sup> 给线程指定较高的基本优先级时，需注意。这有可能会降低其他线程的运行概率。
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.3" href="#fnr-.3">3</a></sup> 可以捕捉该异常完成线程的资源清理任务。
</p>


<p class="footnote"><sup><a class="footnum" name="fn-.4" href="#fnr-.4">4</a></sup> 该时间测自CPU Intel Core i7 860的环境，参考<a href="http://www.albahari.com/threading/">Threading in C#</a>
</p></div>
</div>

</div>
</div>
</div>

</body>
</html>
