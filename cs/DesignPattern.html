<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
<!-- 2017-06-22 Thu 10:35 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>设计模式</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="ChrisChen" />
<meta name="keywords" content="design pattern" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../styles/demo/css/demo.css"/>
<link href="https://fonts.proxy.ustclug.org/css?family=Roboto+Slab:400,700|Inconsolata:400,700" rel="stylesheet" type="text/css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">设计模式</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4ba762d">1. OO 基本原则</a></li>
<li><a href="#org8d2428e">2. 策略模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgd323e5f">3. 状态模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgb4931e7">4. 观察者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org6efcbc6">5. 模板方法&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="_">类</span></span></a></li>
<li><a href="#org63df6c0">6. 装饰者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgb8d5da4">7. 单件模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgacd7281">8. 工厂模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org5c17382">9. 命令模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#org95a1d64">10. 适配器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="_">类</span>&#xa0;<span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#org0938dbf">11. 代理模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#org4d5b0f6">12. 外观模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#orgaaa33aa">13. 迭代器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#org4e5397a">14. 桥接模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></a></li>
<li><a href="#orgfd62df5">15. 生成器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orge7e7da6">16. 组合模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">结构型</span>&#xa0;<span class="__">对象</span></span></a></li>
<li><a href="#orgcaf2ec3">17. 责任链模式</a></li>
<li><a href="#org79554fc">18. 一些 OO 提示</a></li>
</ul>
</div>
</div>
<div id="outline-container-org4ba762d" class="outline-2">
<h2 id="org4ba762d"><span class="section-number-2">1</span> OO 基本原则</h2>
<div class="outline-text-2" id="text-1">
<p>
S.O.L.I.D
</p>

<ul class="org-ul">
<li>单一职责原则</li>
<li>开放封闭原则</li>
<li>子类替换原则</li>
<li>接口隔离原则</li>
<li>依赖倒置原则</li>
</ul>
</div>
</div>

<div id="outline-container-org8d2428e" class="outline-2">
<h2 id="org8d2428e"><span class="section-number-2">2</span> 策略模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-2">
<p>
<a id="orgfdc6fc2"></a>
</p>
</div>
<div id="outline-container-orgc906f86" class="outline-3">
<h3 id="orgc906f86"><span class="section-number-3">2.1</span> 概述</h3>
<div class="outline-text-3" id="text-2-1">
<p>
定义一系列算法，分别封装起来，使它们之间可以相互替换。
</p>
</div>
</div>

<div id="outline-container-org84c14a2" class="outline-3">
<h3 id="org84c14a2"><span class="section-number-3">2.2</span> 适用性</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>一些 <b>相关</b> 的类接口一致，仅仅是行为有异</li>
<li>使算法使用的数据结构不暴露于客户</li>
<li>一个类定义了多种行为，且这些行为在类中是以多个条件语句的形式出现的</li>
</ul>
</div>
</div>

<div id="outline-container-orgdc7c89c" class="outline-3">
<h3 id="orgdc7c89c"><span class="section-number-3">2.3</span> 结构</h3>
<div class="outline-text-3" id="text-2-3">

<div class="figure">
<p><img src="../resources/OO/Strategy.png" alt="Strategy.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org309291a" class="outline-3">
<h3 id="org309291a"><span class="section-number-3">2.4</span> 角色</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li><p>
Context
</p>
<p class="verse">
维护一个 Strategy 对象的引用<br />
可开放接口，让 Strategy 访问其数据<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org0748786" class="outline-3">
<h3 id="org0748786"><span class="section-number-3">2.5</span> 优点</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>定义一组可供重用的算法（共通内容可放置于基类）</li>
<li>替代继承使用组合，更灵活，不用硬编码至 Context 中</li>
<li>消除条件语句</li>
<li>客户代码可以动态的选择具体算法</li>
</ul>
</div>
</div>

<div id="outline-container-org09b8026" class="outline-3">
<h3 id="org09b8026"><span class="section-number-3">2.6</span> 缺点</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li><p>
客户代码必须了解到具体算法之间的区别（增加耦合）
</p>

<p>
Gof 建议：仅当不同行为是与客户相关的行为有关时，才使用 Strategy 模式
</p></li>

<li><p>
Strategy 和 Context 之间的通信开销
</p>

<p>
各具体算法所需要的参数不一样，但是接口共享。导致需要额外增加两边接口，导致这两个类更紧密的耦合
</p></li>

<li><p>
增加了对象的数目
</p>

<p>
参考 Flyweight 模式
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org6eaa6be" class="outline-3">
<h3 id="org6eaa6be"><span class="section-number-3">2.7</span> 实现</h3>
<div class="outline-text-3" id="text-2-7">
</div><div id="outline-container-org745d927" class="outline-4">
<h4 id="org745d927"><span class="section-number-4">2.7.1</span> 需定义 Context 和 Strategy 之间数据交换的接口</h4>
<div class="outline-text-4" id="text-2-7-1">
<ul class="org-ul">
<li><p>
方法一 Push：将数据作为参数放在 Strategy 的接口 AlgorithmInterface()中。
</p>

<p>
缺点：Context 可能发送一些 Strategy 不需要的数据。
</p></li>

<li><p>
方法二 Pull：Context 将自身作为参数传递给 Strategy，Strategy 再调用 Get 获取数据。
</p>

<p>
缺点：Context 必须为 Strategy 定义一堆更精细的 Get 接口。（C++中可使用友元）
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org38a757b" class="outline-4">
<h4 id="org38a757b"><span class="section-number-4">2.7.2</span> 将 Strategy 作为 C++模板参数</h4>
<div class="outline-text-4" id="text-2-7-2">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #F92672;">template</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #F92672;">typename</span> <span style="color: #66D9EF;">Strategy</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Context</span>
<span style="color: #AE81FF;">{</span>
<span style="color: #F92672;">private</span>:
    <span style="color: #66D9EF;">Strategy</span> <span style="color: #FD971F;">theStrategy</span>;
<span style="color: #F92672;">public</span>:
    <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">ContextInterface</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>theStrategy.AlgorithmInterface<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">}</span>
<span style="color: #AE81FF;">}</span>;
</pre>
</div>
<ul class="org-ul">
<li>不再需要 Strategy 抽象基类。</li>
<li>避免多态，使用模板在编译时就绑定 Strategy 和 Context，提高运行效率，牺牲了动态绑定的灵活性。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org45875ed" class="outline-3">
<h3 id="org45875ed"><span class="section-number-3">2.8</span> 相关模式</h3>
<div class="outline-text-3" id="text-2-8">
<p>
<a href="#org6beb90e">State</a> <a href="#orgadae4a8">两者区别</a>、<a href="#org7d863e0">Template Method</a>
</p>
</div>
</div>
</div>
<div id="outline-container-orgd323e5f" class="outline-2">
<h2 id="orgd323e5f"><span class="section-number-2">3</span> 状态模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="org6beb90e"></a>
</p>
</div>
<div id="outline-container-org830dd9e" class="outline-3">
<h3 id="org830dd9e"><span class="section-number-3">3.1</span> 概述</h3>
<div class="outline-text-3" id="text-3-1">
<p>
对象的行为随着内部状态的改变而改变。
</p>
</div>
</div>

<div id="outline-container-orgaec9586" class="outline-3">
<h3 id="orgaec9586"><span class="section-number-3">3.2</span> 适用性</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>一个对象的行为取决于它的状态，并且需要在 <b>运行时</b> 根据它的状态改变它的行为</li>
<li>大量的依赖于对象状态的分支 <b>条件语句</b> 是一个信号，通常可以用 State 模式进行改造。</li>
</ul>
</div>
</div>

<div id="outline-container-orgfcee690" class="outline-3">
<h3 id="orgfcee690"><span class="section-number-3">3.3</span> 结构</h3>
<div class="outline-text-3" id="text-3-3">

<div class="figure">
<p><img src="../resources/OO/State.png" alt="State.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org28941f4" class="outline-3">
<h3 id="org28941f4"><span class="section-number-3">3.4</span> 优点</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>易扩展新的状态，只需定义新的子类</li>
<li><p>
State 对象可以被多个 Context 对象共享
</p>
<p class="verse">
条件：状态 <b>对象</b> 不能持有自己的状态实例。需要将状态实例指定到一个静态变量中(可用单件模式实现)<br />
<br />
如果状态需要利用 Context 中的数据或方法，可在 Handle()方法传入 Context 的引用。<br />
<br />
这种实现不再需要 State 类保存自身的引用，可实现没有内部状态只有行为的轻量级对象。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org7383bc1" class="outline-3">
<h3 id="org7383bc1"><span class="section-number-3">3.5</span> 实现</h3>
<div class="outline-text-3" id="text-3-5">
</div><div id="outline-container-orgd116eef" class="outline-4">
<h4 id="orgd116eef"><span class="section-number-4">3.5.1</span> 谁定义状态转换</h4>
<div class="outline-text-4" id="text-3-5-1">
<ol class="org-ol">
<li>可由 Context 全权负责状态转移</li>
<li><p>
通常由 State 具体类自身指定它们的后继状态更方便灵活
</p>
<p class="verse">
可以给 Context 增加一个接口，让 State 子类对象显式地设定 Context 的内部状态。<br />
由 State 子类来指定状态转移的缺点是，增加了子类之间的依赖。<br />
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgb46ae40" class="outline-4">
<h4 id="orgb46ae40"><span class="section-number-4">3.5.2</span> 可使用表驱动法</h4>
<div class="outline-text-4" id="text-3-5-2">
<ul class="org-ul">
<li>State 模式主要对状态相关的行为进行建模</li>
<li>而表驱动着重于定义状态的转换，通常表的 key 表示某一状态，Value 为它的后继状态。</li>
</ul>
</div>
</div>

<div id="outline-container-orgdbbc85d" class="outline-4">
<h4 id="orgdbbc85d"><span class="section-number-4">3.5.3</span> 创建和销毁 State 对象</h4>
<div class="outline-text-4" id="text-3-5-3">
</div><ul class="org-ul"><li><a id="orge2254ce"></a>面临权衡：(1)需要时创建；(2)提前创建所有的 State 子类对象<br /><div class="outline-text-5" id="text-orge2254ce">
<ol class="org-ol">
<li>将要进入的状态在运行时是不可知的，且上下文不经常改变状态时，选择(1)。</li>
<li>另外，当 State 对象存储大量的信息时，使用(1)。</li>
<li>当状态频繁变化时，第(2)种方法更好。Context 对象需保存所有 State 子类对象的引用(不宜扩展)。</li>
</ol>
</div></li></ul>
</div>
</div>

<div id="outline-container-org2a2fd25" class="outline-3">
<h3 id="org2a2fd25"><span class="section-number-3">3.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-3-6">
<p>
<a href="#orgfdc6fc2">Strategy</a>、<a href="#org7d863e0">Template Method</a>
</p>
</div>
<div id="outline-container-org9750d0e" class="outline-4">
<h4 id="org9750d0e"><span class="section-number-4">3.6.1</span> 与 Strategy 模式的区别</h4>
<div class="outline-text-4" id="text-3-6-1">
<p>
<a id="orgadae4a8"></a>
意图：
</p>
<ul class="org-ul">
<li>Strategy 定义的是一组平行的算法，这些算法有着共同的目标。</li>
<li>State 模式更关注根据内在状态的不同，执行不同的行为，这些行为可能目的完全不同。</li>
</ul>
<p>
客户角度：
</p>
<ul class="org-ul">
<li>State 模式：通常的用法，状态通常跟着 Context 的行为而改变，对客户来说状态转换规则是不可见的。</li>
<li>Strategy 模式：为了灵活，通常是由客户来指定具体的策略。</li>
</ul>
<p>
总结：
</p>
<ul class="org-ul">
<li>Strategy 模式提供了一个继承之外更具弹性的替换方案。</li>
<li>State 模式更多的用来避免 Context 中过多的分支语句。</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb4931e7" class="outline-2">
<h2 id="orgb4931e7"><span class="section-number-2">4</span> 观察者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-4">
<p>
<a id="org06be4fc"></a>
</p>
</div>
<div id="outline-container-org0c94bd3" class="outline-3">
<h3 id="org0c94bd3"><span class="section-number-3">4.1</span> 概述</h3>
<div class="outline-text-3" id="text-4-1">
<p>
定义对象之间一对多的依赖，当一个对象状态发生变化时，所有依赖于它的对象都得到通知。
</p>
</div>
</div>

<div id="outline-container-org8cd811f" class="outline-3">
<h3 id="org8cd811f"><span class="section-number-3">4.2</span> 结构</h3>
<div class="outline-text-3" id="text-4-2">

<div class="figure">
<p><img src="../resources/OO/Observer.png" alt="Observer.png" />
</p>
</div>

<p>
当一个观察者接收到改变指示后，流程图如下所示：
</p>


<div class="figure">
<p><img src="../resources/OO/ObserverSeq.png" alt="ObserverSeq.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org63cecf1" class="outline-3">
<h3 id="org63cecf1"><span class="section-number-3">4.3</span> 优点</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li><p>
Subject 和 Observer 间是抽象耦合
</p>
<p class="verse">
因为是非紧密耦合，Subject 和 Observer 可以来自于系统中的不同的抽象层次<br />
低层次 Subject 一样可以通知高层次 Observer，使用该模式不会破坏系统层次<br />
这就是抽象 Subject 和 Observer 的作用。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org5be61aa" class="outline-3">
<h3 id="org5be61aa"><span class="section-number-3">4.4</span> 缺点</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li><p>
来自某一观察者的意外更新
</p>
<p class="verse">
某个观察者更新了主题的状态，导致其他观察者也发生了改变。<br />
如果更新准则定义或维护不当，常常会引起错误的更新。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org3b20545" class="outline-3">
<h3 id="org3b20545"><span class="section-number-3">4.5</span> 实现</h3>
<div class="outline-text-3" id="text-4-5">
</div><div id="outline-container-org2b2a977" class="outline-4">
<h4 id="org2b2a977"><span class="section-number-4">4.5.1</span> 主题与观察者的关联方式</h4>
<div class="outline-text-4" id="text-4-5-1">
<ul class="org-ul">
<li>主题跟踪观察者最简单的方式是保存观察者们的引用</li>
<li>另一种方式是维护一份主题与观察者之间的映射表</li>
</ul>
</div>
</div>

<div id="outline-container-org0bbc59a" class="outline-4">
<h4 id="org0bbc59a"><span class="section-number-4">4.5.2</span> 观察多个主题</h4>
<div class="outline-text-4" id="text-4-5-2">
<p class="verse">
某些情况下，观察多个主题是有意义的，例如：一个表格对象依赖于多个数据源。<br />
需要扩展 Update 接口使观察者知道是哪一个主题送来的。<br />
主题可以简单的将自己作为观察者 Update 接口的参数，让观察者知道应去检查哪一个目标。<br />
</p>
</div>
</div>

<div id="outline-container-orgd30a809" class="outline-4">
<h4 id="orgd30a809"><span class="section-number-4">4.5.3</span> 谁触发更新</h4>
<div class="outline-text-4" id="text-4-5-3">
<p>
Notify 谁来调用？
</p>

<ul class="org-ul">
<li>由主题对象的状态设定操作自动调用。
<ul class="org-ul">
<li>优点：客户不需要调用 Notify。</li>
<li>缺点：多个连续的设定操作会产生多次连续更新，可能效率较低。(关键还是要看需求：在更新状态的时候是否需要通知)</li>
</ul></li>

<li>客户负责调用 Notify
<ul class="org-ul">
<li>优点：客户可以在一系列状态设定操作之后一次性通知更新。</li>
<li>缺点：给客户增加了触发更新的责任。客户忘记的话，容易出错。</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgcf302cc" class="outline-4">
<h4 id="orgcf302cc"><span class="section-number-4">4.5.4</span> 主题删除时，应通知观察者置空主题引用</h4>
</div>

<div id="outline-container-orgca96dfd" class="outline-4">
<h4 id="orgca96dfd"><span class="section-number-4">4.5.5</span> 在发出通知前，确保主题的状态自身是一致的</h4>
<div class="outline-text-4" id="text-4-5-5">
<p>
反例如下：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #66D9EF;">void</span> <span style="color: #AE81FF;">MySubject</span>::<span style="color: #A6E22E;">Operation</span> <span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">int</span> <span style="color: #FD971F;">newValue</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
  <span style="color: #AE81FF;">BaseClassSubject</span>::Operation<span style="color: #66D9EF;">(</span>newValue<span style="color: #66D9EF;">)</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#20808;&#35302;&#21457;&#20102;&#36890;&#30693;</span>
  _myInstVar += newValue;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#21518;&#20462;&#25913;&#33258;&#36523;&#29366;&#24577;</span>
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<p>
可以使用<a href="#org7d863e0">模板方法</a>发送通知来避免这种错误。(模板方法规定好修改状态和触发通知的顺序)
</p>
</div>
</div>

<div id="outline-container-org29f0343" class="outline-4">
<h4 id="org29f0343"><span class="section-number-4">4.5.6</span> 推拉模型的取舍</h4>
<div class="outline-text-4" id="text-4-5-6">
<ul class="org-ul">
<li>推模型(大多数情况使用它)
<ul class="org-ul">
<li>Update 参数传入的信息可能有很多，并非是所有观察者都需要的。</li>
<li>主题对观察者所需要的信息的假定并不总是正确。</li>
</ul></li>

<li>拉模型
<ul class="org-ul">
<li>Update 传入主题的引用。</li>
<li>观察者自己向主题获取信息。</li>
<li>缺点：可能需要调用多个接口以搜集全观察者自己需要的状态。(耦合度增加)</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-orgad0a64c" class="outline-4">
<h4 id="orgad0a64c"><span class="section-number-4">4.5.7</span> 只关注感兴趣的改变</h4>
<div class="outline-text-4" id="text-4-5-7">
<p>
扩展主题的注册接口，加入 interest 参数
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #75715E;">//</span><span style="color: #75715E;">&#20027;&#39064;</span>
<span style="color: #66D9EF;">void</span> <span style="color: #AE81FF;">Subject</span>::<span style="color: #A6E22E;">Attach</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Observer</span>*, <span style="color: #66D9EF;">Aspect</span>&amp; <span style="color: #FD971F;">interest</span><span style="color: #AE81FF;">)</span>;
<span style="color: #75715E;">//</span><span style="color: #75715E;">&#35266;&#23519;&#32773;</span>
<span style="color: #66D9EF;">void</span> <span style="color: #AE81FF;">Observer</span>::<span style="color: #A6E22E;">Update</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Subject</span>*, <span style="color: #66D9EF;">Aspect</span>&amp; <span style="color: #FD971F;">interest</span><span style="color: #AE81FF;">)</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc774eef" class="outline-4">
<h4 id="orgc774eef"><span class="section-number-4">4.5.8</span> 封装复杂的更新语义(ChangeManager)</h4>
<div class="outline-text-4" id="text-4-5-8">
<p class="verse">
当主题与观察者之间的依赖关系特别复杂时，<br />
需要一个 ChangeManager 对象来维护这些关系。<br />
<br />
目的：尽量减少观察者反映其主题的状态变化所需的工作量。<br />
例子：如果一操作涉及到几个主题，就必须保证所有的主题都更改完了，再<br />
一并通知它们的观察者。<br />
</p>

<p>
该对象主要有 <b>三个职责</b> ：
</p>
<ul class="org-ul">
<li>管理主题与观察者之间的映射表，提供接口来维护这个映射表。</li>
<li>定义一个特定的更新策略。</li>
<li>根据一个主题的请求，更新所有它的观察者。</li>
</ul>
<p>
详细参考：<a href="#org5a186eb">基于 ChangeManager 的 Observer 模式</a>
</p>
</div>
</div>
</div>

<div id="outline-container-org3c8d746" class="outline-3">
<h3 id="org3c8d746"><span class="section-number-3">4.6</span> 扩展</h3>
<div class="outline-text-3" id="text-4-6">
<p>
<a id="org5a186eb"></a>
基于 ChangeManager 的 Observer 模式
</p>

<div class="figure">
<p><img src="../resources/OO/ObserverWithChangeManager.png" alt="ObserverWithChangeManager.png" />
</p>
</div>

<p>
具体更新策略由具体的 ChangeManager 来决定：
</p>
<ul class="org-ul">
<li>SimpleChangeManager 总是更新每一个主题的所有观察者</li>
<li>DAGChangeManager 实现多个主题变更时，只更新观察者一次</li>
</ul>
</div>
</div>

<div id="outline-container-org25de104" class="outline-3">
<h3 id="org25de104"><span class="section-number-3">4.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>ChangeManager 是一个 Mediator 模式的实例</li>
<li>ChangeManager 通常是 Singleton 模式</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org6efcbc6" class="outline-2">
<h2 id="org6efcbc6"><span class="section-number-2">5</span> 模板方法&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="_">类</span></span></h2>
<div class="outline-text-2" id="text-5">
<p>
<a id="org7d863e0"></a>
</p>
</div>
<div id="outline-container-org4c684b3" class="outline-3">
<h3 id="org4c684b3"><span class="section-number-3">5.1</span> 概述</h3>
<div class="outline-text-3" id="text-5-1">
<p class="verse">
最基本的设计模式，代码复用的基本技术<br />
定义一系列算法的骨架，将其中的一些步骤延迟到子类中。<br />
使子类可以不改变一个算法的结构，而重定义算法的某些特定步骤。<br />
</p>
</div>
</div>
<div id="outline-container-org54ab091" class="outline-3">
<h3 id="org54ab091"><span class="section-number-3">5.2</span> 适用性</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>多个子类中存在一些公共行为，需要提取出来，做法如下：
<ol class="org-ol">
<li>识别代码中不同部分</li>
<li>提取出新的函数</li>
<li>用一个新的模板方法替换原算法(公共部分放于其中)</li>
</ol></li>
<li>控制子类扩展，模板方法只在特定点调用子类方法</li>
</ul>
</div>
</div>
<div id="outline-container-orgc183e77" class="outline-3">
<h3 id="orgc183e77"><span class="section-number-3">5.3</span> 结构</h3>
<div class="outline-text-3" id="text-5-3">

<div class="figure">
<p><img src="../resources/OO/TemplateMethod.png" alt="TemplateMethod.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orga01b523" class="outline-3">
<h3 id="orga01b523"><span class="section-number-3">5.4</span> 优点</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li><p>
提供了反向的控制结构。即"好莱坞法则"："别找我们，我们找你。"。
</p>
<p class="verse">
即高层组件调用低层组件，低层组件不能调用高层组件。<br />
但并非低层组件一定不能调用高层组件，最重要的是避免让<br />
高层组件和低层组件之间有明显的环状依赖。<br />
</p></li>
<li>一个模板方法整合了一系列操作，从而减少了需要客户程序调用的接口数。</li>
<li>客户代码只依赖于模板方法基类，不依赖于具体类，减少整个系统的 <b>依赖</b> 。</li>
</ul>
</div>
</div>

<div id="outline-container-org303852f" class="outline-3">
<h3 id="org303852f"><span class="section-number-3">5.5</span> 实现</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li><p>
hook operations
提供缺省<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>的行为，子类在必要时拓展。例如：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #66D9EF;">void</span> <span style="color: #AE81FF;">AbstractClass</span>::<span style="color: #A6E22E;">TemplateMethod</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
  Operation1<span style="color: #66D9EF;">()</span>;
  Operation2<span style="color: #66D9EF;">()</span>;
  Hook1<span style="color: #66D9EF;">()</span>;
  <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>HookFileExisted<span style="color: #A6E22E;">()</span><span style="color: #66D9EF;">)</span>
    <span style="color: #66D9EF;">{</span>
      Operation3<span style="color: #A6E22E;">()</span>;
    <span style="color: #66D9EF;">}</span>
<span style="color: #AE81FF;">}</span>

<span style="color: #66D9EF;">bool</span> <span style="color: #AE81FF;">AbstractClass</span>::<span style="color: #A6E22E;">HookFileExisted</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
  <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">true</span>;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
<p class="verse">
<b>重要</b> ：模板方法应该指明哪些操作是钩子(可被重定义)，哪些操作是抽象操作(必须被重定义)。<br />
可以做一个命名约定<br />
需被重定义的操作加上前缀"Do"<br />
钩子方法加上前缀"Hook"<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org22a5ef5" class="outline-3">
<h3 id="org22a5ef5"><span class="section-number-3">5.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>Factory Method 常被模板方法调用。</li>
<li>Strategy 使用委托来改变整个算法，模板方法使用继承来改变算法的一部分。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org63df6c0" class="outline-2">
<h2 id="org63df6c0"><span class="section-number-2">6</span> 装饰者模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-6">
<p>
<a id="orgab8f698"></a>
</p>
</div>
<div id="outline-container-org274dc45" class="outline-3">
<h3 id="org274dc45"><span class="section-number-3">6.1</span> 概述</h3>
<div class="outline-text-3" id="text-6-1">
<p>
动态地给一个对象添加一些额外的职责。提供了比继承更大的灵活<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>。
</p>
</div>
</div>

<div id="outline-container-orge5a9264" class="outline-3">
<h3 id="orge5a9264"><span class="section-number-3">6.2</span> 结构</h3>
<div class="outline-text-3" id="text-6-2">

<div class="figure">
<p><img src="../resources/OO/Decorator.png" alt="Decorator.png" />
</p>
</div>

<ul class="org-ul">
<li>使用继承的目的是为了达到类型匹配，使用户在使用 Decorator 对象时，与使用 Component 一样。</li>
</ul>
</div>
</div>

<div id="outline-container-org3dd64dd" class="outline-3">
<h3 id="org3dd64dd"><span class="section-number-3">6.3</span> 优点</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>比静态继承更灵活，在运行时添加职责。</li>
<li>继承在添加一些共通职责时，容易产生类爆炸。Decorator 添加的职责大多数情况下能重用。</li>
<li>使结构层次较高的类更简洁。不依赖于现有已扩展的 Decorator 类，定义新类型的 Decorator 很容易。</li>
</ul>
</div>
</div>

<div id="outline-container-org21cbc1f" class="outline-3">
<h3 id="org21cbc1f"><span class="section-number-3">6.4</span> 缺点</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>使用装饰时不应该依赖于对象标识。被装饰了的组件与这个组件本身就对象标识而言，是有区别的。</li>
<li>产生很多小对象。对于不了解系统的人，难以学习，排错也比较困难。</li>
</ul>
</div>
</div>

<div id="outline-container-orgc03c36e" class="outline-3">
<h3 id="orgc03c36e"><span class="section-number-3">6.5</span> 实现</h3>
<div class="outline-text-3" id="text-6-5">
<ol class="org-ol">
<li>接口一致性。所有的 Component 和 Decorator 必须有一个公共的父类。</li>
<li>抽象的 Decorator 基类是可选的。仅需添加一个职责时，无需 Decorator 基类。</li>
<li>保持 Component 类的简单性。公共父类仅定义接口，尽量避免加入子类并不需要的职责。</li>
</ol>
</div>
</div>

<div id="outline-container-org143f1f9" class="outline-3">
<h3 id="org143f1f9"><span class="section-number-3">6.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-6-6">
</div><div id="outline-container-orgb0dc2a9" class="outline-4">
<h4 id="orgb0dc2a9"><span class="section-number-4">6.6.1</span> 与 Strategy 的比较：</h4>
<div class="outline-text-4" id="text-6-6-1">
<ul class="org-ul">
<li>Decorator 可看做一个对象的 <b>外壳</b> 。</li>
<li><p>
Strategy 则是改变对象的内核。
</p>
<p class="verse">
当 Component 基类很 <b>庞大</b> 时，使用 Decorator 代价太高，Strategy 模式更好一些。<br />
比如，绘制边框的职责，既可以使用 Decorator 模式包一层外壳，<br />
也可以使用 Border 对象专门负责，再组合进 Context。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org80942c1" class="outline-4">
<h4 id="org80942c1"><span class="section-number-4">6.6.2</span> Composite 模式</h4>
<div class="outline-text-4" id="text-6-6-2">
<p class="verse">
可以将装饰视为一个退化的、仅有一个组件的组合。<br />
另外，它的目的在于添加职责，而 Composite 目的在于对象聚合。<br />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgb8d5da4" class="outline-2">
<h2 id="orgb8d5da4"><span class="section-number-2">7</span> 单件模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-7">
<p>
<a id="orge93c547"></a>
</p>
</div>
<div id="outline-container-orged883be" class="outline-3">
<h3 id="orged883be"><span class="section-number-3">7.1</span> 概述</h3>
<div class="outline-text-3" id="text-7-1">
<p>
保证类仅有一个实例，并提供该实例的全局访问点。
</p>
</div>
</div>
<div id="outline-container-orgb238487" class="outline-3">
<h3 id="orgb238487"><span class="section-number-3">7.2</span> 适用性</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>当类只能有一个实例</li>
<li>当这个唯一实例需要通过子类化扩展</li>
</ul>
</div>
</div>
<div id="outline-container-orge49519d" class="outline-3">
<h3 id="orge49519d"><span class="section-number-3">7.3</span> 结构</h3>
<div class="outline-text-3" id="text-7-3">

<div class="figure">
<p><img src="../resources/OO/Singleton.png" alt="Singleton.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf5653eb" class="outline-3">
<h3 id="orgf5653eb"><span class="section-number-3">7.4</span> 优点</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li><b>受控访问</b></li>
<li><p>
起到命名空间的作用
</p>
<p class="verse">
对全局变量的一种改进，全局变量会污染名空间(容易重名)。<br />
支持静态类的语言，使用静态类解决该问题更简单。<br />
</p></li>
</ul>


<ul class="org-ul">
<li>可以被 <b>继承</b> 扩展。</li>
<li><p>
可扩展单例为 <b>多个实例</b>
</p>

<p>
允许 Singleton 类可以管理多个实例（池类技术）。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orge687ae7" class="outline-3">
<h3 id="orge687ae7"><span class="section-number-3">7.5</span> 实现</h3>
<div class="outline-text-3" id="text-7-5">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Singleton</span>
<span style="color: #AE81FF;">{</span>
<span style="color: #F92672;">public</span>:
    <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">Singleton</span>* <span style="color: #A6E22E;">GetInstance</span><span style="color: #66D9EF;">()</span>;
<span style="color: #F92672;">protected</span>:
    <span style="color: #A6E22E;">Singleton</span><span style="color: #66D9EF;">()</span> : _instance<span style="color: #66D9EF;">(</span><span style="color: #AE81FF;">NULL</span><span style="color: #66D9EF;">)</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#38544;&#34255;&#30340;&#26500;&#36896;&#20989;&#25968;</span>
<span style="color: #F92672;">private</span>:
    <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">Singleton</span>* <span style="color: #FD971F;">_instance</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #66D9EF;">Singleton</span>* <span style="color: #AE81FF;">Singleton</span>::<span style="color: #A6E22E;">GetInstance</span> <span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>_instance == <span style="color: #AE81FF;">NULL</span><span style="color: #66D9EF;">)</span> _instance = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Singleton</span>;
    <span style="color: #F92672;">return</span> _instance;
<span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
<div id="outline-container-org751980d" class="outline-4">
<h4 id="org751980d"><span class="section-number-4">7.5.1</span> 同步问题</h4>
<div class="outline-text-4" id="text-7-5-1">
<p class="verse">
为了保证在多线程环境下只创建一个实例，需要对 GetInstance 方法做同步处理。<br />
<br />
简单的方法：直接将 GetInstance 方法声明为 synchronized。<br />
<br />
这样的做法有个问题：<br />
我们需要同步的只是 GetInstance 内部负责创建实例的区块，<br />
对整个函数进行同步，如果函数体内内容较多且外部调用很频繁，<br />
开销会很大。<br />
<br />
应该只同步创建实例的区块(java 示例)：<br />
</p>
<div class="org-src-container">
<pre class="src src-java"><span style="color: #F92672;">public</span> <span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Singleton</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">private</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">Singleton</span> <span style="color: #FD971F;">uniqueInstance</span>;
    <span style="color: #F92672;">private</span> <span style="color: #A6E22E;">Singleton</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{}</span>
    <span style="color: #F92672;">public</span> <span style="color: #F92672;">static</span> <span style="color: #66D9EF;">Singleton</span> <span style="color: #A6E22E;">GetInstance</span><span style="color: #66D9EF;">()</span> <span style="color: #66D9EF;">{</span>
        <span style="color: #F92672;">if</span> <span style="color: #A6E22E;">(</span>uniqueInstance == <span style="color: #AE81FF;">null</span><span style="color: #A6E22E;">)</span> <span style="color: #A6E22E;">{</span> <span style="color: #75715E;">//</span><span style="color: #75715E;">&#21028;&#26029;&#26159;&#21542;&#35201;&#36827;&#20837;&#36127;&#36131;&#21019;&#24314;&#23454;&#20363;&#30340;&#21516;&#27493;&#27169;&#22359;</span>
            <span style="color: #F92672;">synchronized</span> <span style="color: #E6DB74;">(</span>Singleton.<span style="color: #F92672;">class</span><span style="color: #E6DB74;">)</span> <span style="color: #E6DB74;">{</span><span style="color: #75715E;">//</span><span style="color: #75715E;">&#20165;&#19968;&#20010;&#32447;&#31243;&#25191;&#34892;&#27492;&#21306;&#22359;&#65292;&#30830;&#20445;&#21482;&#21019;&#24314;&#19968;&#20010;&#23454;&#20363;&#12290;</span>
                <span style="color: #F92672;">if</span> <span style="color: #FD971F;">(</span>uniqueInstance == <span style="color: #AE81FF;">null</span><span style="color: #FD971F;">)</span> <span style="color: #FD971F;">{</span>
                    uniqueInstance = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">Singleton</span><span style="color: #F92672;">()</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#23545;&#20110;&#21516;&#27493;&#25968;&#25454;&#65292;&#24403;&#20320;&#30340;&#20889;&#20837;&#20381;&#36182;&#20110;&#35835;&#21462;&#30340;&#20869;&#23481;&#30340;&#26102;&#20505;&#65292;&#35201;&#23567;&#24515;&#12290;</span>
                <span style="color: #FD971F;">}</span>
            <span style="color: #E6DB74;">}</span>
        <span style="color: #A6E22E;">}</span>
        <span style="color: #F92672;">return</span> uniqueInstance;
    <span style="color: #66D9EF;">}</span>
<span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-org5671721" class="outline-4">
<h4 id="org5671721"><span class="section-number-4">7.5.2</span> 继承问题</h4>
<div class="outline-text-4" id="text-7-5-2">
<p>
问题：子类的单件实例化在何处实现？
</p>

<ul class="org-ul">
<li><p>
在父类的 GetInstance 中决定使用哪一个单件子类。
</p>
<p class="verse">
可以传入参数，使用条件语句在运行时期选择适合的子类。<br />
局限在于硬性限定了可能的 Singleton 子类的集合。<br />
优点：支持多态，运行时指定子类。<br />
</p></li>

<li><p>
将 GetInstance 类从父类中剥出，并将它放入子类。
</p>
<p class="verse">
客户代码通过类名调用 GetInstance 自行决定使用哪个子类。<br />
编译时决定使用哪个子类，非运行时，不够灵活。<br />
</p></li>

<li><p>
使用设定文件(或注册表等)记录单件类。
</p>

<p>
GetInstance()读取相关配置项，通过映射表找到相对应的单件类。
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4808415" class="outline-3">
<h3 id="org4808415"><span class="section-number-3">7.6</span> 与静态类比较</h3>
<div class="outline-text-3" id="text-7-6">
</div><div id="outline-container-org01473e3" class="outline-4">
<h4 id="org01473e3"><span class="section-number-4">7.6.1</span> 概念上的理解</h4>
<div class="outline-text-4" id="text-7-6-1">
<p>
静态类是单件模式的一种特殊实现方式。
</p>
<ul class="org-ul">
<li>静态类更多的用于与特定实例无关的 <b>全局</b> 属性和 <b>全局</b> 方法的分类(起到命名空间的作用)。</li>
<li>而单件的概念是确实需要一个实例，而且实例只能有一个。比如：注册表对象，线程池对象。</li>
</ul>
</div>
</div>

<div id="outline-container-org4b8f1a8" class="outline-4">
<h4 id="org4b8f1a8"><span class="section-number-4">7.6.2</span> 创建的时间</h4>
<div class="outline-text-4" id="text-7-6-2">
<ul class="org-ul">
<li>静态类在编译时创建</li>
<li>单件模式的类在运行时创建(创建的时机在一定程度上可选)</li>
</ul>
</div>
</div>

<div id="outline-container-orge3b7c89" class="outline-4">
<h4 id="orge3b7c89"><span class="section-number-4">7.6.3</span> 扩展性</h4>
<div class="outline-text-4" id="text-7-6-3">
<ul class="org-ul">
<li>静态类不能被继承，也无法继承其他类。(如果该类需要实现一些接口，则不能使用静态类)</li>
<li>单件类可以被继承扩展</li>
<li>如需要从一个实例变为多个实例，静态类做不到。单件类可以扩展满足要求 <b>更灵活</b></li>
</ul>
</div>
</div>

<div id="outline-container-org82861c7" class="outline-4">
<h4 id="org82861c7"><span class="section-number-4">7.6.4</span> 总结</h4>
<div class="outline-text-4" id="text-7-6-4">
<ul class="org-ul">
<li>静态类更多地用于对全局方法、全局变量的分类组织。</li>
<li>单件模式表示有且仅有一个对象。单件类可以被继承，易于扩展。</li>
</ul>

<p class="verse">
当对于是否使用单件模式没把握的时候，使用单件类更好一些。<br />
原因：静态类改成实例类，会改变接口，从而影响所有的客户代码。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfa16a93" class="outline-3">
<h3 id="orgfa16a93"><span class="section-number-3">7.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-7-7">
<p>
经常使用 Singleton 模式的其他模式：
</p>
<ul class="org-ul">
<li><a href="#orgd8efc7b">Abstract Factory</a></li>
<li><a href="#org03758c8">Builder</a></li>
<li>Prototype</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgacd7281" class="outline-2">
<h2 id="orgacd7281"><span class="section-number-2">8</span> 工厂模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-8">
<p>
<a id="org6487612"></a>
</p>
</div>
<div id="outline-container-org8cc4610" class="outline-3">
<h3 id="org8cc4610"><span class="section-number-3">8.1</span> 简单工厂方法</h3>
<div class="outline-text-3" id="text-8-1">
<p>
<a id="orgaf6f7c0"></a>
</p>
</div>
<div id="outline-container-org7d36485" class="outline-4">
<h4 id="org7d36485"><span class="section-number-4">8.1.1</span> 结构</h4>
<div class="outline-text-4" id="text-8-1-1">

<div class="figure">
<p><img src="../resources/OO/SimpleFactory.png" alt="SimpleFactory.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-org7614421" class="outline-3">
<h3 id="org7614421"><span class="section-number-3">8.2</span> 工厂方法</h3>
<div class="outline-text-3" id="text-8-2">
<p>
<a id="org818f1db"></a>
</p>
</div>
<div id="outline-container-org74b954e" class="outline-4">
<h4 id="org74b954e"><span class="section-number-4">8.2.1</span> 概述</h4>
<div class="outline-text-4" id="text-8-2-1">
<p>
定义一个用于创建对象的接口，让子类决定实例化哪个产品。
</p>
</div>
</div>

<div id="outline-container-org6be391d" class="outline-4">
<h4 id="org6be391d"><span class="section-number-4">8.2.2</span> 结构</h4>
<div class="outline-text-4" id="text-8-2-2">

<div class="figure">
<p><img src="../resources/OO/FactoryMethod.png" alt="FactoryMethod.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org3bc7ddb" class="outline-4">
<h4 id="org3bc7ddb"><span class="section-number-4">8.2.3</span> 实现</h4>
<div class="outline-text-4" id="text-8-2-3">
<ul class="org-ul">
<li><p>
避免子类化
</p>
<p class="verse">
工厂方法一个潜在的问题是它们可能仅为了创建适当的 Product 对象<br />
而迫使你创建 Creator 子类，C++中可以提供使用模板避免子类化。<br />
</p>
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Creator</span>
<span style="color: #AE81FF;">{</span>
<span style="color: #F92672;">public</span>:
    <span style="color: #F92672;">virtual</span> <span style="color: #66D9EF;">Product</span>* <span style="color: #A6E22E;">Create</span><span style="color: #66D9EF;">()</span> = <span style="color: #AE81FF;">0</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">template</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #F92672;">class</span> <span style="color: #66D9EF;">StandardCreator</span> : <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">Creator</span>
<span style="color: #AE81FF;">{</span>
<span style="color: #F92672;">public</span>:
    <span style="color: #F92672;">virtual</span> <span style="color: #66D9EF;">Product</span>* <span style="color: #A6E22E;">Create</span><span style="color: #66D9EF;">()</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">template</span> <span style="color: #AE81FF;">&lt;</span><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">&gt;</span>
<span style="color: #66D9EF;">Product</span>* <span style="color: #AE81FF;">StandardCreator</span><span style="color: #AE81FF;">&lt;</span><span style="color: #66D9EF;">T</span><span style="color: #AE81FF;">&gt;</span>::<span style="color: #A6E22E;">Create</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">T</span>;
<span style="color: #AE81FF;">}</span>
</pre>
</div></li>
</ul>
</div>
</div>

<div id="outline-container-org02277dd" class="outline-4">
<h4 id="org02277dd"><span class="section-number-4">8.2.4</span> 相关模式</h4>
<div class="outline-text-4" id="text-8-2-4">
<ul class="org-ul">
<li>Abstract Factory 经常使用工厂方法来实现。</li>
<li><p>
工厂方法通常在 Template Method 中被调用。
</p>

<p>
模板方法指定一系列的具体步骤，而创建对象的一步委托给工厂方法。
</p></li>

<li><p>
Prototype 不需要创建 Creator 的子类。
</p>

<p>
但会要求一个针对 Product 类的 Initialize 操作。Creator 使用 Initialize 来初始化对象。
</p></li>

<li><p>
与简单工厂方法的比较
</p>
<p class="verse">
简单工厂在 SimpleFactory 的 create 方法中，使用类似 Switch 语句来根据参数制造产品。<br />
缺点在于，switch 不容易扩展，并且 SimpleFactory 需要知道所有的产品类，耦合紧密。<br />
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4996c94" class="outline-3">
<h3 id="org4996c94"><span class="section-number-3">8.3</span> 抽象工厂</h3>
<div class="outline-text-3" id="text-8-3">
<p>
<a id="orgd8efc7b"></a>
</p>
</div>
<div id="outline-container-orga6dc5aa" class="outline-4">
<h4 id="orga6dc5aa"><span class="section-number-4">8.3.1</span> 概述</h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
提供创建一系列产品族的接口，而无需指定各产品的具体类。
</p>
</div>
</div>

<div id="outline-container-org730d232" class="outline-4">
<h4 id="org730d232"><span class="section-number-4">8.3.2</span> 角色</h4>
<div class="outline-text-4" id="text-8-3-2">
<ul class="org-ul">
<li><p>
ConcreteFactory
</p>

<p>
负责创建各产品对象，每一个具体工厂类都代表一种产品之间的组合。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org2637ca8" class="outline-4">
<h4 id="org2637ca8"><span class="section-number-4">8.3.3</span> 结构</h4>
<div class="outline-text-4" id="text-8-3-3">

<div class="figure">
<p><img src="../resources/OO/AbstractFactory.png" alt="AbstractFactory.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgbffe837" class="outline-4">
<h4 id="orgbffe837"><span class="section-number-4">8.3.4</span> 优点</h4>
<div class="outline-text-4" id="text-8-3-4">
<ul class="org-ul">
<li><p>
<b>使得易于交换产品系列</b>
</p>

<p>
通过替换具体的工厂类，来改变产品系列。
</p></li>

<li><p>
<b>有利于产品的一致性</b>
</p>

<p>
当一系列产品被设计成一起工作时，抽象工厂可以保证一个应用一次只能使用同一系列的对象。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org48e5349" class="outline-4">
<h4 id="org48e5349"><span class="section-number-4">8.3.5</span> 缺点</h4>
<div class="outline-text-4" id="text-8-3-5">
<ul class="org-ul">
<li><p>
<b>难以支持新种类的产品</b>
</p>
<p class="verse">
AbstractFactory 接口定义了可以被创建的产品集合。支持新的产品种类，<br />
就需要扩展接口，还涉及到所有子类的改变。<a href="#orge09338d">解决办法</a><br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org973008c" class="outline-4">
<h4 id="org973008c"><span class="section-number-4">8.3.6</span> 实现</h4>
<div class="outline-text-4" id="text-8-3-6">
<ul class="org-ul">
<li><p>
将具体工厂作为单件
</p>

<p>
一般每个产品系列只需一个 ConcreteFactory 的实例。
</p></li>

<li><p>
创建产品。
</p>
<p class="verse">
AbstractFactory 只声明创建产品的接口。<br />
如果有多个可能的产品系列，具体工厂也可以使用 Prototype 模式来实现。<br />
具体工厂使用产品系列中每一个产品的原型实例来初始化，<br />
且它通过复制它的原型来创建新的产品。<br />
<br />
基于原型的好处：不是每个新的产品系列都需要一个新的具体工厂类。<br />
</p></li>
</ul>

<p>
<a id="orge09338d"></a>
</p>
<ul class="org-ul">
<li><p>
定义可扩展的工厂
</p>
<p class="verse">
加入新产品需要扩展接口，影响子类。<br />
一个更灵活但不太安全的设计是给创建对象的操作增加一个参数。<br />
AbstractFactory 只提供一个 Create 操作，用参数指定要创建的产品。<br />
由于产品种类各不相同，此方法只适用于动态类型语言。<br />
<br />
当所有对象都有相同的基类，且产品对象可以安全的强转成正确的<br />
类型时。才能在 C++这样的静态类型语言中使用。<br />
<br />
此方法有个本质的问题，因为返回的都是 Object 基类，客户无法区分<br />
或对一个产品类别进行安全的假定。需要 dynamic_cast 去转换，这种<br />
自上向下类型的转换并不总是安全的。<br />
<br />
总结：这是一个典型的高度灵活和更高安全性的权衡问题。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgf6647aa" class="outline-4">
<h4 id="orgf6647aa"><span class="section-number-4">8.3.7</span> 相关模式</h4>
<div class="outline-text-4" id="text-8-3-7">
<ul class="org-ul">
<li>Abstract Factory 通常用<a href="#org818f1db">工厂方法</a>实现，也可用 Prototype 实现。</li>
<li>一个具体的工厂通常是一个<a href="#orge93c547">单件</a>。</li>
</ul>
</div>
</div>
</div>
</div>

<div id="outline-container-org5c17382" class="outline-2">
<h2 id="org5c17382"><span class="section-number-2">9</span> 命令模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">行为型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-9">
<p>
<a id="orgd4bb589"></a>
</p>
</div>
<div id="outline-container-orgf8835a4" class="outline-3">
<h3 id="orgf8835a4"><span class="section-number-3">9.1</span> 概述</h3>
<div class="outline-text-3" id="text-9-1">
<p class="verse">
将请求封装成对象，实现统一的 Execute()接口，从而可以使用不同的请求<br />
实例对其他对象进行参数化。<br />
<br />
典型的例子：<br />
Button 控件，对控件设计者来说，只知道 Button 按下应该会发生<br />
些什么，但具体会发生什么一无所知。只能由使用者来决定。<br />
</p>
</div>
</div>

<div id="outline-container-org9bb32fb" class="outline-3">
<h3 id="org9bb32fb"><span class="section-number-3">9.2</span> 适用性</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li><b>回调机制</b> 的一个面向对象的替代品</li>

<li>支持对请求排队</li>

<li><p>
支持撤销操作
</p>
<p class="verse">
Excute()在实施操作前记录状态，Undo()利用该记录状态取消之前执行的操作。<br />
将执行完的命令对象加入一个历史列表，可通过 <b>向前/向后遍历</b> 实现<br />
一系列的 <b>Undo/Redo</b> 。<br />
</p></li>

<li><p>
命令对象支持 <b>持久化</b>
</p>
<p class="verse">
方法：添加 Store()和 Load()接口<br />
在执行一些列命令前，调用 Store()对命令对象进行序列化和持久化操作。<br />
一旦系统崩溃，可以使用 Load()复原命令对象，并重新执行。<br />
</p></li>

<li>支持事务处理</li>
</ul>
</div>
</div>

<div id="outline-container-orgce23fbe" class="outline-3">
<h3 id="orgce23fbe"><span class="section-number-3">9.3</span> 结构</h3>
<div class="outline-text-3" id="text-9-3">

<div class="figure">
<p><img src="../resources/OO/Command.png" alt="Command.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfe191e6" class="outline-3">
<h3 id="orgfe191e6"><span class="section-number-3">9.4</span> 角色</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li><p>
Client
</p>
<p class="verse">
负责创建具体命令对象并指定它的接收者。<br />
存储命令对象到某个媒介。<br />
</p></li>

<li>Invoker 从存储媒介中获取命令对象，并执行。</li>
</ul>
</div>
</div>

<div id="outline-container-org1f9d4cd" class="outline-3">
<h3 id="org1f9d4cd"><span class="section-number-3">9.5</span> 优点</h3>
<div class="outline-text-3" id="text-9-5">
<ol class="org-ol">
<li>增加新的 Command 很容易。</li>
<li>将调用命令的对象与知道如何实现该命令相关操作的对象解耦。</li>
<li>Command 对象和其他对象一样支持扩展。</li>
<li>支持 MacroCommand。复合命令是 Composite 模式的一个实例。</li>
</ol>
</div>
</div>

<div id="outline-container-orgf51a93f" class="outline-3">
<h3 id="orgf51a93f"><span class="section-number-3">9.6</span> 实现</h3>
<div class="outline-text-3" id="text-9-6">
<ul class="org-ul">
<li>一个命令对象职责可大可小。
<ul class="org-ul">
<li>最小职责仅确定一个接收者和执行该请求的动作</li>
<li>职责也可以大到负责处理所有的功能，不需要接收者，直接包含具体动作。(当没有合适的接收者时使用)</li>
</ul></li>
<li><p>
实现 undo 和 redo
</p>

<p>
ConcreteCommand 类需要存储额外的状态信息，包括：
</p>

<ul class="org-ul">
<li>接收者对象</li>
<li>接收者接口执行操作的参数</li>
<li>接收者的状态值</li>
</ul></li>

<li><p>
使用 C++模板
</p>
<p class="verse">
好处：避免每一个动作和接收者都创建一个 Command 子类。<br />
问题：1) 不支持撤销操作 2) 无法向接收者的执行接口传入参数<br />
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgd82abe9" class="outline-3">
<h3 id="orgd82abe9"><span class="section-number-3">9.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-9-7">
<ul class="org-ul">
<li>Composite 可被用来实现宏命令。</li>
<li>Memento 模式可用来保持一个状态，命令对象用该状态来取消之前执行效果。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org95a1d64" class="outline-2">
<h2 id="org95a1d64"><span class="section-number-2">10</span> 适配器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="_">类</span>&#xa0;<span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-10">
<p>
<a id="org0bdb06f"></a>
</p>
</div>
<div id="outline-container-orge6f9b5a" class="outline-3">
<h3 id="orge6f9b5a"><span class="section-number-3">10.1</span> 概述</h3>
<div class="outline-text-3" id="text-10-1">
<p class="verse">
将一个或多个类的接口转换成用户希望的接口。别名 Wrapper。<br />
现有类的接口与用户希望的接口通常是固定的，无法改变。<br />
</p>
</div>
</div>

<div id="outline-container-org01016e3" class="outline-3">
<h3 id="org01016e3"><span class="section-number-3">10.2</span> 结构</h3>
<div class="outline-text-3" id="text-10-2">
</div><div id="outline-container-org08a84bb" class="outline-4">
<h4 id="org08a84bb"><span class="section-number-4">10.2.1</span> 类适配器</h4>
<div class="outline-text-4" id="text-10-2-1">

<div class="figure">
<p><img src="../resources/OO/ClassAdapter.png" alt="ClassAdapter.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org76939dc" class="outline-4">
<h4 id="org76939dc"><span class="section-number-4">10.2.2</span> 对象适配器</h4>
<div class="outline-text-4" id="text-10-2-2">
<p>
将 Adapter 与 Adaptee 之间的继承关系变为了组合。
</p>

<div class="figure">
<p><img src="../resources/OO/InstanceAdapter.png" alt="InstanceAdapter.png" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orga856d0b" class="outline-3">
<h3 id="orga856d0b"><span class="section-number-3">10.3</span> 角色</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>Target
定义了满足用户需要的接口</li>
</ul>
</div>
</div>

<div id="outline-container-org1de001d" class="outline-3">
<h3 id="org1de001d"><span class="section-number-3">10.4</span> 实现细节</h3>
<div class="outline-text-3" id="text-10-4">
</div><div id="outline-container-orgd43dfb7" class="outline-4">
<h4 id="orgd43dfb7"><span class="section-number-4">10.4.1</span> 类适配器还是对象适配器？</h4>
<div class="outline-text-4" id="text-10-4-1">
<ul class="org-ul">
<li><p>
重定义 Adaptee 的行为
</p>
<p class="verse">
类适配器可以方便地重定义 Adaptee 的部分行为。<br />
对象适配器可能需要通过<a href="#orgab8f698">6</a>模式先拓展 Adaptee。<br />
</p></li>

<li><p>
适配多个 Adaptee？
</p>
<p class="verse">
类适配器只能适配一个 Adaptee。<br />
对象适配器支持多个。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgd628639" class="outline-4">
<h4 id="orgd628639"><span class="section-number-4">10.4.2</span> 双向适配器增加透明性</h4>
<div class="outline-text-4" id="text-10-4-2">
<p class="verse">
适配器因为改变了接口，Adapter 对象与 Adaptee 对象不兼容(提示：<a href="#orgab8f698">6</a>兼容)。<br />
原本使用 Adaptee 对象的用户就无法使用 Adapter 对象。<br />
可使用双向适配器，在实现 Target 的同时，保留原本 Adaptee 的接口。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org46fa2f1" class="outline-3">
<h3 id="org46fa2f1"><span class="section-number-3">10.5</span> 相关模式</h3>
<div class="outline-text-3" id="text-10-5">
<ul class="org-ul">
<li><a href="#orgf07c8a1">Bridge</a>模式的结构与其有些相似，但意图不同。Bridge 的目的是将接口部分与实现部分分离。</li>
<li><a href="#orgab8f698">Decorator</a>模式为类增加职责，不改变 <b>原先</b> 的接口。</li>
<li>透明性比<a href="#org0bdb06f">Adapter</a>好，并支持递归组合。</li>
<li><a href="#orge14cf55">Proxy</a>模式在不改变其接口的条件下，为另一个对象定义了一个代理。</li>
<li><a href="#orgf8e04b6">Facade</a>模式将一个或多个不同对象的复杂接口进行简化。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0938dbf" class="outline-2">
<h2 id="org0938dbf"><span class="section-number-2">11</span> 代理模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-11">
<p>
<a id="orge14cf55"></a>
</p>
</div>
<div id="outline-container-orgaf44d07" class="outline-3">
<h3 id="orgaf44d07"><span class="section-number-3">11.1</span> 概述</h3>
<div class="outline-text-3" id="text-11-1">
<p>
控制和管理访问
</p>
</div>
</div>
<div id="outline-container-org68794dd" class="outline-3">
<h3 id="org68794dd"><span class="section-number-3">11.2</span> 适用性</h3>
<div class="outline-text-3" id="text-11-2">
<ol class="org-ol">
<li><b>远程代理</b> 代理类隐藏网络层的实现，本地调用代理类就如同调用本地对象一样。</li>
<li><b>虚代理</b> 创建开销很大的对象时使用。代理类隐藏创建的细节。</li>
<li><b>保护代理</b> 用于权限控制。</li>
<li><b>智能指针</b></li>
</ol>
</div>
</div>
<div id="outline-container-org9c4826c" class="outline-3">
<h3 id="org9c4826c"><span class="section-number-3">11.3</span> 结构</h3>
<div class="outline-text-3" id="text-11-3">

<div class="figure">
<p><img src="../resources/OO/Proxy.png" alt="Proxy.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfbcb5dd" class="outline-3">
<h3 id="orgfbcb5dd"><span class="section-number-3">11.4</span> 角色</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li><p>
Proxy
</p>

<p>
控制对实体的存取，并可能负责创建和删除实体。
</p></li>

<li><p>
Subject
</p>

<p>
定义 RealSubject 与 Proxy 的共用接口。
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgfe41fda" class="outline-3">
<h3 id="orgfe41fda"><span class="section-number-3">11.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-11-5">
</div><div id="outline-container-org256cb9e" class="outline-4">
<h4 id="org256cb9e"><span class="section-number-4">11.5.1</span> C++通过重载-&gt;,*运算符实现</h4>
<div class="outline-text-4" id="text-11-5-1">
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #66D9EF;">Image</span>* <span style="color: #AE81FF;">ImageProxy</span>::<span style="color: #F92672;">operator</span><span style="color: #A6E22E;">-&gt;</span> <span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> LoadImage<span style="color: #66D9EF;">()</span>;
<span style="color: #AE81FF;">}</span>
<span style="color: #66D9EF;">Image</span>&amp; <span style="color: #AE81FF;">ImageProxy</span>::<span style="color: #F92672;">operator</span><span style="color: #A6E22E;">*</span> <span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #F92672;">return</span> *LoadImage<span style="color: #66D9EF;">()</span>;
<span style="color: #AE81FF;">}</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">ImageProxy</span> <span style="color: #FD971F;">imageptr</span>;
    imageptr-&gt;Draw<span style="color: #66D9EF;">()</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#27492;&#22788;&#23454;&#38469;&#35843;&#29992;&#30340;&#26159; Image &#30340;&#26041;&#27861;</span>
    <span style="color: #66D9EF;">(</span>*image<span style="color: #66D9EF;">)</span>.Draw<span style="color: #66D9EF;">()</span>;
    <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">0</span>;
<span style="color: #AE81FF;">}</span>

</pre>
</div>
</div>
</div>
<div id="outline-container-org09f4b42" class="outline-4">
<h4 id="org09f4b42"><span class="section-number-4">11.5.2</span> 远程代理</h4>
<div class="outline-text-4" id="text-11-5-2">
<p class="verse">
远程代理不一定都是通过网络调用的，不同地址空间的对象访问也是远程代理。<br />
远程代理一般需要将对象、调用信息序列化，通过 Socket 等协议，通知远程的<br />
服务，然后有远程提供服务的程序，调用实体对象。<br />
<br />
Java 中有成套的解决方案，叫做 RMI。<br />
</p>
</div>
</div>
<div id="outline-container-orgb586e04" class="outline-4">
<h4 id="orgb586e04"><span class="section-number-4">11.5.3</span> 智能指针</h4>
<div class="outline-text-4" id="text-11-5-3">
<ul class="org-ul">
<li>对指向实际对象的引用计数，引用计数为 0 时，自动释放。</li>
<li>第一次引用时，装入内存。</li>
<li>访问实际对象前，检查被锁定。</li>
</ul>

<p>
标准库的例子：
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #F92672;">#include</span> <span style="color: #E6DB74;">&lt;memory&gt;</span>
<span style="color: #F92672;">using</span> <span style="color: #F92672;">namespace</span> <span style="color: #AE81FF;">std</span>;
<span style="color: #F92672;">class</span> <span style="color: #66D9EF;">A</span> <span style="color: #AE81FF;">{}</span>;
<span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">f</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #66D9EF;">auto_ptr</span><span style="color: #66D9EF;">&lt;</span><span style="color: #66D9EF;">A</span><span style="color: #66D9EF;">&gt;</span> <span style="color: #FD971F;">ptr</span><span style="color: #66D9EF;">(</span><span style="color: #F92672;">new</span> <span style="color: #66D9EF;">A</span><span style="color: #66D9EF;">)</span>;<span style="color: #75715E;">//</span><span style="color: #75715E;">&#26632;&#21306;&#23545;&#35937;&#65292;&#20986;&#26632;&#26102;&#37322;&#25918;&#25351;&#38024;&#65292;&#36991;&#20813;&#22810;&#20010;&#20989;&#25968;&#20986;&#21475;&#37117;&#20889;&#37322;&#25918;&#35821;&#21477;</span>
    <span style="color: #F92672;">try</span>
    <span style="color: #66D9EF;">{</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">delete a;</span>
        <span style="color: #F92672;">return</span>;
    <span style="color: #66D9EF;">}</span>
    <span style="color: #F92672;">catch</span> <span style="color: #66D9EF;">(</span>...<span style="color: #66D9EF;">)</span>
    <span style="color: #66D9EF;">{</span>
        <span style="color: #75715E;">//</span><span style="color: #75715E;">delete a;</span>
    <span style="color: #66D9EF;">}</span>
    <span style="color: #75715E;">//</span><span style="color: #75715E;">delete a;</span>
<span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org496ec92" class="outline-4">
<h4 id="org496ec92"><span class="section-number-4">11.5.4</span> 虚代理</h4>
<div class="outline-text-4" id="text-11-5-4">
<p class="verse">
对于一些开销很大的对象，可能在实际真正用到的时候，才创建对象。<br />
例如：ImageProxy 构造中什么都不做，而在 Draw 的接口中，才真正创建 Image 对象。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org05bf9e0" class="outline-3">
<h3 id="org05bf9e0"><span class="section-number-3">11.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-11-6">
<ul class="org-ul">
<li><p>
<a href="#org0bdb06f">Adapter</a>模式：
</p>

<p>
主要用于转换接口；而代理模式一般情况下不改变接口，意图不一样。
</p></li>

<li><p>
<a href="#orgab8f698">Decorator</a>模式：两者结构类似，但意图不同。
</p>
<p class="verse">
装饰者模式支持多层装饰；而代理通常只会添加一层访问控制。<br />
代理模式通常与实际对象接口保持一致。装饰者通常需要增加接口以达到扩展功能的目的。<br />
</p></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4d5b0f6" class="outline-2">
<h2 id="org4d5b0f6"><span class="section-number-2">12</span> 外观模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-12">
<p>
<a id="orgf8e04b6"></a>
</p>
</div>
<div id="outline-container-orgbc81dd6" class="outline-3">
<h3 id="orgbc81dd6"><span class="section-number-3">12.1</span> 概述</h3>
<div class="outline-text-3" id="text-12-1">
<p>
为子系统中的一组接口进行简化，提供一组高级接口，使得子系统更加容易使用。
</p>
</div>
</div>
<div id="outline-container-org1374296" class="outline-3">
<h3 id="org1374296"><span class="section-number-3">12.2</span> 适用性</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li>为复杂子系统提供一个简单接口，对大部分用户来说足够用，必要时用户一样可以绕过该接口。</li>
<li>使客户程序从子系统的各层次实现的细节中解脱出来。</li>
<li>多层次结构，可以使用 Facade 模式定义每一层的抽象操作。可以让各层次之间通过 facade 进行通信，简化了各层次之间的依赖关系。</li>
</ul>
</div>
</div>
<div id="outline-container-org2ae6a00" class="outline-3">
<h3 id="org2ae6a00"><span class="section-number-3">12.3</span> 结构</h3>
<div class="outline-text-3" id="text-12-3">

<div class="figure">
<p><img src="../resources/OO/Facade.png" alt="Facade.png" />
</p>
</div>
</div>
</div>
<div id="outline-container-org89a8f33" class="outline-3">
<h3 id="org89a8f33"><span class="section-number-3">12.4</span> 优点</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>实现了用户与子系统之间的 <b>松耦合</b> 关系</li>
<li>对用户屏蔽子系统结构，更易用</li>
</ul>
</div>
</div>
<div id="outline-container-orgedd88e1" class="outline-3">
<h3 id="orgedd88e1"><span class="section-number-3">12.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li>使用抽象类实现 Facade 可以进一步降低客户与子系统的耦合度。</li>
<li>C++使用 Namespace 可以私有化子系统中的类。</li>
</ul>
</div>
</div>
<div id="outline-container-org1bc9cf4" class="outline-3">
<h3 id="org1bc9cf4"><span class="section-number-3">12.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-12-6">
<ul class="org-ul">
<li><a href="#orgd8efc7b">Abstract Factory</a>模式可与 Facade 模式一起使用以提供一个单独的创建产品簇的接口。</li>
<li>Mediator 模式与 Facade 模式的相似之处：都抽象了一些已有的类的功能。但 Mediator 的目的是对同级之间的任意通讯进行抽象。</li>
<li>通常来说仅需要一个 Facade 对象，所以 Facade 类定义成 Singleton 类。</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgaaa33aa" class="outline-2">
<h2 id="orgaaa33aa"><span class="section-number-2">13</span> 迭代器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-13">
<p>
<a id="org7b06bdc"></a>
</p>
</div>
<div id="outline-container-orgb861b85" class="outline-3">
<h3 id="orgb861b85"><span class="section-number-3">13.1</span> 概述</h3>
<div class="outline-text-3" id="text-13-1">
<p>
提供遍历集合对象中各元素的方法，并且不将集合具体的数据结构暴露给用户。
</p>
</div>
</div>
<div id="outline-container-orgeac2683" class="outline-3">
<h3 id="orgeac2683"><span class="section-number-3">13.2</span> 适用性</h3>
<div class="outline-text-3" id="text-13-2">
<ul class="org-ul">
<li>遍历访问集合对象的内容，无需暴露它的内部结构。</li>
<li>支持对同一集合对象的多种遍历方式。</li>
<li>为遍历不同数据结构的集合对象提供统一的接口(即支持多态迭代）。</li>
</ul>
</div>
</div>
<div id="outline-container-org01fd938" class="outline-3">
<h3 id="org01fd938"><span class="section-number-3">13.3</span> 结构</h3>
<div class="outline-text-3" id="text-13-3">

<div class="figure">
<p><img src="../resources/OO/Iterator.png" alt="Iterator.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org7238bff" class="outline-3">
<h3 id="org7238bff"><span class="section-number-3">13.4</span> 角色</h3>
<div class="outline-text-3" id="text-13-4">
<ul class="org-ul">
<li><p>
Iterator
</p>

<p>
定义访问和遍历元素的接口
</p></li>

<li>ConcreteIterator

<ul class="org-ul">
<li>实现 Iterator 定义的接口</li>
<li>在遍历集合时，跟踪当前位置</li>
</ul></li>

<li><p>
Aggregate
</p>

<p>
定义创建迭代器对象的接口
</p></li>

<li><p>
ConcreteAggregate
</p>

<p>
实现 Aggregate 定义的接口
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orga8a059e" class="outline-3">
<h3 id="orga8a059e"><span class="section-number-3">13.5</span> 优点</h3>
<div class="outline-text-3" id="text-13-5">
<ul class="org-ul">
<li>支持以不同的方式遍历一个集合，使改变遍历算法变的容易。</li>
<li>迭代器将遍历的职责从集合类中剥离出来。维护起来更容易。</li>
<li>可以同时对一个集合进行多个遍历，只需多个迭代器实例对象。</li>
</ul>
</div>
</div>
<div id="outline-container-org870d540" class="outline-3">
<h3 id="org870d540"><span class="section-number-3">13.6</span> 实现细节</h3>
<div class="outline-text-3" id="text-13-6">
</div><div id="outline-container-org9d4604a" class="outline-4">
<h4 id="org9d4604a"><span class="section-number-4">13.6.1</span> 由谁来控制迭代过程？</h4>
<div class="outline-text-4" id="text-13-6-1">
<p class="verse">
由客户来控制的称为外部迭代器(或称为主动迭代器)。<br />
由迭代器自身来控制的，称为内部迭代器(或称为被动迭代器)。<br />
</p>

<ul class="org-ul">
<li><p>
外部迭代器
</p>

<p>
使用外部迭代器时，客户必须主动推进迭代的步伐。
</p></li>

<li><p>
内部迭代器
</p>
<p class="verse">
使用内部迭代器时，客户只需指定一个操作，迭代器保证对集合<br />
中的每一个元素执行该操作。<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup><br />
如何指定操作？支持匿名函数和闭包的语言很容易实现。<br />
C++中通常有两种方法可以选择<br />
</p>
<ul class="org-ul">
<li>函数指针劣势在于如果需要更新某种状态，则需要使用全局变量。</li>
<li>子类生成需要定义额外的类来达到目的。<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup></li>
</ul></li>

<li><p>
权衡
</p>
<p class="verse">
内部迭代器定义好了迭代逻辑，使用起来更方便；<br />
外部迭代器由于将迭代逻辑交由用户来控制，使用起来更灵活。<br />
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org4588a23" class="outline-4">
<h4 id="org4588a23"><span class="section-number-4">13.6.2</span> 谁定义遍历算法？</h4>
<div class="outline-text-4" id="text-13-6-2">
<ul class="org-ul">
<li><p>
由集合自身定义
</p>
<p class="verse">
由集合自身定义遍历算法。迭代器仅用来指示当前的位置。这种迭代器称为 <b>游标</b> 。<br />
<br />
客户调用 Next()时，需要将游标作为参数传入，Next 操作内部仅改变游标的位置状态。<br />
可改接口为 SetCursor(index)和 int GetCursor()更容易理解。<br />
</p></li>
<li><p>
由迭代器定义
</p>
<p class="verse">
遍历算法还可以由迭代器定义，优势在于，使得在相同的集合上使用不同的迭代算法、<br />
或是在不同的集合上使用相同的迭代算法更简单。<br />
<br />
注意：如果遍历算法会用到集合的私有变量，放在迭代器中，则破坏了集合对象的封装性。<br />
</p></li>
</ul>
</div>
</div>
<div id="outline-container-orgfba5c62" class="outline-4">
<h4 id="orgfba5c62"><span class="section-number-4">13.6.3</span> 线程安全的迭代器</h4>
<div class="outline-text-4" id="text-13-6-3">
<p class="verse">
现实情况下，可能有多个不同线程创建的迭代器引用同一个集合对象。<br />
<br />
解决同步问题的一般做法是：<br />
各迭代器对象需要向集合对象进行注册(可用<a href="#org06be4fc">4</a>模式)，<br />
当改变发生时，集合对象更新每一个迭代器的状态。<br />
</p>
</div>
</div>
<div id="outline-container-orgd1eebc4" class="outline-4">
<h4 id="orgd1eebc4"><span class="section-number-4">13.6.4</span> 关于多态迭代器</h4>
<div class="outline-text-4" id="text-13-6-4">
<ul class="org-ul">
<li><p>
结构图中所展示的是多态迭代器的实现
</p>
<p class="verse">
也可以不需要迭代器抽象基类，这样在 <b>工厂方法 CreateIterator</b> 中<br />
也就不需要动态 new 出迭代器具体类对象。<br />
</p></li>

<li><p>
多态迭代器是有代价的
</p>
<p class="verse">
因为 <b>动态</b> 的分配迭代器对象的本身是有代价的。<br />
一般情况使用分配在栈区上的具体迭代器即可。<br />
</p></li>
<li><p>
多态意味着需要用 new，也就需要用户负责删除它们，这样容易引发错误。
</p>
<p class="verse">
可以使用<a href="#orge14cf55">11</a>模式，在栈区创建一个代理迭代器对象，在代理迭代器析构中<br />
释放具体迭代器对象。不能用工厂是因为工厂只负责对象的创建。<br />
</p>
<div class="org-src-container">
<pre class="src src-c++"><span style="color: #AE81FF;">IteratorProxy</span>::<span style="color: #A6E22E;">IteratorProxy</span><span style="color: #AE81FF;">(</span><span style="color: #66D9EF;">Type</span> <span style="color: #FD971F;">type</span><span style="color: #AE81FF;">)</span>
<span style="color: #AE81FF;">{</span>
  <span style="color: #F92672;">if</span> <span style="color: #66D9EF;">(</span>type == Type.Reverse<span style="color: #66D9EF;">)</span> <span style="color: #66D9EF;">Iterator</span>* <span style="color: #FD971F;">m_iter</span> = <span style="color: #F92672;">new</span> <span style="color: #66D9EF;">ReverseIterator</span><span style="color: #66D9EF;">()</span>;
  ...;
<span style="color: #AE81FF;">}</span>

<span style="color: #AE81FF;">IteratorProxy</span>::~<span style="color: #A6E22E;">IteratorProxy</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
  <span style="color: #F92672;">delete</span> m_iter;
<span style="color: #AE81FF;">}</span>

<span style="color: #66D9EF;">int</span> <span style="color: #A6E22E;">main</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
  <span style="color: #66D9EF;">IteratorProxy</span> <span style="color: #FD971F;">iter</span><span style="color: #66D9EF;">(</span>Type.Reverse<span style="color: #66D9EF;">)</span>;
  iter.next<span style="color: #66D9EF;">()</span>;
  ...;
  <span style="color: #F92672;">return</span> <span style="color: #AE81FF;">0</span>;
<span style="color: #AE81FF;">}</span>

</pre>
</div></li>
</ul>


<ul class="org-ul">
<li>仅在必须要使用多态时才使用。</li>
</ul>
</div>
</div>

<div id="outline-container-orgeeeac2f" class="outline-4">
<h4 id="orgeeeac2f"><span class="section-number-4">13.6.5</span> 迭代器与集合的紧密耦合</h4>
<div class="outline-text-4" id="text-13-6-5">
<p>
迭代器一般作为集合的一个扩展，两者之间是紧密耦合的。
</p>
</div>

<ul class="org-ul"><li><a id="org8fd4b47"></a>利用 C++友元实现<br /><div class="outline-text-5" id="text-org8fd4b47">
<p class="verse">
C++中迭代器可作为它的集合类的一个友元，<br />
这样集合类中就不必定义一些只有迭代器才用的到的方法。<br />
当然这破坏了集合类的封装性，但这点仅仅是针对迭代器而言的。<br />
<br />
问题：<br />
当定义新的 ConcreteIterator(为了增加新的遍历方式)时，需要为集合类加上另一个友元。<br />
<br />
解决办法：<br />
为避免该问题，集合类可定义迭代器父类为友元，<br />
迭代器子类通过包含一些 protected 操作，来访问集合类非公共可见成员。<br />
</p>
</div></li></ul>
</div>
<div id="outline-container-orgfa403c9" class="outline-4">
<h4 id="orgfa403c9"><span class="section-number-4">13.6.6</span> 与<a href="#org1626fd4">16</a>模式的协作</h4>
</div>
<div id="outline-container-orgbc10f70" class="outline-4">
<h4 id="orgbc10f70"><span class="section-number-4">13.6.7</span> 空迭代器</h4>
<div class="outline-text-4" id="text-13-6-7">
<p class="verse">
用于处理边界条件。<br />
一个 NullIterator 的 IsDone()总是返回 true，或者 HasNext()总是返回 false。<br />
<br />
提示：<br />
空迭代器更多的用于处理树形结构的集合。<br />
叶结点通常需要一个 NullIterator。<br />
</p>
</div>
</div>
</div>
<div id="outline-container-org78e0d84" class="outline-3">
<h3 id="org78e0d84"><span class="section-number-3">13.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-13-7">
<ul class="org-ul">
<li>迭代器可在<a href="#org1626fd4">Composite</a>模式这样的递归结构上使用。</li>
<li>多态迭代器可以通过<a href="#org818f1db">Factory Method</a>模式来实例化迭代器子类。</li>
<li>迭代器可使用一个 memento 来捕获一个迭代状态，即迭代器内部存储 memento。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org4e5397a" class="outline-2">
<h2 id="org4e5397a"><span class="section-number-2">14</span> 桥接模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="__">对象</span>&#xa0;<span class="___">结构型</span></span></h2>
<div class="outline-text-2" id="text-14">
<p>
<a id="orgf07c8a1"></a>
</p>
</div>
<div id="outline-container-org36eb447" class="outline-3">
<h3 id="org36eb447"><span class="section-number-3">14.1</span> 概述</h3>
<div class="outline-text-3" id="text-14-1">
<p>
分离抽象部分与实现部分，使得抽象部分也能被改变。
</p>
</div>
</div>
<div id="outline-container-org85bfbb5" class="outline-3">
<h3 id="org85bfbb5"><span class="section-number-3">14.2</span> 适用性</h3>
<div class="outline-text-3" id="text-14-2">
<ul class="org-ul">
<li>多用于需要跨多个平台的 GUI 部分。</li>
</ul>
</div>
</div>
<div id="outline-container-orge6c1986" class="outline-3">
<h3 id="orge6c1986"><span class="section-number-3">14.3</span> 结构</h3>
<div class="outline-text-3" id="text-14-3">

<div class="figure">
<p><img src="../resources/OO/Bridge.png" alt="Bridge.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgf479f7b" class="outline-3">
<h3 id="orgf479f7b"><span class="section-number-3">14.4</span> 优缺点</h3>
<div class="outline-text-3" id="text-14-4">
</div><div id="outline-container-orga4449a5" class="outline-4">
<h4 id="orga4449a5"><span class="section-number-4">14.4.1</span> 优点</h4>
<div class="outline-text-4" id="text-14-4-1">
<ul class="org-ul">
<li>将实现解耦，不再与界面(接口)绑定死。</li>
<li>接口也可独立扩展。</li>
<li>对接口扩展也不会影响到现有客户。</li>
</ul>
</div>
</div>
<div id="outline-container-org4afd56e" class="outline-4">
<h4 id="org4afd56e"><span class="section-number-4">14.4.2</span> 缺点</h4>
<div class="outline-text-4" id="text-14-4-2">
<ul class="org-ul">
<li>增加架构复杂度</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgb7d56d7" class="outline-3">
<h3 id="orgb7d56d7"><span class="section-number-3">14.5</span> 实现细节</h3>
<div class="outline-text-3" id="text-14-5">
</div><div id="outline-container-orgaa035e8" class="outline-4">
<h4 id="orgaa035e8"><span class="section-number-4">14.5.1</span> Implementor 具体对象的创建</h4>
<div class="outline-text-4" id="text-14-5-1">
<ul class="org-ul">
<li>可由 Abstraction 的构造方法的参数，在构造中确定创建哪个对象。</li>
<li>可提供缺省的创建，根据需要改变具体对象。</li>
<li><p>
代理给其他对象，由其他对象来决定。
</p>
<p class="verse">
比如，由一些 factory 对象来决定，可以使 Abstraction<br />
和 Implementor 对象彻底解耦。<br />
</p></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgce3f1eb" class="outline-3">
<h3 id="orgce3f1eb"><span class="section-number-3">14.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-14-6">
<p class="verse">
<a href="#org0bdb06f">Adapter</a> 通常在系统设计完成后才会被使用，Bridge 则在系统设计开始<br />
时就被使用，它使得抽象与实现可以独立的进行改变。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgfd62df5" class="outline-2">
<h2 id="orgfd62df5"><span class="section-number-2">15</span> 生成器模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">创建型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-15">
<p>
<a id="org03758c8"></a>
</p>
</div>
<div id="outline-container-orgf64d19c" class="outline-3">
<h3 id="orgf64d19c"><span class="section-number-3">15.1</span> 概述</h3>
<div class="outline-text-3" id="text-15-1">
<p>
将一个复杂对象的创建过程封装起来，提供接口创建复杂对象的各部件。
</p>
</div>
</div>
<div id="outline-container-org58b932e" class="outline-3">
<h3 id="org58b932e"><span class="section-number-3">15.2</span> 结构</h3>
<div class="outline-text-3" id="text-15-2">

<div class="figure">
<p><img src="../resources/OO/Builder.png" alt="Builder.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org1296bdf" class="outline-3">
<h3 id="org1296bdf"><span class="section-number-3">15.3</span> 角色</h3>
<div class="outline-text-3" id="text-15-3">
<ul class="org-ul">
<li><p>
Builder
</p>

<p>
为创建一个 Product 对象的各个部件指定抽象接口。
</p></li>

<li>ConcreteBuilder
<ul class="org-ul">
<li>实现 Builder 的接口以构造和装配该产品的各个部件</li>
<li>定义产品的内部表示，及其各部件的装配过程</li>
<li>提供一个检索产品的接口 GetResult</li>
</ul></li>

<li><p>
Director
</p>

<p>
构造一个使用 Builder 接口的对象
</p></li>
</ul>
</div>
</div>

<div id="outline-container-org5967b4b" class="outline-3">
<h3 id="org5967b4b"><span class="section-number-3">15.4</span> 流程图</h3>
<div class="outline-text-3" id="text-15-4">

<div class="figure">
<p><img src="../resources/OO/BuilderSeq.png" alt="BuilderSeq.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgb36fb64" class="outline-3">
<h3 id="orgb36fb64"><span class="section-number-3">15.5</span> 效果</h3>
<div class="outline-text-3" id="text-15-5">
<ul class="org-ul">
<li>只需定义一个新的生成器就可以改变产品内部表示</li>
<li>创建与表示分开，客户无需知道产品内部的部件类</li>
</ul>
</div>
</div>
<div id="outline-container-org8eb0859" class="outline-3">
<h3 id="org8eb0859"><span class="section-number-3">15.6</span> 实现</h3>
<div class="outline-text-3" id="text-15-6">
<ul class="org-ul">
<li><p>
产品不是抽象类？
</p>

<p>
通常具体生成器生成的产品之间相差很大，不太可能有公有接口。
</p></li>

<li>通常缺省 BuildPart 方法什么也不做，但非纯虚方法</li>
</ul>
</div>
</div>

<div id="outline-container-org670a3e9" class="outline-3">
<h3 id="org670a3e9"><span class="section-number-3">15.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-15-7">
<ul class="org-ul">
<li><a href="#orgd8efc7b">Abstract Factory</a>着重于多个系列产品对象，生成器专注于创建复杂对象，最后一步才返回产品。</li>
<li><a href="#org1626fd4">Composite</a>通常是用 Builder 生成的。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orge7e7da6" class="outline-2">
<h2 id="orge7e7da6"><span class="section-number-2">16</span> 组合模式&#xa0;&#xa0;&#xa0;<span class="tag"><span class="___">结构型</span>&#xa0;<span class="__">对象</span></span></h2>
<div class="outline-text-2" id="text-16">
<p>
<a id="org1626fd4"></a>
</p>
</div>
<div id="outline-container-orga7ead3e" class="outline-3">
<h3 id="orga7ead3e"><span class="section-number-3">16.1</span> 概述</h3>
<div class="outline-text-3" id="text-16-1">
<p class="verse">
将对象组合成树形结构，表现出“整体/部分”的层次。<br />
用户对于单个对象的使用和组合对象的使用具有一致性。<br />
</p>
</div>
</div>

<div id="outline-container-org7f09a76" class="outline-3">
<h3 id="org7f09a76"><span class="section-number-3">16.2</span> 结构</h3>
<div class="outline-text-3" id="text-16-2">

<div class="figure">
<p><img src="../resources/OO/Composite.png" alt="Composite.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org25cf59e" class="outline-3">
<h3 id="org25cf59e"><span class="section-number-3">16.3</span> 角色</h3>
<div class="outline-text-3" id="text-16-3">
<ul class="org-ul">
<li>Component
<ul class="org-ul">
<li>声明组合和叶对象的一致操作 Operation。</li>
<li>在适当情况下，实现所有类的默认行为。</li>
<li>声明用于访问和管理 Component 子部件的接口。</li>
</ul></li>
<li>Composite
<ul class="org-ul">
<li>实现有子部件的 Operation 行为。</li>
<li>存储子部件。</li>
<li>实现访问和管理子部件的接口。</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-orga711749" class="outline-3">
<h3 id="orga711749"><span class="section-number-3">16.4</span> 优点</h3>
<div class="outline-text-3" id="text-16-4">
<ul class="org-ul">
<li><p>
简化客户代码，客户可以一致的使用组合对象和叶对象。
</p>
<p class="verse">
用户不关心是何种对象，也就不需要写一些选择语句。<br />
</p></li>
<li>容易增加新类型的组件。</li>
</ul>
</div>
</div>

<div id="outline-container-org7eef859" class="outline-3">
<h3 id="org7eef859"><span class="section-number-3">16.5</span> 实现</h3>
<div class="outline-text-3" id="text-16-5">
<ul class="org-ul">
<li><p>
子部件可保存父部件的引用。
</p>
<p class="verse">
父部件引用也支持<a href="#orge72d58b">17</a>。<br />
父部件引用一般定义在 Component 类中。<br />
</p></li>

<li>共享组件，可减少对存储的需求。</li>

<li><p>
透明性与安全性的权衡
</p>
<p class="verse">
如需更多的透明性，将操作子部件的 Add 操作和 Remove 操作在 Component 类中定义。<br />
如需更高的安全性，将这些操作在 Composite 类中定义。安全性会需要用到类型转换。<br />
</p></li>
<li><p>
存储子结点的引用集合
</p>
<p class="verse">
对于叶结点而言，会有一定的空间浪费，需考虑。<br />
</p></li>
<li><p>
子部件顺序问题
</p>
<p class="verse">
有时候子结点的顺序可能是有意义的。比如语法分析树。<br />
这时候需要仔细设计对子结点的访问和管理接口，可使用 Iterator 模式。<br />
</p></li>
<li>Composite 存储子结点的数据结构是可选的</li>
</ul>
</div>
</div>

<div id="outline-container-orgac2ff48" class="outline-3">
<h3 id="orgac2ff48"><span class="section-number-3">16.6</span> 相关模式</h3>
<div class="outline-text-3" id="text-16-6">
<ul class="org-ul">
<li>部件到父部件的连接使用<a href="#orge72d58b">Chain of Responsibility</a></li>
<li><a href="#orgab8f698">Decorator</a>与 Composite 模式很像，事实上他们经常可以一起使用。</li>
<li>Flyweight 可以帮助实现共享组件。</li>
<li><a href="#org7b06bdc">Iterator</a>可用来遍历 Composite 子部件。</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgcaf2ec3" class="outline-2">
<h2 id="orgcaf2ec3"><span class="section-number-2">17</span> 责任链模式</h2>
<div class="outline-text-2" id="text-17">
<p>
<a id="orge72d58b"></a>
</p>
</div>
<div id="outline-container-orgcdda184" class="outline-3">
<h3 id="orgcdda184"><span class="section-number-3">17.1</span> 概述</h3>
<div class="outline-text-3" id="text-17-1">
<p class="verse">
使多个对象都有机会处理请求，将这些对象连成一条链，沿着该链传递该请求，<br />
直到有对象处理该请求为止。<br />
通俗点讲，每个处理对象能处理请求就处理掉，否则就扔给下一个处理对象。<br />
</p>
</div>
</div>

<div id="outline-container-org7d7a3ff" class="outline-3">
<h3 id="org7d7a3ff"><span class="section-number-3">17.2</span> 结构</h3>
<div class="outline-text-3" id="text-17-2">

<div class="figure">
<p><img src="../resources/OO/ChainOfResponsibility.png" alt="ChainOfResponsibility.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-org5438d67" class="outline-3">
<h3 id="org5438d67"><span class="section-number-3">17.3</span> 适用性</h3>
<div class="outline-text-3" id="text-17-3">
<ul class="org-ul">
<li>经常被用来处理鼠标键盘事件。</li>
<li>过滤器的实现可参考责任链模式。</li>
</ul>
</div>
</div>

<div id="outline-container-orge5bc079" class="outline-3">
<h3 id="orge5bc079"><span class="section-number-3">17.4</span> 优点</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li><p>
降低耦合度
</p>

<p>
请求者不关心谁处理了请求。责任链中对象也无需知道链结构。
</p></li>

<li>可以动态地增加修改 Handler 对象</li>
</ul>
</div>
</div>

<div id="outline-container-org0e9ba05" class="outline-3">
<h3 id="org0e9ba05"><span class="section-number-3">17.5</span> 缺点</h3>
<div class="outline-text-3" id="text-17-5">
<ul class="org-ul">
<li>不保证请求一定会被处理。</li>
<li>不容易观察运行时特征，不利于除错。</li>
</ul>
</div>
</div>

<div id="outline-container-org7890075" class="outline-3">
<h3 id="org7890075"><span class="section-number-3">17.6</span> 实现</h3>
<div class="outline-text-3" id="text-17-6">
</div><div id="outline-container-org767390f" class="outline-4">
<h4 id="org767390f"><span class="section-number-4">17.6.1</span> 后继者实现</h4>
<div class="outline-text-4" id="text-17-6-1">
<p class="verse">
通常 Handler 类维护后继者链接，并提供默认实现向后继者转发请求。<br />
如果 ConcreteHandler 类对该请求不感兴趣，它只需要用到默认实现转发请求即可。<br />
</p>
</div>
</div>

<div id="outline-container-org660287d" class="outline-4">
<h4 id="org660287d"><span class="section-number-4">17.6.2</span> 请求的表示</h4>
<div class="outline-text-4" id="text-17-6-2">
<ul class="org-ul">
<li><p>
单一类型请求
</p>

<p>
通过一个 hard-coded 操作调用，这种方式方便安全。
</p></li>

<li><p>
多个类型的一组请求
</p>

<p>
处理函数参数需要一个请求码，用条件语句区分请求码以分派请求。
</p></li>

<li>使用独立的请求对象</li>
</ul>
</div>
</div>

<div id="outline-container-orgfb77d17" class="outline-4">
<h4 id="orgfb77d17"><span class="section-number-4">17.6.3</span> 终极 Handler</h4>
<div class="outline-text-4" id="text-17-6-3">
<p>
责任链不保证请求一定会被处理，可以在最后加个终极处理器处理这种情况。
</p>
</div>
</div>
</div>


<div id="outline-container-orgf170810" class="outline-3">
<h3 id="orgf170810"><span class="section-number-3">17.7</span> 相关模式</h3>
<div class="outline-text-3" id="text-17-7">
<p class="verse">
责任链通常与<a href="#org1626fd4">Composite</a>一起使用。一个部件的后继者可以是它的父部件。<br />
子部件能处理则处理，不能处理则一层层交由父部件处理。<br />
</p>
</div>
</div>
</div>

<div id="outline-container-org79554fc" class="outline-2">
<h2 id="org79554fc"><span class="section-number-2">18</span> 一些 OO 提示</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-orgd207296" class="outline-3">
<h3 id="orgd207296"><span class="section-number-3">18.1</span> 活用空对象来避免 null 值检查</h3>
<div class="outline-text-3" id="text-18-1">
<div class="org-src-container">
<pre class="src src-cpp"><span style="color: #F92672;">class</span> <span style="color: #66D9EF;">Object</span>
<span style="color: #AE81FF;">{</span>
<span style="color: #F92672;">public</span>:
    vitual <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">DoSomething</span><span style="color: #66D9EF;">()</span> = <span style="color: #AE81FF;">0</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #F92672;">class</span> <span style="color: #66D9EF;">NullObject</span> : <span style="color: #F92672;">public</span> <span style="color: #66D9EF;">Object</span>
<span style="color: #AE81FF;">{</span>
<span style="color: #F92672;">public</span>:
    <span style="color: #66D9EF;">void</span> <span style="color: #A6E22E;">DoSomething</span><span style="color: #66D9EF;">()</span>;
<span style="color: #AE81FF;">}</span>;

<span style="color: #66D9EF;">void</span> <span style="color: #AE81FF;">NullObject</span>::<span style="color: #A6E22E;">DoSomething</span><span style="color: #AE81FF;">()</span>
<span style="color: #AE81FF;">{</span>
    <span style="color: #75715E;">//</span><span style="color: #75715E;">do nothing</span>
<span style="color: #AE81FF;">}</span>
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
hook 操作缺省经常是一个空操作。空操作的意义：某些子类可能需要一些"特别"的操作，而大部分子类不需要。
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
继承是在编译时静态扩展父类的职责，装饰者模式是动态的添加职责。
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
实现 MapReduce 中"Map"的一种方式。
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
具体代码示例参照《Gof 设计模式》5.4 10
</p></div></div>


</div>
</div></div>
</body>
</html>
